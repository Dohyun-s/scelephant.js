<!doctype html>
<html lang="en">
<head>
<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="SC-Elephant Viewer">
<title>SC-Elephant DB Viewer</title>
    
<!-- bootstrap5 -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">

<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js" integrity="sha256-qXBd/EfAdjOA2FGrGAG+b3YBn2tn5A6bhz+LSgYD96k=" crossorigin="anonymous"></script>
<script> lodash = _.noConflict(); // load script of lodash </script>     
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><!-- JQuery -->
<script src="https://cdn.plot.ly/plotly-2.14.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js" integrity="sha512-zInFF17qBFVvvvFpIfeBzo7Tj7+rQxLeTJDmbxjBz5/zIr89YVbTNelNhdTT+/DCrxoVzBeUPVFJsczKbB7sew==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- for colormaps -->
<script src="https://cdn.jsdelivr.net/npm/hotkeys-js@3.8.1/dist/hotkeys.min.js" integrity="sha256-4nmnbhmVpr2Rg64+7ysAr93+vQrfc0UvHWwm4W6uXJM=" crossorigin="anonymous"></script><!--hotkeys to add keyboard shortcuts-->
    
<!-- 
<script type="module">
  import * as zarr from "https://cdn.skypack.dev/zarrita/v2";
  import { get } from "https://cdn.skypack.dev/zarrita/ops";
  import FetchStore from "https://cdn.skypack.dev/zarrita/storage/fetch";
  // must add codecs to global registry if compression is used
  import Blosc from "https://cdn.skypack.dev/numcodecs/blosc";
  zarr.registry.set( Blosc.codecId, () => Blosc );
  
  // add to top level
  window.zarr = zarr;
  window.get = get;
  window.Blosc = Blosc
  window.FetchStore = FetchStore
</script> -->
    
<!-- ES import -->
<script type="module">
    // import * as dataframeJs from 'https://cdn.skypack.dev/dataframe-js';
    import * as papaparse from 'https://cdn.skypack.dev/papaparse';
    window.Papa = papaparse;
    import * as pako from 'https://cdn.skypack.dev/pako';
    window.pako = pako;
    
    // import modules for plotting
//     import Plotly from 'https://cdn.skypack.dev/plotly.js'; // cannot be imported from skypack...
//     import * as chromaJs from 'https://cdn.skypack.dev/chroma-js';
//     import * as d3 from 'https://cdn.skypack.dev/d3';
    
//     // import modules for interactions
//     import datatablesNet from 'https://cdn.skypack.dev/datatables.net';
//     import yaireoTagify from 'https://cdn.skypack.dev/@yaireo/tagify';
//     import hotkeysJs from 'https://cdn.skypack.dev/hotkeys-js';
//     import html2canvas from 'https://cdn.skypack.dev/html2canvas';
//     import fileSaver from 'https://cdn.skypack.dev/file-saver';
//     import fontAwesome from 'https://cdn.skypack.dev/font-awesome';
    
//     // import Zarrita
//     import * as zarrita from "https://cdn.skypack.dev/zarrita/v2";
//     import { get } from "https://cdn.skypack.dev/zarrita/ndarray"; // "https://cdn.skypack.dev/zarrita/ops";
//     import FetchStore from "https://cdn.skypack.dev/zarrita/storage/fetch";
//     import Blosc from "https://cdn.skypack.dev/numcodecs/blosc";
//     zarrita.registry.set(Blosc.codecId, () => Blosc); // using compression
//     window.Blosc = Blosc
//     window.zarrita = zarrita;
//     window.zarrita_get = get;
//     window.zarrita_FetchStore = FetchStore;
    
    // import Zarr
    import * as zarr from "https://cdn.skypack.dev/zarr";
    window.zarr = zarr;
    
    // import bitset for BitArray
    import bitset from 'https://cdn.skypack.dev/bitset';
    window.BitSet = bitset;
    
//     // import umap.js for embedding
//     import * as umapJs from 'https://cdn.skypack.dev/umap-js';
//     window.umapJs = umapJs;
    
//     // import hdbscan for clustering
//     import * as hdbscan from 'https://cdn.skypack.dev/hdbscan';
//     window.hdbscan = hdbscan;
    
//     // import pca for dimension reduction
//     import * as mlPca from 'https://cdn.skypack.dev/ml-pca';
//     window.mlPca = mlPca;
</script>

<style>

</style>

</head>

<body>
<nav class="navbar navbar-expand-lg bg-light">
  <div class="container-fluid">
    <a class="navbar-brand" href="#">SC-Elephant DB</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item">
          <a class="nav-link active" data-bs-toggle="offcanvas" data-bs-target="#offcanvasLoadRamData" aria-controls="offcanvasLoadRamData">1) Load RamData</a>
        </li>
        <li class="nav-item">
          <a class="nav-link active" data-bs-toggle="offcanvas" data-bs-target="#offcanvasRetrieveAnnData" aria-controls="offcanvasRetrieveAnnData">2) Retrieve AnnData</a>
        </li>
        <li class="nav-item">
          <a class="nav-link active" data-bs-toggle="offcanvas" data-bs-target="#offcanvasPlotAnnData" aria-controls="offcanvasPlotAnnData">3) Plot AnnData</a>
        </li>
<!--         <li class="nav-item">
          <a class="nav-link" href="#">Link</a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            Dropdown
          </a>
          <ul class="dropdown-menu">
            <li><a class="dropdown-item" href="#">Action</a></li>
            <li><a class="dropdown-item" href="#">Another action</a></li>
            <li><hr class="dropdown-divider"></li>
            <li><a class="dropdown-item" href="#">Something else here</a></li>
          </ul>
        </li>
        <li class="nav-item">
          <a class="nav-link disabled">Disabled</a>
        </li> -->
      </ul>
<!--       <form class="d-flex" role="search">
        <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
        <button class="btn btn-outline-success" type="submit">Search</button>
      </form> -->
    </div>
  </div>
</nav>
    
<div class="content" id="canvas">
</div>
<nav class="navbar navbar-light bg-light">
  <div class="container-fluid">
    RamData, SC-Elephant, SC-Elephant.js, and ELDB were developed by Hyunsu An at the Gwangju Institute of Science and Technology under the supervision of Professor JiHwan Park.<br>Â© 2022 Functional Genomics Lab, Gwangju Institute of Science and Technology
  </div>
</nav>
    
<!-- offcanvases -->
<div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasLoadRamData" aria-labelledby="offcanvasLoadRamDataLabel">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" id="offcanvasLoadRamDataLabel">Load RamData</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="offcanvas-body">
    <div class="d-grid gap-2">
        <button class="btn btn-primary" type="button" onclick="LoadRamData( )">Load RamData</button>
    </div>
    <br>
    <label for="select_ramdata_object" class="form-label">Select RamData Object</label>
    <select class="form-select" aria-label="select_ramdata_object" id="select_ramdata_object">
    </select>
    <br>
        
  </div>
</div>
    
<!-- offcanvas -->
<div class="offcanvas offcanvas-bottom" tabindex="-1" id="offcanvasRetrieveAnnData" aria-labelledby="offcanvasRetrieveAnnDataLabel" style="height: 90vh">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" id="offcanvasRetrieveAnnDataLabel">Retrieve AnnData from RamData</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="d-grid mx-3 gap-2">
    <button class="btn btn-primary" type="button" onclick="RetrieveAnnData( )">Retrieve AnnData</button>
  </div>
  <div class="offcanvas-body">
    <div class="form-floating">
        <textarea class="form-control" placeholder="adata" id="input_str_name_adata_output"></textarea>
        <label for="floatingTextarea">Output AnnData Name</label>
    </div>
    <br>
      
    <div id="div_repr_bc">
        <h5>Barcode Axis</h5>
    </div>
        
    <label for="select_filter_bc" class="form-label">Select Barcode Filter</label>
    <select class="form-select" aria-label="select_filter_bc" id="select_filter_bc">
    </select>
    <br>
      
    <label for="select_annotations_bc" class="form-label">Select Barcode Annotations</label>
    <select class="form-select" multiple aria-label="select_annotations_bc" id="select_annotations_bc" style="height: 150px">
    </select>
    <br>
      
    <label for="select_embedding" class="form-label">Select Embeddings</label>
    <select class="form-select" multiple aria-label="select_embedding" id="select_embedding" style="height: 150px">
    </select>
    <br>
      
    <div id="div_repr_ft">
      <h5>Feature Axis</h5>
    </div>
      
    <label for="select_filter_ft" class="form-label">Select Feature Filter</label>
    <select class="form-select" aria-label="select_filter_ft" id="select_filter_ft">
    </select>
    <br>
      
    <div class="form-floating">
        <textarea class="form-control" placeholder="Leave a comment here" id="input_str_gene_names" style="height: 150px"></textarea>
        <label for="input_str_gene_names">Gene Symboles (separated by comma)</label>
    </div>
    <br>
      
    <div>
      <h5>Layer</h5>
    </div>
        
    <label for="select_layer" class="form-label">Select Layer</label>
    <select class="form-select" aria-label="select_layer" id="select_layer">
    </select>
    <br>
  </div>
</div>
    
<!-- offcanvas -->
<div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvasPlotAnnData" aria-labelledby="offcanvasPlotAnnDataLabel">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" id="offcanvasPlotAnnDataLabel">Plot AnnData</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="d-grid mx-3 gap-2">
    <button class="btn btn-primary" type="button" onclick="PlotAnnData( )">Plot AnnData</button>
  </div>
  <div class="offcanvas-body">
    <div class="form-floating">
        <select class="form-select" aria-label="select_adata" id="select_adata">
        </select>
      <label for="select_adata" class="form-label">Select AnnData</label>
    </div>
    <br>
      
    <div>
      <h5>Data</h5>
    </div>
      
    <div class="btn-group d-flex justify-content-center" role="group" aria-label="Basic radio toggle button group">
      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_feature" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_feature">Feature</label>

      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_obs" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_obs">Annotation</label>

      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_feature_and_obs" autocomplete="off" checked>
      <label class="btn btn-outline-primary" for="radio_select_type_graph_feature_and_obs">Both</label>

      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_violin" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_violin">Violin</label>
    </div>
    <br>

    <div class="form-floating">
        <select class="form-select" aria-label="select_str_entry_ft" id="select_str_entry_ft">
        </select>
      <label for="select_str_entry_ft" class="form-label">Select Feature Entry</label>
    </div>
      
    <div class="form-floating">
        <select class="form-select" aria-label="select_annotations_bc_for_plot" id="select_annotations_bc_for_plot">
        </select>
      <label for="select_annotations_bc_for_plot" class="form-label">Select Barcode Annotation</label>
    </div>
      
    <div class="form-floating">
        <textarea class="form-control" placeholder="10" id="input_float_vmax"></textarea>
        <label for="input_float_vmax">maximum value cutoff</label>
    </div>
    <br>
      
    <div>
      <h5>Coordinates</h5>
    </div>
      
    <label for="select_embedding_for_plot" class="form-label">Select Embedding</label>
    <select class="form-select" aria-label="select_embedding_for_plot" id="select_embedding_for_plot">
    </select>
    <br>
      
    <div>
      <h5>Figure</h5>
    </div>
    <div class="form-floating">
        <textarea class="form-control" placeholder="ELDB" id="input_str_name_panel"></textarea>
        <label for="input_str_name_panel">Output Panel Name (no white spaces)</label>
    </div>
    <br>
      
    <div class="form-floating">
        <textarea class="form-control" placeholder="sc-elephant database" id="input_str_name_figure"></textarea>
        <label for="input_str_name_figure">Output Figure Name</label>
    </div>
    <br>
      
    <div>
      <h5>Figure Size</h5>
    </div>
    <div class="row g-2">
      <div class="col-md">
        <div class="form-floating">
            <textarea class="form-control" placeholder="1200" id="input_int_fig_size_x"></textarea>
            <label for="input_int_fig_size_x">Width (pixels)</label>
        </div>
      </div>
      <div class="col-md">
        <div class="form-floating">
            <textarea class="form-control" placeholder="1000" id="input_int_fig_size_y"></textarea>
            <label for="input_int_fig_size_y">Height (pixels)</label>
        </div>
      </div>
    </div>
    <br>
    
    <div>
      <h5>Marker (Point) Size</h5>
    </div>
    <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="switch_responsive_marker_size_or_static">
        <label class="form-check-label" for="switch_responsive_marker_size_or_static">Responsive Marker (Point) Size</label>
    </div>
    <div class="form-floating">
        <textarea class="form-control" placeholder="3" id="input_int_marker_size"></textarea>
        <label for="input_int_marker_size">Marker Size (pixels)</label>
    </div>
    <br>
    <br>
        
  </div>
</div>
    
<!-- bootstrap5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
    
<script>

/*
Implementation of RamData.js [START]
*/
// functions from the external references
// set operations
function isSuperset(set, subset) {
  for (const elem of subset) {
    if (!set.has(elem)) {
      return false;
    }
  }
  return true;
}
function union(setA, setB) {
  const _union = new Set(setA);
  for (const elem of setB) {
    _union.add(elem);
  }
  return _union;
}
function intersection(setA, setB) {
  const _intersection = new Set();
  for (const elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem);
    }
  }
  return _intersection;
}
function symmetricDifference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    if (_difference.has(elem)) {
      _difference.delete(elem);
    } else {
      _difference.add(elem);
    }
  }
  return _difference;
}
function difference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}
    
// string functions
function isString ( value ) { // Returns if a value is a string
    return typeof value === 'string' || value instanceof String;
}
// define hashing funciton of string
Object.defineProperty(String.prototype, 'hashCode', {
        value: function() {
            var hash = 0, i, chr;
            for (i = 0; i < this.length; i++) {
                chr   = this.charCodeAt(i);
                hash  = ((hash << 5) - hash) + chr;
                hash |= 0; // Convert to 32bit integer
            }
        return hash;
    }
});
    
// implemented functions
function check_none( val ) {
    // check whether the given value 'val' is either undefined or null
    return ( val === undefined ) | ( val === null );
}
function sort_number( a, b ) {
    return a - b;
}
function count_ba( ba, length ) {
    // count the number of active entries in the given BitSet object 'ba' of the given length 'length'
    let int_num_active_entries = 0;
    for ( let i = 0; i < length; i ++ ) {
        int_num_active_entries += ba.get( i );
    }
    return int_num_active_entries;
}
function ba_to_integer_indices( ba, length ) {
    /*
    convert BitSet array to an array of integer indices of the active entries
    */
    // initialize the list of integer indices
    let l_int_index = [ ];
    for ( let i = 0; i < length; i ++ ) {
        if ( ba.get( i ) > 0 ) {
            l_int_index.push( i );
        }
    }
    return l_int_index;
}
function to_ba( arr ) {
    /*
    convert arrays to a BitSet object
    */
    // if BitSet object is given, return the object and exit
    if ( arr instanceof BitSet ) {
        return arr;
    }

    // if 'NestedArray' is given, check shape and flatten the array
    if ( arr instanceof zarr.NestedArray ) {
        // if a given 'arr' is a NestedArray, check its shape (the length of the filter should be same as the number of rows of the current object)
        if ( ! ( arr.shape.length == 1 ) ) {
            if ( this.verbose ) {
                console.log( "the shape of the given filter is invalid, exiting" );
            }
            return;
        }
        arr = arr.flatten( ); // flatten the nested array

    } else if ( arr instanceof Int8Array ) {
        // if flattened 'Int8Array' is given, check shape
        // if the length of the given array is different from the number of rows of the object
    } else {
        if ( this.verbose ) {
            console.log( "date type of given input is invalid" );
        }
        return;
    }
    // initialize BitSet object
    let ba = new BitSet,
        i = 0,
        val = 0;
    // set BitSet object
    for ( i = 0; i < arr.length ; i ++ ) {
        val = arr[ i ];
        if ( val != 0 ) {
            ba.set( i, 1 )
        }
    }
    return ba;
}
function ParseBase64GzippedText( str_base64_gzipped ) {
    // Decode base64 (convert ascii to binary) // Convert binary string to character-number array // Turn number array into byte-array // Convert gunzipped byteArray back to ascii string:
    let l_char = pako.inflate( new Uint8Array( atob( str_base64_gzipped ).split( '' ).map( function( x ) { return x.charCodeAt( 0 ); } ) ) ); 
    let str_content = ""; // convert ASCII value to character and concatenate the characters into a string
    for ( let i = 0; i < l_char.length; i ++ ) {
        str_content += String.fromCharCode( l_char[ i ] );
    }
    return str_content;
}
function ParseTransposedArrayWithHeader( l_l ) { // return a dictionary of arrays ( similar to the DataFrame.toDict() output ) from an array of arrays
    let dictarr = { };
    for ( let i = 0; i < l_l.length; i ++ ) {
        let key = l_l[ i ].shift( );
        dictarr[ key ] = l_l[ i ];
    }
    return dictarr;
}

// sparse matrix
class SparseMatrix {
    /*
    a class for storing 2D sparse matrix 
    l_arr_data : an array containing the following arrays:
        l_int_index_for_querying : a list of int_index values for querying
        l_l_int_index_not_for_querying : a list of lists containing int_index of the axis not for querying
        l_l_value : a list of lists containing values
    shape // shape of the sparse matrix. required for to_dense operation
    is_for_querying_primary_axis // is the axis for querying is primary, set this flag to true. 
    */
    constructor( l_arr_data, shape, is_for_querying_primary_axis = true, verbose = true ) {
        /*
        */
        // set attributes
        this.is_for_querying_primary_axis = is_for_querying_primary_axis;
        this.shape = shape;
        // set attributes
        this.length = this.shape[ ( this.is_for_querying_primary_axis ) ? 0 : 1 ]; // retrieve the number of queries 
        if ( l_arr_data instanceof Array ) {
            // construct a sparse matrix from the array input
            // validate input
            if ( l_arr_data.length != 3 ) {
                if ( this.verbose ) {
                    console.log( 'invalid input. the length of the array should be 3.' )
                }
                return;
            }
            let int_num_entries_axis_for_querying_with_data = l_arr_data[ 0 ].length;
            if ( int_num_entries_axis_for_querying_with_data == 0 ) {
                if ( this.verbose ) {
                    console.log( 'the number of entries is zero.' )
                }
                return;
            }
            this._data = { }
            for ( let i = 0; i < int_num_entries_axis_for_querying_with_data; i ++ ) {
                let int_index_for_querying = l_arr_data[ 0 ][ i ],
                    l_int_index_not_for_querying = l_arr_data[ 1 ][ i ],
                    l_value = l_arr_data[ 2 ][ i ];
                this._data[ int_index_for_querying ] = [ l_int_index_not_for_querying, l_value ];
            }
        } else if ( l_arr_data instanceof Object ) {
            // build a sparse matrix from the Object input
            this._data = l_arr_data; // use the given object directly as the data source
        }
    }
    subset( args ) {
        /*
        args : an integer or list of integer indices for the axis for querying
        
        return a subset of the current sparse matrix that contains entries of a given list of integer indices for the current axis for querying 
        */
        // if a single integer was given, 
        if ( typeof args == 'number' ) {
            args = [ args ];
        }
        // retrieve a list of all the integer indices for the axis for querying for subsetting
        let l_int_entry_subset = [ ... intersection( new Set( args ), new Set( Object.keys( this._data ).map( ( x ) => { return parseInt( x ); } ) ) ) ].sort( sort_number ), // sort by int_entry // convert integers converted to strings back to integers
            data_subset =  { }, // initialize a new data that will contain a subset of the sparse matrix
            int_entry_new = 0; // 'int_entry_new' after subsetting
        // subset array
        for ( let int_entry of l_int_entry_subset ) {
            data_subset[ int_entry_new ] = this._data[ int_entry ]; // retrieve data
            int_entry_new += 1; // update 'int_entry_new' 
        }
        // set new shape
        let shape_new = [ ... this.shape ];
        shape_new[ ( this.is_for_querying_primary_axis ) ? 0 : 1 ] = int_entry_new; // compose the new shape. now the length of the axis for querying should be the number of entries that were used in the subsetting
        return new SparseMatrix( data_subset, shape_new, this.is_for_querying_primary_axis ); // return a new SparseMatrix object containing a subset of data
    }
    to_dense( dtype = 'float64' ) {
        /*
        return a dense matrix (using Array) of the current sparse matrix
        */
        let arr = nj.zeros( this.shape, dtype ); // initialize the dense array using numjs
        for ( let int_entry in Object.keys( this._data ) ) { // iterate over the int_entry for querying
            let res = this._data[ int_entry ],
                l_int_index_not_for_querying = res[ 0 ],
                l_value = res[ 1 ];
            for ( let i = 0; i < l_value.length; i ++ ) {
                let int_index_not_for_querying = l_int_index_not_for_querying[ i ],
                    value = l_value[ i ];
                // set value
                if ( this.is_for_querying_primary_axis ) {
                    arr.set( int_entry, int_index_not_for_querying, value ); // set value
                } else {
                    arr.set( int_index_not_for_querying, int_entry, value ); // set value
                }
            }
        }
        return arr; // return a dense numjs array
    }
}
class DataFrame {
    /*
    name_col_index : name of the index.
    length : the number of rows of the dataframe
    */
    constructor( dict_data, name_col_index = undefined, length = undefined, verbose = true ) {
        /*
        retrieve length of dataframe
        */
        if ( check_none( length ) ) {
            if ( Object.keys( dict_data ).length == 0 ) {
                if ( verbose ) {
                    console.log( 'Error, dict_data is empty yet length is not given, exiting' );
                }
                return;
            }
            let col = dict_data[ Object.keys( dict_data )[ 0 ] ]; // retrieve any column
            length = check_none( col.length ) ? col.shape[ 0 ] : col.length; // retrieve the length of a dataframe
        }
        this.length = length;
        this._dict_data = dict_data; // add data
        
        // set columns attribute (a set of column names)
        this.columns = new Set( Object.keys( this._dict_data ) );
        
        /*
        Build Index of DataFrame
        */
        let flag_use_default_index = check_none( name_col_index ) | ( ! this.columns.has( name_col_index ) ), // retrieve a flag indicating whether a default index should be used.
            arr_index = flag_use_default_index ? nj.arange( this.length ).tolist( ) : this._dict_data[ name_col_index ], // use integer indices by default
            dict_mapping_index = { }; // initialize a dictionary for mapping
        for ( let i = 0; i < arr_index.length; i ++ ) {
            let e = arr_index[ i ]; // retrieve index value at 'i'
            if ( ! ( e in dict_mapping_index ) ) {
                dict_mapping_index[ e ] = [ ];
            }
            dict_mapping_index[ e ].push( i );
        }
        this._dict_mapping_index = dict_mapping_index;
        this.name_col_index = flag_use_default_index ? undefined : name_col_index; // retrieve the name_col for building an index // update a name_col used for building an index
    }
    set_index( name_col_index ) {
        /*
        set index of a DataFrame object
        */
        let flag_use_default_index = check_none( name_col_index ) | ( ! this.columns.has( name_col_index ) ), // retrieve a flag indicating whether a default index should be used.
            arr_index = flag_use_default_index ? nj.arange( this.length ).tolist( ) : this._dict_data[ name_col_index ], // use integer indices by default
            dict_mapping_index = { }; // initialize a dictionary for mapping
        for ( let i = 0; i < arr_index.length; i ++ ) {
            let e = arr_index[ i ]; // retrieve index value at 'i'
            if ( ! ( e in dict_mapping_index ) ) {
                dict_mapping_index[ e ] = [ ];
            }
            dict_mapping_index[ e ].push( i );
        }
        this._dict_mapping_index = dict_mapping_index;
        this.name_col_index = flag_use_default_index ? undefined : name_col_index; // retrieve the name_col for building an index // update a name_col used for building an index
    }
    add_column( name_col, arr_val ) {
        /*
        add a new column to the dataframe
        
        name_col : the name of new column
        arr_val : array of values
        */
        let length_new_col = check_none( arr_val.length ) ? arr_val.shape[ 0 ] : arr_val.length; // retrieve the length of the new column
        if ( length_new_col == this.length ) { // check the length of the new column is the same as the length of the current dataframe
            this._dict_data[ name_col ] = arr_val; // add/update the column of the dataframe
            this.columns.add( name_col ); // add the column name to the columns attribute.
        }
    }
    get_column( name_col ) {
        /*
        retrieve values of the column
        */
        if ( this.columns.has( name_col ) ) { // check whether the current dataframe contains 'name_col' column
            return this._dict_data[ name_col ]; // return the values of the column
        }
    }
    get_integer_indices_of_rows( l_index_value = undefined ) {
        /*
        retrieve integer indices of rows according to the given row index values
        
        'l_index_value' // a list of index values ('row') for retrieving integer indices 
        */
        // retrieve l_int_index for the subset
        let l_int_index = [ ];
        if ( check_none( l_index_value ) ) {
            l_int_index = nj.arange( this.length ).tolist( ); // if no selection was given, use the integer indices of all rows.
        } else {
            for ( let index_val of l_index_value ) {
                if ( index_val in this._dict_mapping_index ) { // check 'index_val' exists in the dataframe
                    l_int_index.push( ... this._dict_mapping_index[ index_val ] )
                }
            }
        }
        return l_int_index;
    }
    subset( l_index_value = undefined, l_column_value = undefined ) {
        /* 
        return a subset of dataframe according to 'l_index_value' and 'l_column_value'
        */
        // retrieve l_int_index for the subset
        let l_int_index = this.get_integer_indices_of_rows( l_index_value );
        
        // retrieve a subset of data
        let dict_data_subset = { }; // initialize dict_data of a new dataframe
        for ( let col of l_column_value ) {
            if ( col in this._dict_data ) { // if column name exists in the dataframe
                let arr_val_subset = [ ], // initialize the array that will contain a subset of data
                    arr_val = this._dict_data[ col ], // retrieve values of the column
                    flag_is_array = arr_val instanceof Array; // retrieve 'flag_is_array' indicating whether 'arr_val' is an instance of Array
                for ( let int_index of l_int_index ) { // for each 'int_index'
                    arr_val_subset.push( flag_is_array ? arr_val[ int_index ] : arr_val.get( int_index ) ); // retrieve values from NestedArray (class from Zarr.js)
                }
                dict_data_subset[ col ] = arr_val_subset; // retrieve the subset 
            }
        }
        return new DataFrame( dict_data_subset, this.name_col_index, l_int_index.length ); // return a subset of DataFrame, using the same index as the current DataFrame
    }
}
// AnnData
class AnnData {
    /*
    a javascript object for containing an AnnData data object
    
    X : a sparse/dense/empty matrix containing expression data.
    */
    constructor( X = undefined, df_obs = { }, df_var = { }, dict_data_obsm = { }, dict_data_varm = { }, dict_data_uns = { }, verbose = true ) {
        /*
        */
        // set attributes
        this.verbose = verbose;
        
        // check inputs
        if ( ! ( check_none( X ) | ( X instanceof nj.NdArray ) | ( X instanceof SparseMatrix ) ) ) { // X should be an empty value, numjs array, or a sparse matrix.
            if ( this.verbose ) {
                console.log( 'invalid X was given, exiting' )
            }
            return;
        }
        // set attributes
        this.X = X; // sparse/dense matrix
        this.obs = df_obs; // dataframe
        this.var = df_var;
        this.obsm = dict_data_obsm;
        this.varm = dict_data_varm;
        this.uns = dict_data_uns;
    }
    repr( ) {
        /*
        a function to represent AnnData in the javascript
        */
        return `<AnnData object>` // return string representation of the AnnData
        
    }
}
    
class ZarrDataFrame {
    constructor( path_folder_zdf, filter = undefined, flag_retrieve_categorical_data_as_integers = false, verbose = true ) {
        // set attributes
        this.path_folder_zdf = path_folder_zdf;
        this.filter = filter;
        this.flag_retrieve_categorical_data_as_integers = flag_retrieve_categorical_data_as_integers;
        this.verbose = verbose;
        // initialize attributes
        this._columns = { };
    }
    async initialize( ) {
        // load metadata of zarrdataframe
        // should be run before using zdf
        let zattrs = await $.getJSON( `${this.path_folder_zdf}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        this.metadata.columns = new Set( this.metadata.columns ) // convert an array of columns to a set of columns
        
        // set attributes using the metadata
        this.columns = this.metadata.columns;
        this._n_rows_unfiltered = this.metadata.int_num_rows;
        this.set_filter( this.filter ); // set filter once metadata is loaded_
        this._int_num_rows_in_a_chunk = this.metadata.int_num_rows_in_a_chunk;
    }
    async load_column( name_col ) {
        // load metadata if it has not been loaded
        if ( check_none( this.metadata ) ) {
            await this.initialize( );
        }
        
        // load zarr object and metadata of a given column name
        if ( this.columns.has( name_col ) & ! ( name_col in this._columns ) ) {
            let za = await zarr.openArray({
                store : this.path_folder_zdf,
                path : `${name_col}/`,
                mode: "r"
            });
            // if binary data encoded in '|i1' format ('b1') format was detected, change dtype to '|i1', since '|b1' is currently not supported in the Zarr.js implementation
            if ( za.meta.dtype == '|b1' ) {
                za.meta.dtype = '|i1'; // change dtype to '|i1'
            }
            this._columns[ name_col ] = { 
                'zarr_object' : za,
                'metadata' : ( await $.getJSON( `${this.path_folder_zdf}${name_col}/.zattrs` ) )[ 'dict_col_metadata' ] // read column metadata
            }
        }
    }
    set_filter( ba_filter ) {   
        // if filter is removed
        if ( check_none( ba_filter ) ) {
            this.filter = undefined;
            this._n_rows_after_applying_filter = undefined;
            return;
        }
        
        function count_active_entries( zdf ) {
            // count the number of active entries in the active filter of a given zdf object
            let int_num_active_entries = 0,
                filter = zdf.filter;
            for ( let i = 0; i < zdf._n_rows_unfiltered; i ++ ) {
                int_num_active_entries += filter.get( i );
            }
            zdf._n_rows_after_applying_filter = int_num_active_entries;
        }
        // if BitSet object is given, set the filter and exit
        if ( ba_filter instanceof BitSet ) {
            this.filter = ba_filter;
            count_active_entries( this ); // count active number of entries in the given filter
            return;
        }
            
        // if 'NestedArray' is given, check shape and flatten the array
        if ( ba_filter instanceof zarr.NestedArray ) {
            // if a given 'ba_filter' is a NestedArray, check its shape (the length of the filter should be same as the number of rows of the current object)
            if ( ! ( ba_filter.shape.length == 1 & ba_filter.shape[ 0 ] == this._n_rows_unfiltered ) ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
            ba_filter = ba_filter.flatten( ); // flatten the nested array

        } else if ( ba_filter instanceof Int8Array ) {
            // if flattened 'Int8Array' is given, check shape
            // if the length of the given array is different from the number of rows of the object
            if ( ba_filter.length != this._n_rows_unfiltered ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
        }
        // initialize BitSet object
        let ba = new BitSet,
            i = 0,
            val = 0;
        // set BitSet object
        for ( i = 0; i < ba_filter.length ; i ++ ) {
            val = ba_filter[ i ];
            if ( val != 0 ) {
                ba.set( i, 1 )
            }
        }
        
        // set filter for the object
        this.filter = ba;
        count_active_entries( this ); // count active number of entries in the given filter
    }
    async get_item( name_col, coord_primary_axis = undefined, coord_other_axes = undefined ) {
        /*
        name_col : the name of the column
        coord_primary_axis = undefined : if undefined is given, all entries (if filter is not applied) or filtered entries (if filter is active) will be returned.
        coord_other_axes = undefined : slices or coordinates for a secondary axis and other axes other than the primary axis
        */
        // load metadata if it has not been loaded
        if ( check_none( this.metadata ) ) {
            await this.initialize( );
        }
        
        // retrieve flags
        let flag_coord_primary_axis_not_given = check_none( coord_primary_axis ),
            flag_coord_other_axes_not_given = check_none( coord_other_axes ),
            flag_filter_is_not_active = check_none( this.filter );
        
        // if the 'name_col' is not valid, exit
        if ( ! this.columns.has( name_col ) ) {
            if ( this.verbose ) {
                console.log( `the given column name ${name_col} does not exist in the current ZarrDataFrame, exiting` );
            }
            return;
        }
        await this.load_column( name_col ); // load zarr object of the 'name_col'
        
        let arr_data = [ ];
        if ( flag_coord_primary_axis_not_given ) {
            if ( flag_filter_is_not_active ) {
                if ( flag_coord_other_axes_not_given ) { // when no indexing occurs other than the primary axis
                    arr_data = await this._columns[ name_col ].zarr_object.get( null ); // retrieve all entries (filter is not active, no indexing were given)
                } else {
                    if ( Array.isArray( coord_other_axes ) ) { // when coordinates for multiple axes were given
                        let coords = [ null ];
                        coords.push( ... coord_other_axes );
                        arr_data = await this._columns[ name_col ].zarr_object.get( coords );
                    } else { // when only secondary axis was given
                        arr_data = await this._columns[ name_col ].zarr_object.get( [ null, coord_other_axes ] );
                    }
                }
            } else {
                // filter is active. apply the active filter to the current zarr object
                // exit when the number of active entries in the filter is 0.
                if ( this._n_rows_after_applying_filter == 0 ) {
                    if ( this.verbose ) {
                        console.log( "the number of active entries in the filter is zero, exiting" );
                    }
                    return;
                }
                
                // prepare
                let int_num_entries_in_a_chunk = this._columns[ name_col ].zarr_object.chunks[ 0 ];
                
                // compose an array of coordinates for axes other than the primary axis
                let coords_other_than_primary_axis = [ ];
                if ( ! flag_coord_other_axes_not_given ) {
                    if ( Array.isArray( coord_other_axes ) ) { // when coordinates of more than two axes were given
                        coords_other_than_primary_axis.push( ... coord_other_axes );
                    } else { // when only secondary axis was given
                        coords_other_than_primary_axis.push( coord_other_axes );
                    }
                }
                
                async function _filter_a_portion_of_zarr_object( int_index_start, int_index_end, zdf, coords_other_than_primary_axis, int_num_active_entries_in_a_batch ) {
                    // retrieve data for a portion of zarr object, filter using the given ba_filter, and return filtered records
                    let coords = [ zarr.slice( int_index_start, int_index_end ) ];
                    coords.push( ... coords_other_than_primary_axis ); // combine coordinates of all axes
                    
                    // fetch data
                    let arr = await zdf._columns[ name_col ].zarr_object.get( coords );
                    
                    // initialize the output, filtered array
                    let dtype = arr.dtype, // retrieve dtype of the array
                        l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
                        int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry // when 1D data is given, there will be one value for each entry
                        l_dims_filtered = [ int_num_active_entries_in_a_batch ];
                    l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis
                    
                    arr = arr.flatten( ); // flatten the array
                    let int_num_bytes_for_a_value = arr.byteLength / arr.length, // retrieve the number of bytes for each value
                        filter = zdf.filter;

                    let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * int_num_active_entries_in_a_batch ) ), // initialize the typedarray that will contain the output, filtered data
                        int_index_entry_after_filtering = 0; 
                    
                    for ( let i = int_index_start; i < int_index_end; i ++ ) {
                        if ( filter.get( i ) > 0 ) {
                            arr_filtered.set( arr.slice( int_num_values_for_an_entry * ( i - int_index_start ), int_num_values_for_an_entry * ( i - int_index_start + 1 ) ), int_num_values_for_an_entry * int_index_entry_after_filtering )
                            int_index_entry_after_filtering += 1; // update 'int_index_entry_after_filtering'
                        }
                    }
                    
                    // return the filtered array as a nested array
                    return new zarr.NestedArray( arr_filtered, l_dims_filtered );
                }
                
                let l_promise_filtered = [ ]; // initialize a list of promises that will contain filtered results
                for ( let i = 0; i < Math.ceil( this._n_rows_unfiltered / int_num_entries_in_a_chunk ); i ++ ) { // iterate each chunk
                    // count the number of active entries in a chunk
                    let int_index_start = i * int_num_entries_in_a_chunk,
                        int_index_end = Math.min( ( i + 1 ) * int_num_entries_in_a_chunk, this._n_rows_unfiltered ), 
                        int_num_active_entries_in_a_batch = 0,
                        filter = this.filter;
                    for ( let i = int_index_start; i < int_index_end; i ++ ) {
                        int_num_active_entries_in_a_batch += filter.get( i );
                    }
                    // if there is active entries in the current chunk, fetch and process the data
                    if ( int_num_active_entries_in_a_batch > 0 ) { 
                        l_promise_filtered.push( _filter_a_portion_of_zarr_object( int_index_start, int_index_end, this, coords_other_than_primary_axis, int_num_active_entries_in_a_batch ) );
                    }
                }
                
                // collect filtered results for each valid chunk
                let l_arr_filtered = await Promise.all( l_promise_filtered ),
                    arr = l_arr_filtered[ 0 ]; // retrieve the first filtered result to gather information about the returned results
                
                // initialize the output that will contain the combined filtered array
                let dtype = arr.dtype, // retrieve dtype of the array
                    l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
                    int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry
                    l_dims_filtered = [ this._n_rows_after_applying_filter ];
                l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis

                arr = arr.flatten( ); // flatten the first filtered array
                let int_num_bytes_for_a_value = arr.byteLength / arr.length, // retrieve the number of bytes for each value
                    filter = this.filter;

                let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * this._n_rows_after_applying_filter ) ), // initialize the typedarray that will contain the output, filtered data
                    int_num_values_copied = 0; 

                // iterate through each filtered result and combine data
                for ( let i = 0; i < l_arr_filtered.length; i ++ ) {
                    let arr = l_arr_filtered[ i ].flatten( ); // retrieve a filtered result and flatten the nested array
                    arr_filtered.set( arr, int_num_values_copied ) // copy the filtered result of a chunk to the combined result
                    int_num_values_copied += arr.length; // update 'int_num_values_copied'
                }
                // retrieve the filtered array as a nested array
                arr_data = new zarr.NestedArray( arr_filtered, l_dims_filtered );
            }
        } else {
            // when indexing through primary axis is active
            if ( flag_coord_other_axes_not_given ) { // when no indexing occurs other than the primary axis
                arr_data = await this._columns[ name_col ].zarr_object.get( coord_primary_axis ); // retrieve all entries
            } else {
                if ( Array.isArray( coord_other_axes ) ) { // when coordinates of more than two axes were given
                    let coords = [ coord_primary_axis ];
                    coords.push( ... coord_other_axes );
                    arr_data = await this._columns[ name_col ].zarr_object.get( coords );
                } else { // when only secondary axis was given
                    arr_data = await this._columns[ name_col ].zarr_object.get( [ coord_primary_axis, coord_other_axes ] );
                }
            }
        }
        // retrieve column metadata
        let col_metadata = this._columns[ name_col ].metadata;
        if ( col_metadata[ 'flag_categorical' ] ) { // retrieve categorical data
            if ( arr_data.shape.length > 1 ) { // currently, only a categorical data with 1D shape is supported.
                return arr_data;
            }
            let l_unique_categories = col_metadata[ 'l_value_unique' ], // retrieve a list of unique categories of the given column
                arr_data_category = [ ];
            
            // retrieve categorical data
            for ( let int_index_category of arr_data.flatten( ) ) {
                arr_data_category.push( l_unique_categories[ int_index_category ] );
            }
            arr_data = arr_data_category;
        }
        // return retrieved data
        return arr_data;
    }
    async get_df( l_col ) {
        /*
        return a DataFrame for the given list of columns
        */
        let dict_data = { };
        for ( let col of l_col ) { // for each column in the given list of columns
            if ( this.columns.has( col ) ) { // if the column exists in the dataframe
                dict_data[ col ] = await this.get_item( col ); // retrieve values of the column
            }
        }
        return new DataFrame( dict_data, undefined, this.n_rows, this.verbose ); // return the retrieved data as a dataframe // use default index
    }
    get_n_rows( ) {
        /* # 2022-06-22 16:36:54 
        retrieve the number of rows after applying filter. if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
        */
        if ( check_none( this.filter ) ) { // if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
            return this._n_rows_unfiltered;
        } else { // if a filter is active
            return this._n_rows_after_applying_filter; // return the number of active rows in the filter
        }
    }
    get n_rows( ) {
        /* # 2022-06-22 16:36:54 
        retrieve the number of rows after applying filter. if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
        */
        if ( check_none( this.filter ) ) { // if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
            return this._n_rows_unfiltered;
        } else { // if a filter is active
            return this._n_rows_after_applying_filter; // return the number of active rows in the filter
        }
    }
}
async function zarr_get_by_l_int_index( za, l_int_index, coord_other_axes = undefined ) {
    /* 
    'l_int_index' WILL BE SORTED
    */
    // prepare (retrieve the number of entries in the primary axis of a chunk
    let int_num_entries_in_a_chunk = za.chunks[ 0 ],
        flag_coord_other_axes_not_given = check_none( coord_other_axes );

    // compose an array of coordinates for axes other than the primary axis
    let coords_other_than_primary_axis = [ ];
    if ( ! flag_coord_other_axes_not_given ) {
        if ( Array.isArray( coord_other_axes ) ) { // when coordinates of more than two axes were given
            coords_other_than_primary_axis.push( ... coord_other_axes );
        } else { // when only secondary axis was given
            coords_other_than_primary_axis.push( coord_other_axes );
        }
    }
    // sort 'l_int_index
    l_int_index = l_int_index.sort( sort_number );

    async function _filter_a_portion_of_zarr_object( int_index_start, int_index_end, za, l_int_index, coords_other_than_primary_axis ) {
        // retrieve data for a portion of zarr object, filter using the given ba_filter, and return filtered records
        let coords = [ zarr.slice( int_index_start, int_index_end ) ];
        coords.push( ... coords_other_than_primary_axis ); // combine coordinates of all axes
        
        // fetch data
        let arr = await za.get( coords );
        
        // initialize the output, filtered array
        let dtype = arr.dtype, // retrieve dtype of the array
            l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
            int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry
            int_num_active_entries_in_a_batch = l_int_index.length,
            l_dims_filtered = [ int_num_active_entries_in_a_batch ];
        l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis

        arr = arr.flatten( ); // flatten the array
        let int_num_bytes_for_a_value = arr.byteLength / arr.length; // retrieve the number of bytes for each value

        let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * int_num_active_entries_in_a_batch ) ), // initialize the typedarray that will contain the output, filtered data
            int_index_entry_after_filtering = 0; 

        for ( let int_index of l_int_index ) {
            arr_filtered.set( arr.slice( int_num_values_for_an_entry * ( int_index - int_index_start ), int_num_values_for_an_entry * ( int_index - int_index_start + 1 ) ), int_num_values_for_an_entry * int_index_entry_after_filtering )
            int_index_entry_after_filtering += 1; // update 'int_index_entry_after_filtering'
        }
        // return the filtered array as a nested array
        return new zarr.NestedArray( arr_filtered, l_dims_filtered );
    }

    let l_promise_filtered = [ ], // initialize a list of promises that will contain filtered results
        l_int_index_of_a_chunk = [ ],
        int_index_chunk_current = undefined;
    for ( let int_index of l_int_index ) {
        // retrieve 'int_index_chunk' of the current int_index
        let int_index_chunk = parseInt( int_index / int_num_entries_in_a_chunk );
        // when chunk boundary has been crossed, flush batch and update the chunk boundary
        if ( int_index_chunk != int_index_chunk_current ) {
            // flush batch
            if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
                l_promise_filtered.push( _filter_a_portion_of_zarr_object( int_index_chunk_current * int_num_entries_in_a_chunk, ( int_index_chunk_current + 1 ) * int_num_entries_in_a_chunk, za, l_int_index_of_a_chunk, coords_other_than_primary_axis ) );
                l_int_index_of_a_chunk = [ ]; // initialize the next batch
            } 
            // update 'int_index_chunk_current'
            int_index_chunk_current = int_index_chunk; 
        }
        // collect 'int_index'
        l_int_index_of_a_chunk.push( int_index ); // initialize the next batch
    }
    // flush batch
    if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
        l_promise_filtered.push( _filter_a_portion_of_zarr_object( int_index_chunk_current * int_num_entries_in_a_chunk, ( int_index_chunk_current + 1 ) * int_num_entries_in_a_chunk, za, l_int_index_of_a_chunk, coords_other_than_primary_axis ) );
        l_int_index_of_a_chunk = [ ]; // initialize the next batch
    } 
    
    // collect filtered results for each valid chunk
    let l_arr_filtered = await Promise.all( l_promise_filtered ),
        arr = l_arr_filtered[ 0 ]; // retrieve the first filtered result to gather information about the returned results

    // initialize the output that will contain the combined filtered array
    let dtype = arr.dtype, // retrieve dtype of the array
        l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
        int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry
        l_dims_filtered = [ l_int_index.length ];
    l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis

    arr = arr.flatten( ); // flatten the first filtered array
    let int_num_bytes_for_a_value = arr.byteLength / arr.length; // retrieve the number of bytes for each value

    let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * l_int_index.length ) ), // initialize the typedarray that will contain the output, filtered data
        int_num_values_copied = 0; 

    // iterate through each filtered result and combine data
    for ( let i = 0; i < l_arr_filtered.length; i ++ ) {
        let arr = l_arr_filtered[ i ].flatten( ); // retrieve a filtered result and flatten the nested array
        arr_filtered.set( arr, int_num_values_copied ) // copy the filtered result of a chunk to the combined result
        int_num_values_copied += arr.length; // update 'int_num_values_copied'
    }
    // return the filtered array as a nested array
    return new zarr.NestedArray( arr_filtered, l_dims_filtered );
}
class StringZarr {
    /*
    a stringzarr object contains 2D-array of strings of variable length with chunk shape of ('int_num_of_entries_in_a_chunk', 1), meaning each chunk contains values of a single column
    */
    constructor( path_folder, verbose = true ) {
        // set attributes
        this.path_folder = path_folder;
        this.verbose = verbose;
        // initialize attributes
    }
    async initialize( ) {
        // load metadata of the object
        // should be run before using the object
        let zattrs = await $.getJSON( `${this.path_folder}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        
        // set attributes
        this.int_num_entries = this.metadata[ 'int_num_entries' ]
        this.int_num_of_entries_in_a_chunk = this.metadata[ 'int_num_of_entries_in_a_chunk' ]
        
        this.length = this.int_num_entries;
    }
    async get_by_l_int_index( l_int_index, int_index_column = 0 ) {
        /*
        'l_int_index' list of integer indices for retrieving data. the indices WILL BE SORTED!, and the list of returned values will contains the list of sorted indices.
        'int_index_column' : the index of the column for retrieving data
        */
        // prepare (retrieve the number of entries in the primary axis of a chunk
        let int_num_entries_in_a_chunk = this.int_num_of_entries_in_a_chunk;

        // sort 'l_int_index
        l_int_index = l_int_index.sort( sort_number );

        async function _filter_a_portion_of_stringzarr_object( int_index_chunk_row, stringzarr, l_int_index, int_index_chunk_column ) {
            // fetch data
            let arr = await stringzarr.load_a_chunk( int_index_chunk_row, int_index_chunk_column ),
                int_num_active_entries_in_a_batch = l_int_index.length,
                arr_filtered = [ ], // initialize an array that will contain the filtered data
                int_index_start = int_index_chunk_row * stringzarr.int_num_of_entries_in_a_chunk;
            
            // filter data
            for ( let int_index of l_int_index ) {
                arr_filtered.push( arr[ int_index - int_index_start ] );
            }
            // return the filtered array as a nested array
            return arr_filtered;
        }

        let l_promise_filtered = [ ], // initialize a list of promises that will contain filtered results
            l_int_index_of_a_chunk = [ ],
            int_index_chunk_current = undefined;
        for ( let int_index of l_int_index ) {
            // retrieve 'int_index_chunk' of the current int_index
            let int_index_chunk = parseInt( int_index / int_num_entries_in_a_chunk );
            // when chunk boundary has been crossed, flush batch and update the chunk boundary
            if ( int_index_chunk != int_index_chunk_current ) {
                // flush batch
                if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
                    l_promise_filtered.push( _filter_a_portion_of_stringzarr_object( int_index_chunk_current, this, l_int_index_of_a_chunk, int_index_column ) );
                    l_int_index_of_a_chunk = [ ]; // initialize the next batch
                } 
                // update 'int_index_chunk_current'
                int_index_chunk_current = int_index_chunk; 
            }
            // collect 'int_index'
            l_int_index_of_a_chunk.push( int_index ); // initialize the next batch
        }
        // flush batch
        if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
            l_promise_filtered.push( _filter_a_portion_of_stringzarr_object( int_index_chunk_current, this, l_int_index_of_a_chunk, int_index_column ) );
            l_int_index_of_a_chunk = [ ]; // initialize the next batch
        } 

        // collect filtered results for each valid chunk
        let l_arr_filtered = await Promise.all( l_promise_filtered ),
            arr_filtered = [ ]; // initialize the typedarray that will the output values

        // iterate through each filtered result and combine data
        for ( let i = 0; i < l_arr_filtered.length; i ++ ) {
            arr_filtered.push( ... l_arr_filtered[ i ] ); // retrieve a filtered result
        }
        // return the filtered array
        return arr_filtered;
    }
    parse_chunk( file ) { 
        /*
        retrieve data of a chunk
        */
        return new Promise ( function( resolve, reject ) {
            fetch( file )
                .then( ( response ) => {
                  return response.text( );
               }).then( ( text_base64 ) => {
                  return ParseBase64GzippedText( text_base64 );
               }).then( ( text ) => {
                let arr = text.split( '\n' );
                arr = arr.slice( 0, arr.length - 1 );
                resolve( arr );
                  // Papa.parse( text, { download: false, header: false, skipEmptyLines: false, delimiter: '\t', worker: true, dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ); }, error: reject } ); // remove last empty line
               }).catch( err => { reject } );
        });
    }
    async load_a_chunk( index_chunk_row, index_chunk_col = 0 ) {
        /*
        load data of a chunk of 'index_chunk_row' and 'index_chunk_col'
        */
        return await this.parse_chunk( `${this.path_folder}${index_chunk_row}.${index_chunk_col}` );
    }
    async load_all_data( ) {
        let l_file = [ `${this.path_folder}8.0`, `${this.path_folder}7.0`, `${this.path_folder}6.0` ];
        let l_promise = l_file.map( function( file ) { 
            return new Promise ( function( resolve, reject ) {
                fetch( file )
                    .then( ( response ) => {
                      return response.text( );
                   }).then( ( text_base64 ) => {
                      return ParseBase64GzippedText( text_base64 );
                   }).then( ( text ) => {
                    let arr = text.split( '\n' );
                    arr = arr.slice( 0, arr.length - 1 );
                    resolve( arr );
                      // Papa.parse( text, { download: false, header: false, skipEmptyLines: false, delimiter: '\t', worker: true, dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ); }, error: reject } ); // remove last empty line
                   }).catch( err => { reject } );
            });
        }); // 'skipEmptyLines' is set to false to allow reading empty lines in some input files // due to 'skipEmptyLines: false' option, the last line is empty, and should be discarded
        let results = await Promise.all( l_promise ); // wait until all files have been parsed by Papa.parse
        let l_parsed_data = [ ]; 
        l_parsed_data.push( ... results );
        return l_parsed_data;
    }
}
class RAMtx {
    constructor( path_folder_ramtx, ramdata = undefined, verbose = true, flag_debugging = false ) {
        // these values will be fixed: dtype_of_feature_and_barcode_indices = np.uint32, dtype_of_values = np.float64
        // set attributes
        this.path_folder_ramtx = path_folder_ramtx;
        this._ramdata = ramdata;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        
        // set filters using the given RamData
        this.ba_filter_features = check_none( this._ramdata ) ? undefined : this._ramdata.ft.filter;
        this.ba_filter_barcodes = check_none( this._ramdata ) ? undefined : this._ramdata.bc.filter;
    }
    async initialize( ) {
        // initialize RAMtx
        // load metadata of RAMtx and zarr objects containing sparse data
        // should be run before using RAMtx
        let zattrs = await $.getJSON( `${this.path_folder_ramtx}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        
        // set attributes
        this.flag_ramtx_sorted_by_id_feature = this.metadata[ 'flag_ramtx_sorted_by_id_feature' ];
        this._int_num_barcodes = this.metadata[ 'int_num_barcodes' ];
        this._int_num_features = this.metadata[ 'int_num_features' ];
        this._int_num_records = this.metadata[ 'int_num_records' ];
        this.mode = this.metadata[ 'mode' ];

        this.is_for_querying_features = this.flag_ramtx_sorted_by_id_feature;
        
        // # open zarr objects
        this.is_sparse = this.mode != 'dense' 
        if ( this.is_sparse ) {
            this._za_mtx_index = await zarr.openArray({
                store : this.path_folder_ramtx,
                path : `matrix.index.zarr/`,
                mode: "r"
            });
            this._za_mtx = await zarr.openArray({
                store : this.path_folder_ramtx,
                path : `matrix.zarr/`,
                mode: "r"
            });
        }
    }
    async load_ba_active_entries( ) {
        // load 'ba_active_entries'
        let name_axis_for_querying = this.flag_ramtx_sorted_by_id_feature ? 'features' : 'barcodes',
            za_ba_active_entries = await zarr.openArray({
            store : this.path_folder_ramtx,
            path : `matrix.${name_axis_for_querying}.active_entries.zarr/`,
            mode: "r"
        });
        // if binary data encoded in '|i1' format ('b1') format was detected, change dtype to '|i1', since '|b1' is currently not supported in the Zarr.js implementation
        if ( za_ba_active_entries.meta.dtype == '|b1' ) {
            za_ba_active_entries.meta.dtype = '|i1'; // change dtype to '|i1'
        }
        this.ba_active_entries = to_ba( await za_ba_active_entries.get( null ) ); // retrieve a filter of active entries
    }
    get int_num_barcodes( ) {
        return this._int_num_barcodes;
    }
    get int_num_features( ) {
        return this._int_num_features;
    }
    get int_num_records( ) {
        return this._int_num_records;
    }
    async get_item( l_int_entry ) {
        /*
        get sparse data for the given list of 'l_int_entry'
        */
        // get expression of a list of int_entry
        // initialize the object if metadata has not been loaded
        if ( check_none( this.metadata ) ) {
            await this.initialize( );
        }
        
        // initialize the output data structures
        let l_int_entry_of_axis_for_querying = [ ], 
            l_arr_int_entry_of_axis_not_for_querying = [ ], 
            l_arr_value = [ ];
        
        // wrap in a list if a single entry was queried
        if ( ! Array.isArray( l_int_entry ) ) { // check whether the given entry is not an array
            l_int_entry = [ l_int_entry ];
        }
        
        // retrieve flag indicating an empty input
        let flag_empty_input = l_int_entry.length == 0;
        
        // retrieve zarr objects
        let za_mtx = this._za_mtx,
            za_mtx_index = this._za_mtx_index;
        
        // internal settings
        let int_num_chunks_for_a_batch = 2 // number of chunks in a batch for retrieving data for the sparse matrix
        
        // retrieve filters 
        let is_for_querying_features = this.is_for_querying_features,
            ba_filter_axis_for_querying = ( is_for_querying_features ) ? this.ba_filter_features : this.ba_filter_barcodes, 
            ba_filter_not_axis_for_querying = ( is_for_querying_features ) ? this.ba_filter_barcodes : this.ba_filter_features,
            int_num_entries_axis_for_querying = ( is_for_querying_features ) ? this._ramdata.ft.int_num_entries : this._ramdata.bc.int_num_entries; // retrieve the number of entries for the axis for querying
        
        // create view 
        // retrieve dictionaries for changing coordinates
        // initialize the dictionaries
        let dict_change_int_entry_of_axis_for_querying = undefined,
            dict_change_int_entry_of_axis_not_for_querying = undefined;
        if ( ! check_none( this._ramdata ) ) { // if RAMtx has been attached to RamData, retrieve dictionaries that can be used to change coordinate
            let ram = this._ramdata; // retrieve ramdata from which view will be retrieved. if current RAMtx is component, use composite RamData. else, use RamData to which current RAMtx has been attached to.
            if ( this.is_for_querying_features ) {
                dict_change_int_entry_of_axis_for_querying = ram.ft.dict_change
                dict_change_int_entry_of_axis_not_for_querying = ram.bc.dict_change
            } else {
                dict_change_int_entry_of_axis_for_querying = ram.bc.dict_change
                dict_change_int_entry_of_axis_not_for_querying = ram.ft.dict_change
            }
        }
        
        // compose a vectorized function for the conversion of int_entries of the non-indexed axis.
        let vchange_int_entry_of_axis_not_for_querying = undefined;
        if ( ! check_none( dict_change_int_entry_of_axis_not_for_querying ) ) {
            vchange_int_entry_of_axis_not_for_querying = ( arr ) => {
                /*
                arr : typed array
                */
                let arr_changed = new arr.constructor( new ArrayBuffer( arr.buffer.byteLength ) ); // initialize an empty typed array with the same type length 
                for ( let i = 0; i < arr.length; i ++ ) {
                    arr_changed[ i ] = dict_change_int_entry_of_axis_not_for_querying[ arr[ i ] ];
                }
                return arr_changed;
            }
        }
        
        // retrieve filtered 'l_int_entry'
        if ( ! check_none( ba_filter_axis_for_querying ) ) { // if 'ba_filter_axis_for_querying' is validz
            let l_int_entry_filtered = [ ];
            if ( flag_empty_input ) {
                // ''' handle when empty 'l_int_entry' has been given and filter has been set  '''
                l_int_entry_filtered = ba_to_integer_indices( ba_filter_axis_for_querying, int_num_entries_axis_for_querying );
            } else {
                // filter 'l_int_entry' according to 'ba_filter_axis_for_querying'
                for ( let int_entry of l_int_entry ) {
                    if ( ba_filter_axis_for_querying.get( int_entry ) > 0 ) {
                        l_int_entry_filtered.push( int_entry );
                    }
                }
            }
            l_int_entry = l_int_entry_filtered; // use filtered 'l_int_entry' as 'l_int_entry'
        }
                
        // if no valid entries are available, return an empty result
        if ( l_int_entry.length == 0 ) {
            return [ l_int_entry_of_axis_for_querying, l_arr_int_entry_of_axis_not_for_querying, l_arr_value ];
        }
            
        // sort 'int_entry' so that closely located entries can be retrieved together
        // sort indices of entries so that the data access can occur in the same direction
        let int_num_entries = l_int_entry.length;
        l_int_entry = l_int_entry.sort( sort_number );
        
        // single thread mode
        /* # 2022-08-16 01:54:31 
        retrieve data as a worker in a worker process or in the main processs (in single-process mode)
        */
        // initialize 

        function _process_entry( int_entry, arr_int_entry_of_axis_not_for_querying, arr_value ) {
            /* # 2022-07-30 22:07:46 
            process retrieve data. apply filter and change coordinates
            */
            // if a filter for not-indexed axis has been set, apply the filter to the retrieved records
            if ( ! check_none( ba_filter_not_axis_for_querying ) ) {                
                // create empty arrays
                let arr_int_entry_of_axis_not_for_querying_filtered = [ ],
                    arr_value_filtered = [ ];

                // iterate through each record
                for ( let i = 0; i < arr_value.length; i ++ ) {
                    // check whether the current int_entry is included in the filter
                    if ( ba_filter_not_axis_for_querying.get( arr_int_entry_of_axis_not_for_querying[ i ] ) > 0 ) { 
                        // include the record
                        arr_int_entry_of_axis_not_for_querying_filtered.push( arr_int_entry_of_axis_not_for_querying[ i ] );
                        arr_value_filtered.push( arr_value[ i ] );
                    }
                }
                
                // if no valid data exists (all data were filtered out), continue to the next 'int_entry'
                if ( arr_value_filtered.length == 0 ) {
                    return;
                }

                // convert arrays to typed arrays
                arr_int_entry_of_axis_not_for_querying = new arr_int_entry_of_axis_not_for_querying.constructor( arr_int_entry_of_axis_not_for_querying_filtered );
                arr_value = new arr_value.constructor( arr_value_filtered );
            }

            // apply view
            if ( ! check_none( dict_change_int_entry_of_axis_for_querying ) ) {
                int_entry = dict_change_int_entry_of_axis_for_querying[ int_entry ]
            }
            // convert int_entry for the non-indexed axis if a mapping has been given (create view)
            if ( ! check_none( vchange_int_entry_of_axis_not_for_querying ) ) {
                arr_int_entry_of_axis_not_for_querying = vchange_int_entry_of_axis_not_for_querying( arr_int_entry_of_axis_not_for_querying )
            }
            
            // append the retrieved data to the output results 
            l_int_entry_of_axis_for_querying.push( int_entry ); 
            l_arr_int_entry_of_axis_not_for_querying.push( arr_int_entry_of_axis_not_for_querying );
            l_arr_value.push( arr_value );
        }
        async function __fetch_from_sparse_ramtx( l_int_entry_in_a_batch, l_index_in_a_batch ) {
            /* # 2022-07-30 22:32:14 
            fetch data from sparse ramtx for a batch
            */
            ba_filter_not_axis_for_querying instanceof BitSet; // use 'ba_filter_not_axis_for_querying' in the subsequent scopes
            
            let st_batch = l_index_in_a_batch[ 0 ][ 0 ], // retrieve start and end positions of the current batch
                en_batch = l_index_in_a_batch[ l_index_in_a_batch.length - 1 ][ 1 ],
                arr = await za_mtx.get( zarr.slice( st_batch, en_batch ) ), // fetch data from the Zarr object
                arr_int_entry_of_axis_not_for_querying = arr.get( [ null, 0 ] ), // retrieve nested array of each component
                arr_value = arr.get( [ null, 1 ] );

            for ( let i = 0; i < l_index_in_a_batch.length; i ++ ) { // iterate over each entry
                let int_entry = l_int_entry_in_a_batch[ i ],
                    index = l_index_in_a_batch[ i ],
                    st = index[ 0 ] - st_batch, // substract the start position of the batch to retrieve the local index
                    en = index[ 1 ] - st_batch,
                    sl = zarr.slice( st, en ); // retrieve a slice object for the current entry
                _process_entry( int_entry, arr_int_entry_of_axis_not_for_querying.get( sl ).flatten( ), arr_value.get( sl ).flatten( ) );
            }
        }
        // retrieve data
        // handle sparse ramtx
        // %% Sparse ramtx %% 
        // prepare
        let int_num_records_in_a_chunk = za_mtx.meta.chunks[ 0 ] // retrieve the number of records in a chunk
        let index_chunk_start_current_batch = undefined, // initialize the index of the chunk at the start of the batch
            l_int_entry_in_a_batch = [ ],
            l_index_in_a_batch = [ ], // several entries will be processed together as a batch if they reside in the same or nearby chunk ('int_num_chunks_for_a_batch' setting)
            arr_index = await zarr_get_by_l_int_index( za_mtx_index, l_int_entry ); // retrieve arr_index of the given list of 'int_entry'
        
        // iterate through each 'int_entry'
        for ( let i = 0; i < l_int_entry.length; i ++ ) { // iterate through each entry
            // retrieve mtx_index data and remove invalid entries
            let int_entry = l_int_entry[ i ];
            let index = arr_index.get( i ).flatten( ), // retrieve mtx_index data 
                st = index[ 0 ],
                en = index[ 1 ];
            if ( st == en ) { // if there is no count data for the 'int_entry', continue on to the next 'int_entry' # drop 'int_entry' lacking count data (when start and end index is the same, the 'int_entry' does not contain any data)
                continue
            }

            // if batch is full, flush the batch 
            let index_chunk_end = en - 1; // int_num_records_in_a_chunk # retrieve the index of the last chunk
            if ( ( index_chunk_start_current_batch !== undefined ) & ( index_chunk_end >= index_chunk_start_current_batch + int_num_chunks_for_a_batch ) ) { // if start has been set 
                await __fetch_from_sparse_ramtx( l_int_entry_in_a_batch, l_index_in_a_batch );
                // initialize the next batch
                l_int_entry_in_a_batch = [ ]; 
                l_index_in_a_batch = [ ];
                index_chunk_start_current_batch = undefined; // reset start
            }
            // start the batch 
            // if start has not been set, set the start of the current batch
            if ( index_chunk_start_current_batch === undefined ) { // start the batch
                index_chunk_start_current_batch = st // int_num_records_in_a_chunk 
            }

            // add int_entry to the batch 
            l_int_entry_in_a_batch.push( int_entry ) 
            l_index_in_a_batch.push( [ st, en ] )
        }
        if ( l_int_entry_in_a_batch.length > 0 ) { // if some entries remains unprocessed, flush the buffer
            await __fetch_from_sparse_ramtx( l_int_entry_in_a_batch, l_index_in_a_batch );
        }

        // return the retrieved data
        return [ l_int_entry_of_axis_for_querying, l_arr_int_entry_of_axis_not_for_querying, l_arr_value ];
    }
    async get_sparse_matrix( l_int_entry ) {
        /* # 2022-08-30 11:03:14 
        
        get sparse matrix for the given list of integer representations of the entries.
        
        'l_int_entry' : list of int_entries for query
        'flag_return_as_arrays' : if True, return three arrays and a single list, 'l_int_barcodes', 'l_int_features', 'l_values', 'l_int_num_records'. 
                'l_int_barcodes', 'l_int_features', 'l_values' : for building a sparse matrix
                'l_int_num_records' : for building an index
                if False, return a scipy.csr sparse matrix
        */
        // return data as a sparse matrix
        return new SparseMatrix( await this.get_item( l_int_entry ), check_none( this._ramdata ) ? [ this._int_num_barcodes, this._int_num_features ] : [ this._ramdata.bc.length, this._ramdata.ft.length ], ! this.flag_ramtx_sorted_by_id_feature, this.verbose ); // convert count data to a sparse matrix // feature = secondary axis, barcode = primary axis
    }
}
class RamDataAxis {
    constructor( path_folder, name_axis, ba_filter = undefined, ramdata = undefined, dict_kw_zdf = { 'flag_retrieve_categorical_data_as_integers' : false }, dict_kw_view = { 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' : 0.1 }, int_index_str_rep = 0, verbose = true, flag_debugging = false ) {
        // set attributes
        this.path_folder = path_folder;
        this._path_folder = path_folder;
        this._name_axis = name_axis;
        this.filter = ba_filter;
        this._ramdata = ramdata;
        this.dict_kw_zdf = dict_kw_zdf;
        this.dict_kw_view = dict_kw_view;
        this.int_index_str_rep = int_index_str_rep;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        // initialize viewer (coordinate converter, a dictionary for converting coordinates) 
        this.dict_change = undefined ;
        this._dict_change_backup = undefined;
    }
    async initialize( ) {
        // initialize RamDataAxis
        // initialize the mapping dictionaries
        this._dict_str_to_i = undefined; 
        this._dict_i_to_str = undefined; 
        
        // open a ZarrDataFrame with a given filter
        this.meta = new ZarrDataFrame( 
            `${this.path_folder}${this._name_axis}.num_and_cat.zdf/`, 
            this.filter, 
            this.dict_kw_zdf[ 'flag_retrieve_categorical_data_as_integers' ],
            this.verbose
        );
        await this.meta.initialize( ); // initialize the ZarrDataFrame object
        // retrieve number of entries
        this.int_num_entries = this.meta._n_rows_unfiltered;
        
        // load string representations of the entries of the axis
        this._sza = new StringZarr( `${this._path_folder}${this._name_axis}.str.chunks/`, this.verbose );
        await this._sza.initialize( ); // initialize the stringzarr object
    }
    set_filter( ba_filter ) {
        /* 
        set filter for the axis
        */       
        function change_filter( ax ) {
            // set filter of the ZarrDataFrame
            ax.meta.set_filter( ax.filter );
            
            // set filter of the layer if a layer has been loaded
            if ( ! check_none( ax._ramdata ) ) {
                if ( ! check_none( ax._ramdata.layer ) ) {
                    ax._ramdata.layer.set_filter( ax.filter, ax._name_axis == 'features' ); // set filter of the axis
                }
            }
        }
        
        // if filter is removed
        if ( check_none( ba_filter ) ) {
            this.filter = undefined;
            change_filter( this ); // change filters 
            return;
        }
        
        // if BitSet object is given, set the filter and exit
        if ( ba_filter instanceof BitSet ) {
            this.filter = ba_filter;
            change_filter( this ); // change filters 
            return;
        }
            
        // if 'NestedArray' is given, check shape and flatten the array
        if ( ba_filter instanceof zarr.NestedArray ) {
            // if a given 'ba_filter' is a NestedArray, check its shape (the length of the filter should be same as the number of rows of the current object)
            if ( ! ( ba_filter.shape.length == 1 & ba_filter.shape[ 0 ] == this.int_num_entries ) ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
            ba_filter = ba_filter.flatten( ); // flatten the nested array

        } else if ( ba_filter instanceof Int8Array ) {
            // if flattened 'Int8Array' is given, check shape
            // if the length of the given array is different from the number of rows of the object
            if ( ba_filter.length != this.int_num_entries ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
        } else {
            if ( this.verbose ) {
                console.log( "the data type of the given 'ba_filter' object is not supported, exiting" );
            }
            return;
        }
        // initialize BitSet object
        let ba = new BitSet,
            i = 0,
            val = 0;
        // set BitSet object
        for ( i = 0; i < ba_filter.length ; i ++ ) {
            val = ba_filter[ i ];
            if ( val != 0 ) {
                ba.set( i, 1 )
            }
        }
        
        // set filter for the object
        this.filter = ba;
        change_filter( this ); // change filters 
    }
    create_view( ) {
        /*
        create the view of the axis
        
        build 'dict_change' (dictionaries for conversion of coordinates) from the given filter, creating a view of the current 'Axis'
        automatically set filter using the mask containing all active entries with valid data if filter is not active
        
        for example, when filter is 
         0123456789  - index
        '1000101110' - filter 
        
        then, dict_change will be { 0 : 0, 4 : 1, 6 : 2, 7 : 3, 8 : 4 }
        when the number of active entries in an exis > 10% (or above any proportion that can set by 'float_min_proportion_of_active_entries_in_an_axis_for_using_array'), an array with the same length will be used for the conversion of coordinates
        
        'float_min_proportion_of_active_entries_in_an_axis_for_using_array' : a threshold for the transition from dictionary to array for the conversion of coordinates. empirically, dictionary of the same length takes about ~10 times more memory than the array
        'dtype' : dtype of array that will be used as 'dictionary'
        index_component : Union[ None, int ] = None : the index of a component RamData to retrieve view.
        
        */
        // retrieve settings to create a view
        let float_min_proportion_of_active_entries_in_an_axis_for_using_array = ( 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' in this.dict_kw_view ) ? this.dict_kw_view[ 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' ] : 0.1;

        // initialize 'dict_change'
        let dict_change = undefined,
            ba = this.filter;
        if ( ( ! check_none( ba ) ) & ( this.meta._n_rows_after_applying_filter < this.int_num_entries ) ) { // only build 'dict_change' if a filter is active or at least one entry is not active
            // count the number of active entries in the given filter
            let n = this.meta._n_rows_unfiltered,
                n_active_entries = count_ba( ba, n );
            
            // initialize dictionary
            // implement a dictionary using an array if the proportion of active entries in the axis is larger than the given threshold to reduce the memory footprint and increase the efficiency of conversion process
            dict_change = ( ( n_active_entries / n ) > float_min_proportion_of_active_entries_in_an_axis_for_using_array ) ? new Int32Array( new ArrayBuffer( 4 * n ) ) : { }; // 4 bytes (Int32 arrays) for building 'dict_change'
            
            let i = 0; // initialize active entry counter
            for ( let int_index of ba_to_integer_indices( ba, n ) ) { // iterate through 'int_entry' of the active entries
                dict_change[ int_index ] = i; // retrieve active_entry > i mapping
                i ++; // increase index
            }
        }
        this.dict_change = dict_change; // load 'dict_change'
    }
    destroy_view( ) {
        /* # 2022-07-16 15:23:01 
        unload 'this.dict_change' (dictionaries for conversion of coordinates), destroying the current view
        */
        this.dict_change = undefined;
    }
    backup_view( ) {
        /* # 2022-08-20 17:25:12 
        backup view
        */
        this._dict_change_backup = this.dict_change; // back up view
        this.destroy_view( ); // destroy view
    }
    restore_view( ) {
        /* # 2022-08-20 17:25:12 
        restore view
        */
        this.dict_change = this._dict_change_backup;
        this._dict_change_backup = undefined;
    }
    none( ) {
        /* # 2022-09-08 11:30:33 
        return an empty bitarray filter
        */
        ba = new BitSet( );
        return ba
    }
    exclude( filter_to_exclude ) {
        /* # 2022-09-14 00:12:48 
        exclude entries in the given filter 'filter_to_exclude' from the current filter
        */
        // exclude the entries in 'filter_to_exclude'
        this.set_filter( this.filter.andNot( filter_to_exclude ) );
    }
    all( flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-09-02 00:33:56 
        return bitarray filter with all entries marked 'active'
        
        'flag_return_valid_entries_in_the_currently_active_layer' : return bitarray filter containing only the active entries in the current layer 
        */
        let ba;
        if ( flag_return_valid_entries_in_the_currently_active_layer & ( ! check_none( this._ramdata ) ) & ( ! check_none( this._ramdata.layer ) ) ) { // if RamData has an active layer and 'flag_return_valid_entries_in_the_currently_active_layer' setting is True, return bitarray where entries with valid count data is marked as '1' # if valid ramtx data is available
            let rtx = this._ramdata.layer.get_ramtx( this._name_axis == 'features' ); // retrieve associated ramtx object
            if ( ! check_none( rtx ) ) {
                ba = rtx.ba_active_entries;
                return ba;
            }
        }
        // if layer is empty or 'flag_return_valid_entries_in_the_currently_active_layer' is False, just return a bitarray filled with '1'
        ba = new BitSet( );
        ba.setRange( 0, this.int_num_entries, 1 ); // set all entries as 'active' 
        return ba; // return the bitarray filter
    }
    get_ba_active_entries( flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-07-16 17:38:04 
        
        return a bitarray object containing currently active entries in the Axis. 
        if a filter is active, return the current filter
        if a filter is not active, return the return value of Axis.all( flag_return_valid_entries_in_the_currently_active_layer )
        
        'flag_return_valid_entries_in_the_currently_active_layer' : return bitarray filter containing only the active entries in the current layer 
        */
        return check_none( this.filter ) ? this.all( flag_return_valid_entries_in_the_currently_active_layer ) : this.filter;
    }
    subsample( float_prop_subsampling = 1, flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-07-16 17:12:19 
        subsample active entries in the current filter (or all the active entries with valid data) using the proportion of subsampling ratio 'float_prop_subsampling'
        
        'flag_return_valid_entries_in_the_currently_active_layer' : return bitarray filter containing only the active entries in the current layer 
        */
        // retrieve bitarray of active entries
        let ba_active_entries = this.get_ba_active_entries( flag_return_valid_entries_in_the_currently_active_layer );
        
        // return the bitarray of all active entries if no subsampling is required
        if ( check_none( float_prop_subsampling ) | ( float_prop_subsampling == 1 ) ) {
            return ba_active_entries;
        }
        
        // initialize the output bitarray filter that will contain subsampled entries
        let ba_subsampled = new BitSet( ); 
        
        // perform subsampling
        for ( let i = 0; i < this.int_num_entries; i ++ ) { // iterate over each entry
            if ( ( ba_active_entries.get( i ) > 0 ) & ( Math.random( ) < float_prop_subsampling ) ) { // determine whether an active entry should be included in the subsampled set.
                ba_subsampled.set( i, 1 ); 
            }
        }

        // return subsampled entries
        return ba_subsampled;
    }
    async change_filter( name_col_filter ) {
        /* # 2022-07-16 17:17:29 
        change filter using the filter saved in the metadata with 'name_col_filter' column name. if 'name_col_filter' is not available, current filter setting will not be changed.
        
        'name_col_filter' : name of the column of the metadata ZarrDataFrame containing the filter
        */
        if ( this.meta.columns.has( name_col_filter ) ) { // if a given column name exists in the current metadata ZarrDataFrame
            this.set_filter( await this.meta.get_item( name_col_filter, [ null ] ) ); // retrieve filter from the storage and apply the filter to the axis
        }
    }
    async get_str( queries = undefined, int_index_col = undefined ) {
        /* # 2022-09-22 12:07:01 
        get string representations of the queries
        
        'queries' : queries (list of integer indices) of the entries for which string representations will be loaded. if None is given, all entries will be retrieved.
        int_index_col : Union[ int, None ] = None : the index of the column containing string representation to retrieve. if a single integer index is given, retrieve values from a single column. If a list or a tuple of integer indices are given, values of the columns will be retrieved.
        */
        // retrieve all entries for the 'default' queries
        if ( check_none( queries ) ) {
            queries = nj.arange( this.int_num_entries ).tolist( );
        }
        // set default value for 'int_index_col'
        if ( check_none( int_index_col ) ) {
            int_index_col = this.int_index_str_rep;
        }
        // open a zarr object containing the string representation of the entries
        if ( ! check_none( this._sza ) ) {
            return await this._sza.get_by_l_int_index( queries, int_index_col );
        }
    }
    iterate_str( int_num_entries_in_a_batch= 1000, int_index_col = undefined ) {
        /* # iterate through string representations of the active entries of the current axis object
        
        int_num_entries_in_a_batch : int = 1000 # the number of entries that will be included in a batch
        int_index_col : Union[ int, None ] = None : the index of the column containing string representation to retrieve. if a single integer index is given, retrieve values from a single column. If a list or a tuple of integer indices are given, values of the columns will be retrieved.
        */
        return async function* makeIterator( ) { // return an iterator
            let l_int_entry_in_a_batch = [ ] // initialize a batch container 
            for ( let int_entry of ( check_none( this.filter ) ? nj.arange( this.int_num_entries ).tolist( ) : ba_to_integer_indices( this.filter, this.int_num_entries ) ) ) { // iterate through integer indices of the active entries
                l_int_entry_in_a_batch.push( int_entry );
                // if a batch is full, flush the batch
                if ( l_int_entry_in_a_batch.length >= int_num_entries_in_a_batch ) {
                    let arr = await this.get_str( l_int_entry_in_a_batch, int_index_col );
                    yield { 'l_int_entry' : l_int_entry_in_a_batch, 'l_str_entry' : arr };
                    l_int_entry_in_a_batch = [ ]; // initialize the next batch
                }
            }
            // if there are remaining entries, flush the batch
            if ( l_int_entry_in_a_batch.length > 0 ) {
                let arr = await this.get_str( l_int_entry_in_a_batch, int_index_col );
                yield { 'l_int_entry' : l_int_entry_in_a_batch, 'l_str_entry' : arr };
            }
        }( );
    }
    async load_str( int_index_col = undefined ) {
        /* # 2022-09-12 02:28:49 
        load string representation of all the active entries of the current axis, and retrieve a mapping from string representation to integer representation
        
        'int_index_col' : default value is 'this.int_index_str_rep'
        */
        // set default value for 'int_index_col'
        if ( check_none( int_index_col ) ) {
            int_index_col = this.int_index_str_rep;
        }
        
        // compose a pair of dictionaries for the conversion
        let arr_int_entry = check_none( this.filter ) ? nj.arange( this.int_num_entries ).tolist( ) : ba_to_integer_indices( this.filter, this.int_num_entries ), // retrieve integer representations of the entries
            arr_str = await this.get_str( arr_int_entry, int_index_col ); // retrieve string representations of the entries
        
        // build mapping
        let dict_str_to_i = { },
            dict_i_to_str = { };
        for ( let i = 0; i < arr_int_entry.length; i ++ ) {
            let int_entry = arr_int_entry[ i ],
                str_entry = arr_str[ i ];
            dict_str_to_i[ str_entry ] = int_entry;
            dict_i_to_str[ int_entry ] = str_entry;
        }
        // set attributes
        this._dict_str_to_i = dict_str_to_i;
        this._dict_i_to_str = dict_i_to_str;

        if ( this.verbose ) {
            console.log( `[Axis ${this._name_axis}] completed loading of ${arr_str.length} number of strings` );
        }
        return arr_str // return loaded strings
    }
    unload_str( ) {
        /* # 2022-06-25 09:36:59 
        unload a mapping between string representations and integer representations.
        */
        this._dict_str_to_i = undefined;
        this._dict_i_to_str = undefined;
    }
    async get_item( l, flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-07-14 00:42:20 
        a main functionality of 'Axis' class
        translate a given list of entries / mask (bitset/boolean_array), and return a bitarray mask containing valid entries
        
        inputs:
        [list of entries / mask (bitset/boolean_array)]
        
        returns:
        [a bitset object containing valid entries]
        */
        // ''' initialize '''
        let n = this.int_num_entries; // # retrieve the number of entries
        // # initialize the output object
        // # initialize the bitarray for the valid entries
        let ba_filter_of_selected_entries = new BitSet( );
        
        // # retrieve bitarray filter (or a filter of all active entries in the current layer)
        let ba_filter = ! check_none( this.filter ) ? this.filter : this.all( flag_return_valid_entries_in_the_currently_active_layer );
        
        // ''' handle 'None' '''
        if ( check_none( l ) ) {
            return ba_filter; // # if None is given, return all active entries in the filter (or all active entries in the layer if a filter has not been set).
        }
        
        // ''' handle a single value input '''
        if ( ( typeof l == 'number' ) | ( typeof l == 'string' ) ) { // # if a given input is not iterable or a string, wrap the element in a list
            l = [ l ];
        }
        
        // ''' handle an empty list input '''
        // # handle empty inputs // when an empty input is given, use all entries
        if ( l.length == 0 ) {
            return ba_filter; // # return results
        }
        
        // ''' handle string list input '''
        if ( typeof l[ 0 ] == 'string' ) { // # when string representations were given
            let flag_unload_str = false // # a flag to unload string representations before exiting
            // # if str has not been loaded, load the data temporarily
            if ( check_none( this._dict_str_to_i ) ) {
                flag_unload_str = true;
                await this.load_str( );
            }
            
            let dict_mapping = this._dict_str_to_i; // # retrieve a dictionary for mapping str to int
            for ( let e of l ) {
                if ( e in dict_mapping ) {
                    let i = dict_mapping[ e ];
                    if ( ba_filter.get( i ) > 0 ) { // # if the entry is acitve in the filter (or filter object containing all active entries)
                        ba_filter_of_selected_entries.set( i, 1 );
                    }
                }
            }
            
            // unload str data
            if ( flag_unload_str ) {
                this.unload_str( );
            }
            return ba_filter_of_selected_entries;
        }
        
        // ''' handle mask (bitarray / boolean array) '''
        if ( ( l.length == n ) & isSuperset( new Set( l.slice( 0, 10 ) ), new Set( [ 0, 1, true, false ] ) ) ) { // # detect boolean array
            let ba = to_ba( l ) // # convert mask to bitarray 
            return ba.and( ba_filter ); // # apply filter
        }
        
        // ''' handle integer index list input '''
        for ( let i of l ) {
            if ( ( 0 <= i ) & ( i < n ) & ( ba_filter.get( i ) > 0 ) ) {
                ba_filter_of_selected_entries.set( i, 1 );
            }
        }
        return ba_filter_of_selected_entries;
    }
    get map_str( ) {
        /* # 2022-06-25 09:31:32 
        return a dictionary for mapping string representation to integer representation
        */
        return this._dict_str_to_i;
    }
    get map_int( ) {
        /* # 2022-06-25 09:31:32 
        return a dictionary for mapping integer representation to string representation
        */
        return this._dict_i_to_str;
    }
    get length( ) {
        return this.meta.n_rows;
    }
}
class RamDataLayer {
    constructor( path_folder_ramdata, name_layer, ramdata = undefined, verbose = false, flag_debugging = false ) {
        /* 
        # 2022-07-31 14:33:46 
        */
        // these values will be fixed: dtype_of_feature_and_barcode_indices = np.uint32, dtype_of_values = np.float64
        // set attributes
        this._path_folder_ramdata = path_folder_ramdata;
        this._ramdata = ramdata;
        this.name = name_layer;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        this._path_folder_ramdata_layer = `${path_folder_ramdata}${name_layer}/`;
        
        // retrieve filters from the axes
        let ba_filter_features = check_none( ramdata ) ? undefined : ramdata.ft.filter,
            ba_filter_barcodes = check_none( ramdata ) ? undefined : ramdata.bc.filter;
        
        // set filters of the current layer
        this.ba_filter_features = ba_filter_features
        this.ba_filter_barcodes = ba_filter_barcodes
    }
    async initialize( ) {
        /* 
        # 2022-07-31 14:33:46 
        */
        // read metadata
        let zattrs = await $.getJSON( `${this._path_folder_ramdata_layer}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        this.metadata[ 'set_modes' ] = new Set( this.metadata[ 'set_modes' ] ) // convert modes to set
        this.modes = this.metadata[ 'set_modes' ]; // set attributes
        
        // load ramtx
        await this._load_ramtx_objects( )
        
        if ( this.verbose ) {
            console.log( `[RamDataLayer] '${this.name}' layer has been loaded` );
        }
    }
    async _load_ramtx_objects( ) {
        /* # 2022-08-01 10:57:28 
        load all ramtx present in the layer
        */
        // load RAMtx objects without filters
        // load ramtx
        for ( let mode of this.modes ) { // iterate through each mode
            let name_mode = `ramtx_${mode}`;
            if ( ! ( name_mode in this ) ) { // if the ramtx object of the current mode has not been load
                let rtx;
                if ( mode.includes( 'dense' ) ) {
                    continue;
                    // rtx = RAMtx( `${this._path_folder_ramdata_layer}dense/`, is_for_querying_features = mode.rsplit( 'dense_for_querying_', 1 )[ 1 ] == 'features' ) // open dense ramtx in querying_features/querying_barcodes modes
                } else {
                    rtx = new RAMtx( `${this._path_folder_ramdata_layer}${mode}/`, this._ramdata, this.verbose, this.flag_debugging );
                    await rtx.initialize( ); // initialize an rtx object
                    // set filters of the RAMtx object
                    rtx.ba_filter_features = this.ba_filter_features;
                    rtx.ba_filter_barcodes = this.ba_filter_barcodes;
                }
                this[ name_mode ] = rtx; // set ramtx as an attribute
            }
        }
    }
    select_ramtx( ba_entry_bc, ba_entry_ft ) {
        /* # 2022-07-31 11:46:33 
        select appropriate ramtx based on the queryed barcode and features, given as a bitarray filters 'ba_entry_bc', 'ba_entry_ft'
        */
        // count the number of valid queried entries
        let int_num_entries_queried_bc = count_ba( ba_entry_bc, this._ramdata.bc.int_num_entries ),
            int_num_entries_queried_ft = count_ba( ba_entry_ft, this._ramdata.ft.int_num_entries );
        
        // detect and handle the cases when one of the axes is empty
        if ( ( int_num_entries_queried_bc == 0 ) | ( int_num_entries_queried_ft == 0 ) ) {
            if ( this.verbose ) {
                console.log( `Warning: currently queried view is (barcode x features) ${int_num_entries_queried_bc} x ${int_num_entries_queried_ft}. please change the filter or queries in order to retrieve a valid data` );
            }
        }
        // choose which ramtx object to use
        let flag_use_ramtx_for_querying_feature = int_num_entries_queried_bc >= int_num_entries_queried_ft // select which axis to use. if there is more number of barcodes than features, use ramtx for querying 'features'
        
        let rtx = this.get_ramtx( flag_use_ramtx_for_querying_feature ); // retrieve ramtx
        if ( check_none( rtx ) ) {
            return undefined;
        }
        return rtx;
    }
    get_ramtx( flag_is_for_querying_features = true ) {
        /* # 2022-09-20 12:00:56 
        retrieve ramtx for querying feature/barcodes
        
        flag_is_for_querying_features = True # if True, return RAMtx that can be queried by features
        flag_prefer_dense = False # prefer dense matrix over sparse matrix
        set_int_index_component_to_exclude : Union[ None, set ] = None # set of integer indices of the components to exclude.
            the intended usage of this argument is to exclude RAMtx of the component that will be used as a reference
        */
        
        let name_axis_for_querying = flag_is_for_querying_features ? 'features' : 'barcodes',
            mode_dense = `dense_for_querying_${name_axis_for_querying}`, // retrieve mode name for dense ramtx based on 'flag_is_for_querying_features'
            mode_sparse = `sparse_for_querying_${name_axis_for_querying}`, // retrieve mode name for sparse ramtx based on 'flag_is_for_querying_features'
            mode = mode_sparse, // use sparse mode only
            name_mode = `ramtx_${mode}`; // name of the ramtx object for the selected mode
        if ( name_mode in this ) {
            return this[ name_mode ];
        }
        if ( this.verbose ) {
            console.log( `ramtx for querying ${name_axis_for_querying} efficiently is not available for layer ${this.name}, containing the following modes: ${[ ... this.modes]}` );
        }
        return undefined;
    }
    set_filter( ba_filter, flag_is_filter_for_features = true ) {
        /*
        set_filter of the given axis
        */
        if ( ! ( ( ba_filter instanceof BitSet ) | check_none( ba_filter ) ) ) {
            console.log( 'invalid filter was given for layer' );
        }
        let name_axis_of_filter = flag_is_filter_for_features ? 'features' : 'barcodes';
        
        // set filters of ramtx
        for ( let mode of this.modes ) { // iterate through each mode
            let name_mode = `ramtx_${mode}`;
            if ( mode.includes( 'dense' ) ) {
                continue;
            } else {
                this[ name_mode ][ `ba_filter_${name_axis_of_filter}` ] = ba_filter; // set filter
            }
        }
    }
}   
class RamData {
    constructor(  
        path_folder_ramdata, name_layer = undefined, int_index_str_rep_for_barcodes = 0, int_index_str_rep_for_features = 1, int_num_entries_for_each_weight_calculation_batch = 2000, int_total_weight_for_each_batch = 10000000, dict_kw_zdf = { 'flag_retrieve_categorical_data_as_integers' : false }, dict_kw_view = { 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' : 0.1 }, verbose = true, flag_debugging = false
    ) {
        // set attributes
        this._path_folder_ramdata = path_folder_ramdata;
        this.name_layer_default = name_layer;
        this.int_index_str_rep_for_barcodes = int_index_str_rep_for_barcodes;
        this.int_index_str_rep_for_features = int_index_str_rep_for_features;
        this.int_num_entries_for_each_weight_calculation_batch = int_num_entries_for_each_weight_calculation_batch;
        this.int_total_weight_for_each_batch = int_total_weight_for_each_batch;
        this.dict_kw_zdf = dict_kw_zdf;
        this.dict_kw_view = dict_kw_view;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        this.layer = undefined;
    }
    async initialize( ) {
        // initialize RamData
        // load metadata of RamData
        // should be run before using RamData
        let zattrs = await $.getJSON( `${this._path_folder_ramdata}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        
        // set attributes
        this.int_num_barcodes = this.metadata[ 'int_num_barcodes' ];
        this.int_num_features = this.metadata[ 'int_num_features' ];
        this.identifier = this.metadata[ 'identifier' ];
        this.metadata.layers = new Set( this.metadata.layers ); // get a set of name_layer
        this.layers = this.metadata.layers
        
        // load RamDataAxis
        // initialize axis objects
        this.bc = new RamDataAxis( this._path_folder_ramdata, 'barcodes', undefined, this, this.dict_kw_zdf, this.dict_kw_view, this.int_index_str_rep_for_barcodes, this.verbose, this.flag_debugging );
        await this.bc.initialize( );
        this.ft = new RamDataAxis( this._path_folder_ramdata, 'features', undefined, this, this.dict_kw_zdf, this.dict_kw_view, this.int_index_str_rep_for_features, this.verbose, this.flag_debugging );
        await this.ft.initialize( );

        if ( ! check_none( this.name_layer_default ) ) { // if the name_layer_default is valid
            await this.load_layer( this.name_layer_default );
        }
    }
    async load_layer( name_layer = undefined ) {
        /* 
        load layer 
        */
        this.layer = new RamDataLayer( this._path_folder_ramdata, name_layer, this, this.verbose, this.flag_debugging ); // load layer
        await this.layer.initialize( ); // initialize the layer object
    }
    repr( ) {
        /* 
        represent RamDat in a javascript REPL
        */
        let str_filter_bc = check_none( this.bc.filter ) ? '' : this.bc.meta.get_n_rows( ).toString( ) + '/',
            str_filter_ft = check_none( this.ft.filter ) ? '' : this.ft.meta.get_n_rows( ).toString( ) + '/',
            str_layer = check_none( this.layer ) ? '' : `, ${this.layer.int_num_records} records in the currently active layer '${this.layer.name}'`,
            str_name_layer = check_none( this.layer ) ? 'None' : this.layer.name;
        return `<(read-only) RamData object (${str_filter_bc}${this.metadata[ 'int_num_barcodes' ]} barcodes X ${str_filter_ft}${this.metadata[ 'int_num_features' ]} features` + str_layer + `) stored at ${this._path_folder_ramdata} with the following layers : ${[ ... this.layers ]} (current layer is '${str_name_layer}')>` // show the number of records of the current layer if available.
    }
    async change_filter( name_col_filter = undefined, name_col_filter_bc = undefined, name_col_filter_ft = undefined ) {
        /* # 2022-07-16 17:27:58 
        retrieve and apply filters for 'barcode' and 'feature' Axes
        
        'name_col_filter_bc', 'name_col_filter_ft' will override 'name_col_filter' when applying filters.
        if all name_cols are invalid, no filters will be retrieved and applied
        */
        // # check validity of name_cols for filter
        // # bc
        if ( ! this.bc.meta.columns.has( name_col_filter_bc ) ) {
            name_col_filter_bc = ( this.bc.meta.columns.has( name_col_filter ) ) ? name_col_filter : undefined; // # use 'name_col_filter' instead if 'name_col_filter_bc' is invalid
        }
        // # ft
        if ( ! this.ft.meta.columns.has( name_col_filter_ft ) ) {
            name_col_filter_ft = ( this.ft.meta.columns.has( name_col_filter ) ) ? name_col_filter : undefined; // # use 'name_col_filter' instead if 'name_col_filter_ft' is invalid
        }
        
        // # apply filters
        await this.bc.change_filter( name_col_filter_bc ); // # bc
        await this.ft.change_filter( name_col_filter_ft ); // # ft
    }
    create_view( ) {
        /*  # 2022-07-06 21:17:56 
        create view of the RamData using the current filter settings (load dictionaries for coordinate conversion for filtered barcodes/features)
        */
        this.ft.create_view( );
        this.bc.create_view( );
    }
    destroy_view( ) {
        /*  # 2022-07-05 22:55:22 
        unload dictionaries for coordinate conversion for filtered barcodes/features, destroying the current view
        */
        this.ft.destroy_view( );
        this.bc.destroy_view( );
    }
    async compose_filters( l_entry_bc = [ ], l_entry_ft = [ ], flag_use_str_repr_bc = false, flag_use_str_repr_ft = false ) {
        /* # 2022-07-16 17:10:07 
        for the given 'barcodes'/'features' entries, compose filters containing the entries, and apply the filters.
        
        === inputs ===
        'flag_use_str_repr_bc' = False, 'flag_use_str_repr_ft' = False : flags indicating whether to use string representation of the retrieved entries later
        
        === outputs === 
        bitarray mask of mapped entries and list of string representations (if available. if string representations were not used to retrieve entries, None will be returned for the list object).
        */
        // # retrieve flags indicating that the string representations are not loaded
        let flag_str_not_loaded_bc = check_none( this.bc.map_int ),
            flag_str_not_loaded_ft = check_none( this.ft.map_int );
        
        // ''' retrieve filters and string representations for the queried entries '''
        // ''' barcode '''
        // # load str representation data
        if ( flag_use_str_repr_bc & flag_str_not_loaded_bc ) {
            await this.bc.load_str( );
        }
        // # retrieve filter for the queried entries
        let ba_entry_bc = await this.bc.get_item( l_entry_bc );
        
        // # retrieve str representations of the queried entries
        let l_str_bc = undefined;
        if ( flag_use_str_repr_bc ) {
            let dict_map = this.bc.map_int;
            l_str_bc = [ ];
            for ( let i of ba_to_integer_indices( ba_entry_bc, this.bc.int_num_entries ) ) {
                l_str_bc.push( dict_map[ i ] );
            }
            dict_map = undefined; // delete 'dict_map' for garbage collection
        }
        if ( flag_str_not_loaded_bc ) { // # if 'str' data was not loaded, unload the str data once all necessary data has been retrieved
            this.bc.unload_str( );
        }
        
        // ''' feature '''
        // # load str representation data
        if ( flag_use_str_repr_ft & flag_str_not_loaded_ft ) {
            await this.ft.load_str( );
        }
        // # retrieve filter for the queried entries
        let ba_entry_ft = await this.ft.get_item( l_entry_ft );
        // retrieve str representations of the queried entries
        let l_str_ft = undefined;
        if ( flag_use_str_repr_ft ) {
            let dict_map = this.ft.map_int;
            l_str_ft = [ ];
            for ( let i of ba_to_integer_indices( ba_entry_ft, this.ft.int_num_entries ) ) {
                l_str_ft.push( dict_map[ i ] );
            }
            dict_map = undefined; // delete 'dict_map' for garbage collection
        }
        if ( flag_str_not_loaded_ft ) { // # if 'str' data was not loaded, unload the str data once all necessary data has been retrieved
            this.ft.unload_str( );
        }
        
        return [ ba_entry_bc, l_str_bc, ba_entry_ft, l_str_ft ]; // # return composed filters and mapped string representations (if available)
    }
    async get_item( args ) {
        /* # 2022-08-05 17:18:47 
        please include 'str' in 'barcode_column' and 'feature_column' in order to use string representations in the output AnnData object
        
        possible usages:
        
        [ name_layer, barcode_index, barcode_column, feature_index, feature_column ]
        [ barcode_index, barcode_column, feature_index, feature_column ]
        'barcode_column' and 'feature_column' can include multi-dimensional data 
        for example, 
            [ 'str', { 'X_pca' : slice( 0, 10 ), 'X_umap', : None } ] as 'barcode_column' will include X_umap and X_pca in obsm in the resulting anndata object
            [ 'str', { 'X_pca' : slice( 0, 10 ), { 'X_umap' } ] as 'barcode_column' will also include X_umap and X_pca in obsm in the resulting anndata object
        */
        if ( ! ( args instanceof Array ) ) { // # more than one arguments should be given
            if ( this.verbose ) {
                console.log( 'invalid queries, exiting' );
            }
        }
        // if the first argument appears to be 'name_layer', load the layer and drop the argument
        if ( ( typeof args[ 0 ] == 'string' ) & ( this.layers.has( args[ 0 ] ) ) ) {
            let name_layer = args[ 0 ];
            await this.load_layer( name_layer ); // load the layer
            args = args.slice( 1 );
        }
        // # assumes layer has been loaded, and remaining arguments are only for barcode/feature indexing
        if ( args.length > 4 ) {
            if ( this.verbose ) {
                console.log( 'the number of arguments are too many, exiting.' )
            }
        }
        
        // # make the number of arguments to 4
        for ( let i = 0; i < 4 - args.length; i ++ ) {
            args.push( [ ] ); // push an empty array
        }
        // # parse arguments
        let l_entry_bc = args[ 0 ], 
            l_col_bc = args[ 1 ], 
            l_entry_ft = args[ 2 ], 
            l_col_ft = args[ 3 ];
        
        // backup the filters
        let ba_filter_bc_backup = this.bc.filter,
            ba_filter_ft_backup = this.ft.filter;
        
        // retrieve flags for using string representations in the output
        let flag_use_str_repr_bc = l_col_bc.includes( 'str' ),
            flag_use_str_repr_ft = l_col_ft.includes( 'str' );
        
        // load a layer
        if ( check_none( this.layer ) ) {
            if ( this.layers.size == 0 ) { // # if no layer is available
                if ( this.verbose ) {
                    console.log( 'no layer is available. current implementation requires at least one layer, exiting' );
                    return;
                }
            }
            await this.load_layer( [ ... this.layers ][ 0 ] ); // load any layer
        }
        
        // compose filters from the queried entries
        let res = await this.compose_filters( l_entry_bc, l_entry_ft, flag_use_str_repr_bc, flag_use_str_repr_ft );
        let ba_entry_bc = res[ 0 ], 
            l_str_bc = res[ 1 ], 
            ba_entry_ft = res[ 2 ], 
            l_str_ft = res[ 3 ];
        
        // retrieve ramtx for retrieving data
        let rtx = this.layer.select_ramtx( ba_entry_bc, ba_entry_ft );
        
        // set barcode/feature filters for the queried entries
        this.bc.set_filter( ba_entry_bc );
        this.ft.set_filter( ba_entry_ft );

        // initialize and destroy the view after retrieving the count matrix
        // # load 'dict_change' for coordinate conversion according to the given filters, creating the view of the RamData
        
        // # retrieve count data
        this.create_view( ); // create view
        let X = await rtx.get_sparse_matrix( [ ] ) // # retrieve count data for all entries currently active in the filter
        this.destroy_view( ); // destroy view
        
        // retrieve meta data as dataframes
        let df_obs = await this.bc.meta.get_df( l_col_bc );
        
        if ( flag_use_str_repr_bc ) { // # add string representations
            df_obs.add_column( 'str', l_str_bc ); // add a column containing string representations
            df_obs.set_index( 'str' ); // use string representations as index
            l_str_bc = undefined; // delete 'l_str_bc'
        }
        let df_var = await this.ft.meta.get_df( l_col_ft );
        if ( flag_use_str_repr_ft ) { // # add string representations
            df_var.add_column( 'str', l_str_ft ); // add a column containing string representations
            df_var.set_index( 'str' ); // use string representations as index
            l_str_ft = undefined; // delete 'l_str_ft'
        }
        
        // build output AnnData object
        let adata = new AnnData( X, df_obs, df_var ) // # in anndata.X, row = barcode, column = feature // # set obs and var with integer index values // # add count data
        
        // # add obsm/varm
        let l_ax = [ this.ft, this.bc ],
            l_name_adata_attr = [ 'varm', 'obsm' ],
            l_l_col = [ l_col_ft, l_col_bc ];
        for ( let i = 0; i < 2; i ++ ) { // for each axis
            // retrieve axis
            let ax = l_ax[ i ],
                name_adata_attr = l_name_adata_attr[ i ],
                l_col = l_l_col[ i ];
            for ( let e of l_col ) {
                if ( e instanceof Array ) { // # retrieve all data in the secondary axis
                    for ( let name_col of e ) {
                        if ( ax.meta.columns.has( name_col ) ) { // if the column exists in the metadata
                            adata[ name_adata_attr ][ name_col ] = await ax.meta.get_item( name_col );
                        }
                    }
                } else if ( e instanceof Object ) { // # indexing through secondary axis
                    for ( let name_col in e ) {
                        if ( ax.meta.columns.has( name_col ) ) { // if the column exists in the metadata
                            adata[ name_adata_attr ][ name_col ] = await ( check_none( e[ name_col ] ) ? ax.meta.get_item( name_col ) : ax.meta.get_item( name_col, undefined, e[ name_col ] ) ); // # if e[ name_col ] is None, load all data on the secondary axis
                        }
                    }
                }
            }
        }

        // restore the filters once the data retrieval has been completed
        this.bc.set_filter( ba_filter_bc_backup );
        this.ft.set_filter( ba_filter_ft_backup );
        
        return adata; // # return resulting AnnData
    }
}
/*
Implementation of RamData.js [END]
*/
    
// functions for UI components
function Select_RemoveOptions_Using_ID( id_selectElement ) { // remove all option in the select element using id
    let sel = document.getElementById( id_selectElement ),
        length = sel.options.length - 1;
    for( let i = length; i >= 0; i -- ) {
        sel.remove( i );
    }
}
function Select_Get_Selected_Option_Using_ID( id_selectElement ) { // get selected option in the select element with its id
    let sel = document.getElementById( id_selectElement );
    // if the number of options is zero, return undefined
    if ( sel.options.length == 0 ) {
        return undefined;
    }
    if ( sel.multiple ) { 
        // if the selection object is multi-selection-object
        let l_option = sel.options, 
            l_option_selected = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) { // for each option
            let option = l_option[ i ]; // retrieve current option 
            if ( option.selected ) { // if the current option has been selected
                l_option_selected.push( option ); 
            } 
        }
        return l_option_selected; // return the list of selected options
    } else { // if selection object is single-selection-object
        return sel.options[ sel.selectedIndex ];
    }
}
function Select_Get_Value_from_Option( opt ) {
    /*
    get value from the select option
    */
    if ( check_none( opt ) ) { // if option is invalid, return option without accessing its value attribute.
        return opt;
    }
    return opt.value
}
function Select_AddOptions_Using_ID( id_selectElement, dict_innerHTML_to_value ) { // add options in the select element using id and the given dictionary containing innerHTML (key) and values (values). alternatively, an Array can be given, whose values will be used to initialize both innerHTMLs and values of the options
    // get select element
    let sel = document.getElementById( id_selectElement );
    
    // add options 
    if ( Array.isArray( dict_innerHTML_to_value ) ) { // each entry will be used to initialize both innerHTML and value
        for ( let name of dict_innerHTML_to_value ) {
            let opt = document.createElement( 'option' );
            // set value and name of the option
            opt.value = name;
            opt.innerHTML = name;
            sel.appendChild( opt );
        }
    } else { // innerHTML (key) and values (values)
        for ( let name in dict_innerHTML_to_value ) {
            let opt = document.createElement( 'option' ),
                val = dict_innerHTML_to_value[ name ];
            // set value and name of the option
            opt.value = val;
            opt.innerHTML = name;
            sel.appendChild( opt );
        }
    }
}
function Select_SelectOption_Using_ID( id_selectElement, value ) { // select value
    // get select element
    let sel = document.getElementById( id_selectElement );
    
    if ( Array.isArray( value ) ) { // if a list of selection values was given
        let set_value = new Set( value ); // retrieve a set of unique values to select
        for ( let opt of sel.options ) { // iterate over option
            if ( set_value.has( opt.value  ) ) { // if the option has the value of the given list of values to select
                opt.selected = true; // select the option
            }
        }
    } else {
        // if only single value was used for selection
        sel.value = value;
    }
}
    

// functions for plotting and interacting with html document
// for argsort
let argsort = arr => arr.map( (v, i) => [v, i] ).sort( ).map( a => a[ 1 ] ); // a function for arg-sorting an array
// for Array operations
// functions for numpy-like operations
function ArraySum( l ) { // return the sum of values of an array
    return l.reduce( (a, b) => a + b, 0 );
}
function ArrayIndexing( l, l_index ) {
    let l_output = [ ];
    for ( let i = 0; i < l_index.length; i++ ) { l_output.push( l[ l_index[ i ] ] ); }
    return l_output
}
function ArrayBooleanIndexing( l, l_bool ) {
    let l_output = [ ];
    for ( let i = 0; i < l_bool.length; i++ ) { if ( l_bool[ i ] ) { l_output.push( l[ i ] ); } }
    return l_output
}
function ArrayBoolAND( l_l ) {
    let l_output = [ ];
    for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
        let output = true;
        for ( let i = 0; i < l_l.length; i++ ) { output = output && l_l[ i ][ j ]; }
        l_output.push( output );
    }
    return l_output;
}
function ArrayBoolOR( l_l ) {
    let l_output = [ ];
    for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
        let output = false;
        for ( let i = 0; i < l_l.length; i++ ) { output = output || l_l[ i ][ j ]; }
        l_output.push( output );
    }
    return l_output;
}
function ArrayBoolNOT( l ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] ? false : true ); }
    return l_output;
}
function ArrayGreaterThan( l, thres ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] > thres ); }
    return l_output;
}
function ArrayLessThan( l, thres ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] < thres ); }
    return l_output;
}
function ArrayFull( length, value ) {
    let l_output = [ ];
    for ( let i = 0; i < length; i++ ) { l_output.push( value ); }
    return l_output;
}
function ArrayBroadCasting( l, l_bool, value ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l_bool[ i ] ? value : l[ i ] ); }
    return l_output;
}
function ArrayCap( l, value ) { // cap value of a given list at the given capping value (manually set maximum value)
    l_modified = lodash.cloneDeep( l );
    for ( let i = 0; i < l.length; i ++ ) {
        if ( l[ i ] > value ) { // cap value of a given list at the given capping value (manually set maximum value)
            l_modified[ i ] = value;
        }
    }
    return l_modified
}
function ArrayFloor( l, value ) { // floor value of a given list at the given flooring value (manually set minimum value)
    l_modified = lodash.cloneDeep( l );
    for ( let i = 0; i < l.length; i ++ ) {
        if ( l[ i ] < value ) { // cap value of a given list at the given capping value (manually set maximum value)
            l_modified[ i ] = value;
        }
    }
    return l_modified
}
function ArrayApply( l, a_function ) { // apply certain function to all of values of a given array
    let l_output = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_output[ i ] = a_function( l[ i ] );
    }
    return l_output
}
function ArrayMap( l, dictionary, default_value = undefined ) { // map values in a given array using a given dictionary
    let l_output = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_output[ i ] = ( l[ i ] in dictionary ) ? dictionary[ l[ i ] ] : default_value;
    }
    return l_output
}
function ArrayTranspose( l_l ) { // transpose 2d array
    let n_row = l_l.length, n_col = l_l[ 0 ].length, l_l_t = [ ]; // transposed 2d array
    for ( let i = 0; i < n_col; i ++ ) {
        let l_t = [ ]; // transposed column (now a row)
        for ( let j = 0; j < n_row; j ++ ) { l_t.push( l_l[ j ][ i ] ); }
        l_l_t.push( l_t );
    }
    return l_l_t;
}
function ArrayAsInt( l ) { 
    let l_int = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_int.push( parseInt( l[ i ] ) ); // parse a string into an integer for each entry
    }
    return l_int
} // convert array of strings to array of integers
function ArrayAverage( l ) { // calculate average of values in the array
    let sum = l.reduce( ( a, b ) => a + b, 0 );
    let avg = ( sum / l.length ) || 0;
    return avg;
}
function ArrayMultiply( l, float_multiply_by ) { // return a list with values multiplied by 'float_multiply_by'
    let l_multiplied = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_multiplied.push( l[ i ] * float_multiply_by );
    }
    return l_multiplied;
}
    
/*
RamData locations settings [START]
*/
let dict_ramdata_locations = {
    '20220910_EBI_Broad_HCA_TS_combined_ramdata_subset_160000_barcodes' : 'http://172.27.30.99/web_applications/20220718_sce.js/20220910_EBI_Broad_HCA_TS_combined_ramdata_subset_160000_barcodes/',
    'baron_8K_pancreas_rnaseq_8569_barcodes_ramdata' : 'http://172.27.30.99/web_applications/20220718_sce.js/baron_8K_pancreas_rnaseq_8569_barcodes_ramdata/',
    'all_features_only_gene_6447300_barcodes_sorted_ramdata' : 'http://172.27.30.99/web_applications/20220718_sce.js/all_features_only_gene_6447300_barcodes_sorted_ramdata/',
    'hca_783K_blood_rnaseq_782859_barcodes_ramdata' : 'http://172.27.30.99/web_applications/20220718_sce.js/hca_783K_blood_rnaseq_782859_barcodes_ramdata/',
}
/*
RamData locations settings [END]
*/
    
let dict_data = { 
    'canvas' : {
        'set_name_div' : new Set( )
    },
    'dict_ramdata' : {
    },
    'dict_anndata' : {
    },
    'bs_components' : {
        'offcanvasLoadRamData' : new bootstrap.Offcanvas( document.getElementById( "offcanvasLoadRamData" ), { backdrop: true } ),
        'offcanvasRetrieveAnnData' : new bootstrap.Offcanvas( document.getElementById( "offcanvasRetrieveAnnData" ), { backdrop: true } ),
        'offcanvasPlotAnnData' : new bootstrap.Offcanvas( document.getElementById( "offcanvasPlotAnnData" ), { backdrop: false, scroll: true } )
    },
    'misc' : { // miscellaneous variables
        'name_option_no_filter' : 'no filter (all entries)',
        'function_colormap_rainbow' : chroma.scale( [ '#f00','#0f0','#00f','#f00' ] ).mode('hsl') // colormaps
    }
}
    
function create_div( name_div, style = "width:1100px;height:1100px;", flag_create_dual_div = false ) {
    /*
    create a new div for plotting graph
    
    'flag_create_dual_div' : create two divisions next to each other
    */
    if ( ! dict_data.canvas.set_name_div.has( name_div ) ) { // create div when 'name_div' does not exist in the canvas
        let div_new = document.createElement( 'div' );
        div_new.id = `${name_div}_container`;
        div_new.className = 'plot_container';
        if ( flag_create_dual_div ) {
            div_new.innerHTML = `<h5><span class="badge rounded-pill bg-secondary">${name_div}<button type="button" class="btn-close btn-close-white" aria-label="close figure" onclick="delete_div( '${name_div}' );"></button></span></h5><div id="${name_div}__top__" style="${style} class="plot"></div><div id="${name_div}__bottom__" style="${style} class="plot"></div>`;
        } else {
            div_new.innerHTML = `<h5><span class="badge rounded-pill bg-secondary">${name_div}<button type="button" class="btn-close btn-close-white" aria-label="close figure" onclick="delete_div( '${name_div}' );"></button></span></h5><div id="${name_div}" class="plot" style="${style}"></div>`;
        }
        $( '#canvas' )[ 0 ].prepend( div_new );
        dict_data.canvas.set_name_div.add( name_div ); // add 'name_div' to the set of div names
    }
}
function delete_div( name_div ) {
    /*
    create the given div for plotting graph
    */
    if ( dict_data.canvas.set_name_div.has( name_div ) ) { // delete div when 'name_div' exists in the canvas
        let div = document.getElementById( `${name_div}_container` );
        div.remove( ); // delete the div from the document
        dict_data.canvas.set_name_div.delete( name_div ); // delete the name of div from the set of divisions
    }
}

let name_application = 'scelephant.js'
let config_plotly = { responsive: true, displaylogo: false, toImageButtonOptions: { hoverClosestCartesian: true, format: 'png', filename: name_application, height: 750, width: 1100, scale: 1 }, modeBarButtonsToRemove: [ 'autoScale2d', 'toggleSpikelines', 'hoverCompareCartesian', 'hoverClosestCartesian' ] } // flexible plot width according to the window size  // do not display plotly logo

function adaptive_marker_size( ed, div, dict_kw_args ) {
    /*
    adaptively change marker sizes
    */
    // if no event was detected, exit
    if ( Object.entries( ed ).length === 0 ) { return; }
    
    // function for calculating responsive marker size
    function ResponsiveMarkerSize( div, marker_size_default = 5, int_factor_axis_range_to_marker_size = 30, int_factor_marker_size_multiply = 3 ) { // get marker size according to the given parameter and x- and y-axis range of the division containing a plotly plot
        if ( ! ( 'layout' in div ) ) {
            return marker_size_default; // if plotly has not been drawn, use the default value for the marker size
        }
        let x = div.layout.xaxis, y = div.layout.yaxis,
            int_marker_size_to_be_updated = Math.min( 10, Math.min( Math.ceil( int_factor_axis_range_to_marker_size / ( x.range[ 1 ] - x.range[ 0 ] ) ), Math.ceil( int_factor_axis_range_to_marker_size / ( y.range[ 1 ] - y.range[ 0 ] ) ) ) * int_factor_marker_size_multiply );
        return int_marker_size_to_be_updated;
    }
    
    // broadcasting updated zoom level across plots
    let x = div.layout.xaxis, y = div.layout.yaxis, flag_relayout = false, update = { }; // a flag indicating whether a relayout event is required
    // ignore when layouts are changed due to autoranging
    let int_marker_size_current = div.data[ 0 ].marker.size,
        int_marker_size_to_be_updated = ResponsiveMarkerSize( div, dict_kw_args[ 'marker_size' ], dict_kw_args[ 'int_factor_axis_range_to_marker_size' ], dict_kw_args[ 'int_factor_marker_size_multiply' ] ),
        flag_restyle = int_marker_size_to_be_updated != int_marker_size_current; // retrieve a marker indicating whether the marker size should be updated 

    if ( flag_restyle ) { // restyle existing plot
        console.log( "[adaptive_marker_size] restyling marker size to ", int_marker_size_to_be_updated );
        let update = { marker : div.data[ 0 ].marker };
        update.marker.size = int_marker_size_to_be_updated;
        Plotly.restyle( div, update, [ 0 ] );
    } 
}
function synchronized_layout( ed, divs ) {
    /*
    synchronization of zoom levels across plotly plots
    */
    if ( Object.entries( ed ).length === 0 ) { return; }
    // broadcasting updated zoom level across plots
    divs.forEach( ( div, i ) => {
        let x = div.layout.xaxis, y = div.layout.yaxis, flag_relayout = false, update = { }; // a flag indicating whether a relayout event is required
        // ignore when layouts are changed due to autoranging
        if ( ( ed[ "xaxis.autorange" ] && x.autorange ) && ( ed[ "yaxis.autorange" ] && y.autorange ) ) { 
            return;
        }
        // update x-axis
        if ( x.range[ 0 ] != ed[ "xaxis.range[0]" ] || x.range[ 1 ] != ed[ "xaxis.range[1]" ] ) {
            flag_relayout = true;
            update = { ... update, 'xaxis.range[0]': ed[ "xaxis.range[0]" ], 'xaxis.range[1]': ed[ "xaxis.range[1]" ], 'xaxis.autorange': ed[ "xaxis.autorange" ] };
        }
        // update y-axis
        if ( y.range[ 0 ] != ed[ "yaxis.range[0]" ] || y.range[ 1 ] != ed[ "yaxis.range[1]" ] ) {
            flag_relayout = true;
            update = { ... update, 'yaxis.range[0]': ed[ "yaxis.range[0]" ], 'yaxis.range[1]': ed[ "yaxis.range[1]" ], 'yaxis.autorange': ed[ "yaxis.autorange" ] };
        }
        if ( flag_relayout ) {
            Plotly.relayout( div, update ); // perform relayout operation
        }

    });
}
function draw_graph( name_div, adata, dict_kw_args ) {
    /*
    name_div // name of the division to draw plots
    adata // anndata
    dict_kw_args // keyworded arguments
        - name_gene : undefined // if given, show expression of a gene
        - sort_by_value : true // 
    
    */  
    // define default keworded arguments
    let dict_kw_args_default = {
        'name_gene' : undefined, // if given, show expression of a gene
        'sort_by_value' : true, // if true, sort barcodes by value that is used to color points, preventing lower-priority points to cover high-priority points
        'name_col_obs' : undefined, // if given, display values of a column of adata.obs
        'name_col_embedding' : undefined, // name of obsm data that contains embedding coordinates (assumes NestedArray was given)
        'flag_plot_feature' : true, // if true, plot feature using 'name_gene'. if false, plot obs column from adata.obs
        'name_embedding' : 'UMAP', // name of the embedding method. used to label axes
        'marker_size' : 3, 
        'fig_size' : [ 1100, 1100 ], // the figure size of the new plot (height/width)
        'int_factor_axis_range_to_marker_size' : 30, // for responsive marker size
        'int_factor_marker_size_multiply' : 3, // for responsive marker size
        'vmax' : undefined, // set a maximum value to visualize. useful when an outlier exists and dampens the signals
        'title' : 'default figure name',
        'fontsize_title' : 24,
        'font_title' : 'Calibri',
        'flag_responsive_marker_size' : false,
        'flag_recreate_div' : false, // does recreate the div
    }
    
    dict_kw_args = { ... dict_kw_args_default, ... dict_kw_args }; // compose 'dict_kw_args' using the default keyworded arguments and given keyworded arguments
    
    // recreate div if 'flag_recreate_div' is True
    if ( dict_kw_args[ 'flag_recreate_div' ] ) {
        // if the panel already exists, delete and recreate the panel
        if ( dict_data.canvas.set_name_div.has( name_div ) ) {
            delete_div( name_div ); // delete the panel
        }
        // create a new panel
        create_div( name_div, style = `width:${dict_kw_args[ 'fig_size' ][ 0 ]}px;height:${dict_kw_args[ 'fig_size' ][ 1 ]}px;` );
    }
    
    let marker_colormap = { showscale: true, colorscale: "YlOrRd", reversescale: true }; // setting for showing colormap
    let str_hovertemplate_additional_line = ''; // "<b>" + str_name_option_selected + "</b>: <b>%{marker.color:." + ( ( str_name_option_selected == 'MT Percentage' ) ? 1 : 0 ).toString( ) + "f}</b><br>"; // only MT percentage data will be shown as floating point numbers
    
    let marker_size = dict_kw_args[ 'marker_size' ],
        l_color = undefined,
        l_val_feature = undefined,
        l_val_obs = undefined,
        l_x = [ ... adata.obsm[ dict_kw_args[ 'name_col_embedding' ] ].get( [ null, 0 ] ).flatten( ) ],
        l_y = [ ... adata.obsm[ dict_kw_args[ 'name_col_embedding' ] ].get( [ null, 1 ] ).flatten( ) ],
        l_trace = [ ]; // initialize the list of plotly scatter traces

    // retrieve values
    // retrieve color values according to the setting
    if ( ( ! check_none( dict_kw_args[ 'name_gene' ] ) ) & ( dict_kw_args[ 'name_gene' ] in adata.var._dict_mapping_index ) ) {
        l_val_feature = adata.X.subset( adata.var.get_integer_indices_of_rows( [ dict_kw_args[ 'name_gene' ] ] ) ).to_dense( ).T.tolist( )[ 0 ]; // [ ... adata.obs.get_column( 'raw_sum' ).flatten( ) ]
    }
    l_val_obs = adata.obs.get_column( dict_kw_args[ 'name_col_obs' ] );
    l_color = ( dict_kw_args[ 'flag_plot_feature' ] ) ? l_val_feature : l_val_obs; // retrieve values for setting colors
    if ( check_none( l_color ) ) { // if invalid inputs were given, exit
        return;
    }

    let flag_color_using_continuous_values = typeof l_color[ 0 ] == 'number', // retrieve a flag indicating whether the array contains float value
        name_val_for_color = dict_kw_args[ 'flag_plot_feature' ] ? dict_kw_args[ 'name_gene' ] : dict_kw_args[ 'name_col_obs' ]; // retrieve name of values for coloring points
    
    if ( flag_color_using_continuous_values ) { // if values are continuous values
        // cap the values according to the setting
        if ( ! check_none( dict_kw_args[ 'vmax' ] ) ) { // if valid 'vmax' value has been given
            l_color = ArrayCap( l_color, dict_kw_args[ 'vmax' ] ); // cap values
        }

        // sort by color value according to the setting.
        if ( dict_kw_args[ 'sort_by_value' ] ) {
            let argsort_by_color = argsort( l_color );
            // sort by color value
            l_x = ArrayIndexing( l_x, argsort_by_color );
            l_y = ArrayIndexing( l_y, argsort_by_color );
            l_color = ArrayIndexing( l_color, argsort_by_color );
        }

        // compose a single trace when values are continuous
        let trace = {
            mode: 'markers',
            type: 'scattergl',
            x: l_x,
            y: l_y,
            customdata: ArrayTranspose( [ l_color
                                        ] ),
            hovertemplate: [ `${name_val_for_color}: %{customdata[0]:.5f}`,
                            `UMAP: <b>%{x:.2f}</b>, <b>%{y:.2f}</b>`,
                            "<extra></extra>" ].join( "<br>" ),
            marker: { 
                color: l_color,
                size: dict_kw_args[ 'marker_size' ]
            },
            line: { 
                width: 0
            },
        };
        trace.marker = { ... trace.marker, ... marker_colormap }; // update setting for showing colormap
        l_trace.push( trace ); // add trace to the list of traces
    } else {
        let dict_category_to_dict_data = { }; // initialize dict_data for each category
        for ( let i = 0; i < l_color.length; i ++ ) {
            let e = l_color[ i ],
                x = l_x[ i ],
                y = l_y[ i ];
            // handle 'None' category as a separate category
            if ( check_none( e ) ) {
                e = 'None';
            }
            // initialize dict_data for the category
            if ( ! ( e in dict_category_to_dict_data ) ) {
                dict_category_to_dict_data[ e ] = { l_x: [ ], l_y: [ ] }; 
            }
            dict_category_to_dict_data[ e ].l_x.push( x );
            dict_category_to_dict_data[ e ].l_y.push( y );
        }
        
        // compose trace for 'None' category before other traces can be composed
        if ( 'None' in dict_category_to_dict_data ) { // if 'None' category exists
            let e = 'None';
            let trace = {
                name: e, // set category name as the name of the trace
                mode: 'markers',
                type: 'scattergl',
                x: dict_category_to_dict_data[ e ].l_x,
                y: dict_category_to_dict_data[ e ].l_y,
                hovertemplate: [ `${name_val_for_color}: ${e}`,
                                `UMAP: <b>%{x:.2f}</b>, <b>%{y:.2f}</b>`,
                                "<extra></extra>" ].join( "<br>" ),
                marker: { 
                    color: '#f2f2f2', // set color for 'None' category
                    size: dict_kw_args[ 'marker_size' ]
                },
                line: { 
                    width: 0
                },
            };
            l_trace.push( trace ); // add trace to the list of traces
            delete dict_category_to_dict_data[ 'None' ]; // delete 'None' category
        }
        
        // compose traces        
        for ( let e in dict_category_to_dict_data ) { // for each category
            let trace = {
                name: e, // set category name as the name of the trace
                mode: 'markers',
                type: 'scattergl',
                x: dict_category_to_dict_data[ e ].l_x,
                y: dict_category_to_dict_data[ e ].l_y,
                hovertemplate: [ `${name_val_for_color}: ${e}`,
                                `UMAP: <b>%{x:.2f}</b>, <b>%{y:.2f}</b>`,
                                "<extra></extra>" ].join( "<br>" ),
                marker: { 
                    color: dict_data.misc.function_colormap_rainbow( ( Math.abs( e.hashCode( ) ) % 100 ) / 100 ), // assign color of the entry using hasing
                    size: dict_kw_args[ 'marker_size' ]
                },
                line: { 
                    width: 0
                },
            };
            l_trace.push( trace ); // add trace to the list of traces
        }
    }
   // draw plot using plotly.js
   let div_plot = $( "#" + name_div )[ 0 ], // retrieve div to create a plot
        layout = { 
        margin: { l: 65, r: 65, b: 90, t: 25, pad: 4 }, 
        xaxis: { title : `${dict_kw_args[ 'name_embedding' ]}-1`, zeroline: false }, 
        yaxis: { title : `${dict_kw_args[ 'name_embedding' ]}-2`, zeroline: false }, 
        hovermode: "closest"
    };
    
    // if valid 'title' was given, set title name
    if ( dict_kw_args[ 'title' ].length > 0 ) {
        layout[ 'title' ] = {
            text : dict_kw_args[ 'title' ],
            font : {
                family : dict_kw_args[ 'font_title' ],
                size : dict_kw_args[ 'fontsize_title' ]
            },
            xref: 'paper',
            x: 0.05,
        }
        layout.margin.t = 50; // increase top margin since figure title will not be set
    }
    Plotly.newPlot( div_plot, l_trace, layout, { ... config_plotly, filename: 'single-cell-graph', height: dict_kw_args[ 'fig_size' ][ 0 ], width: dict_kw_args[ 'fig_size' ][ 1 ] } ); // draw scatter plot of the annotation

    
    // add event listner when 'flag_responsive_marker_size' is set to True
    if ( dict_kw_args[ 'flag_responsive_marker_size' ] ) {
        div_plot.on( "plotly_relayout", function( ed ) {
            adaptive_marker_size( ed, div_plot, dict_kw_args );
        });
    }
}
    
{
// object_data.main.gene.expr = { data : { }, data_size : 250 }; // cache of expression data // size of the cache
// object_data.main.cell_marker = { data : { }, data_size : 5 };
// object_data.main.gene.correl = { data : { }, data_size : 10 };
// object_data.main.umap = { tissue : 'not_drawn' }
// object_data.main.scatter = { x_label : 'UMAP-1', y_label : 'UMAP-2', x_axis_option : '__UMAP__', y_axis_option : '__UMAP__', x_axis_col_name : 'UMAP_1', y_axis_col_name : 'UMAP_2', flag_waiting_selection_of_gene : false, gene_symbol_selected : '', flag_axis_using_gene_expr : true }; // initialize axis of the scatter plot
// object_data.setting.expression = { };
// object_data.setting.expression.n_digits_below_floating_point = 3; // number of digits below floading point of the original expression values (converted to integer by multiplying 1000 during delivery of the data)
// object_data.main.datatable = { 'datatable_cell_marker' : { df : null, name : 'cell_marker' }, 'datatable_correl' : { df : null, name : 'correl_gene' } };

// async function Change_UMAP_Coordinate( str_tissue = null ) { 
//     if ( str_tissue === null ) {
//         // change x or y-axis of scatter plot using the current setting
//         let select_x_axis = $id( 'select_scatter_x_axis' ),
//             select_y_axis = $id( 'select_scatter_y_axis' ),
//             x_axis_option_current = select_x_axis.value,
//             y_axis_option_current = select_y_axis.value,
//             x_axis_option_previous = object_data.main.scatter.x_axis_option,
//             y_axis_option_previous = object_data.main.scatter.y_axis_option,
//             flag_update_x_axis = x_axis_option_current != x_axis_option_previous,
//             flag_update_y_axis = y_axis_option_current != y_axis_option_previous,
//             flag_update_axis = flag_update_x_axis | flag_update_y_axis;
//         if ( ! flag_update_axis ) {
//             console.log( "[Change_UMAP_Coordinate] no change in x- or y-axis setting detected, exiting" );
//             return -1
//         }
//         if ( flag_update_x_axis ) { // update x-axis
//             let option_gene = select_x_axis.options[ 1 ];
//             if( x_axis_option_current == '__UMAP__' ) {
//                 object_data.main.scatter.x_label = 'UMAP-1';
//                 object_data.main.scatter.x_axis_option = x_axis_option_current;
//                 object_data.main.scatter.x_axis_col_name = '__UMAP__';
//                 // reset select option
//                 option_gene.value = 'Gene';
//                 option_gene.innerHTML = 'Gene';
//                 object_data.main.scatter.flag_axis_using_gene_expr = false;
//             } else if ( object_data.main.scatter.flag_waiting_selection_of_gene ) {
//                 // update setting for scatter plot
//                 let gene_symbol = object_data.main.scatter.gene_symbol_selected;
//                 object_data.main.scatter.flag_waiting_selection_of_gene = false; // reset flag
//                 object_data.main.scatter.x_label = gene_symbol;
//                 object_data.main.scatter.x_axis_option = gene_symbol;
//                 object_data.main.scatter.x_axis_col_name = '__x_axis_gene_expr__';
//                 object_data.main.scatter.flag_axis_using_gene_expr = true;
//                 // update select option
//                 option_gene.value = gene_symbol;
//                 option_gene.innerHTML = gene_symbol;
//             } else {
//                 object_data.main.scatter.flag_waiting_selection_of_gene = true;
//                 // lock selection button to allow the selection of axis by clicking gene_symbol
//                 select_x_axis.disabled = true;
//                 select_y_axis.disabled = true;
//                 console.log( '[Change_UMAP_Coordinate] (X-axis) waiting a gene_symbol to be selected' );
//                 return 1;
//             }
//         } else {
//             let option_gene = select_y_axis.options[ 1 ];
//             if( y_axis_option_current == '__UMAP__' ) {
//                 object_data.main.scatter.y_label = 'UMAP-2';
//                 object_data.main.scatter.y_axis_option = y_axis_option_current;
//                 object_data.main.scatter.y_axis_col_name = '__UMAP__';
//                 // reset select option
//                 option_gene.value = 'Gene';
//                 option_gene.innerHTML = 'Gene';
//                 object_data.main.scatter.flag_axis_using_gene_expr = false;
//             } else if ( object_data.main.scatter.flag_waiting_selection_of_gene ) {
//                 // update setting for scatter plot
//                 let gene_symbol = object_data.main.scatter.gene_symbol_selected;
//                 object_data.main.scatter.flag_waiting_selection_of_gene = false; // reset flag
//                 object_data.main.scatter.y_label = gene_symbol;
//                 object_data.main.scatter.y_axis_option = gene_symbol;
//                 object_data.main.scatter.y_axis_col_name = '__y_axis_gene_expr__';
//                 object_data.main.scatter.flag_axis_using_gene_expr = true;
//                 // update select option
//                 option_gene.value = gene_symbol;
//                 option_gene.innerHTML = gene_symbol;
//             } else {
//                 object_data.main.scatter.flag_waiting_selection_of_gene = true;
//                 // lock selection button to allow the selection of axis by clicking gene_symbol
//                 select_x_axis.disabled = true;
//                 select_y_axis.disabled = true;
//                 console.log( '[Change_UMAP_Coordinate] (Y-axis) waiting a gene_symbol to be selected' );
//                 return 1;
//             }
//         }
//     } else { 
//         // change UMAP coordinates to the UMAP coordinates of the given tissue
//         if ( str_tissue == object_data.main.umap.tissue ) {
//             console.log( "[Change_UMAP_Coordinate] UMAP coordinates of", str_tissue, "already drawn, exiting" );
//             return -1;
//         }
//         object_data.main.umap.tissue = str_tissue; // update str_tissue of the main UMAP graph
//         object_data.main.umap.flag_all_tissues = str_tissue == 'All'; // flag indicating whether UMAP coordinates of all tissues are used.
//         let dictarr = object_data.file.dict_name_file_to_parsed_data[ "cells.all.tsv.gz.base64.txt" ];
//         if ( object_data.main.umap.flag_all_tissues ) {
//             object_data.main.umap.dictarr = dictarr;
//         } else {
//             // build a boolean index for retrieving UMAP coordinates (and other data) for the current tissue
//             let l_tissue = dictarr[ "tissue" ],
//                 l_bool_index = [ ],
//                 i = 0;
//             for ( i = 0; i < l_tissue.length; i ++ ) {
//                 l_bool_index.push( l_tissue[ i ] == str_tissue );
//             }
//             object_data.main.umap.l_bool_index_tissue = l_bool_index;
//             object_data.main.umap.dictarr = DictArrBooleanIndexing( dictarr, l_bool_index );
//         }
//     }
//     // Update coordinates of scatter plots
//     // draw cell annotation plot
//     PlotCellAnnotation( );
//     // draw expression plot
//     UpdateGene( );
// }
// // preprocessing functions for updating caches
// function preprocess_expr( data ) {
//     let str_key = Object.keys( data )[ 0 ];
//     return ArrayMultiply( data[ str_key ], Math.pow( 0.1, object_data.setting.expression.n_digits_below_floating_point ) );
// }
// var plotPreviewGene = document.getElementById( "plotly_searchbox_main_preview" ),
//     plotSingleCellAnnotation = document.getElementById( "plotly_sclncrna_expression_umap_annotation" ),
//     plotSingleCellExpression = document.getElementById( "plotly_sclncrna_expression_umap_expression" ),
//     plotSingleCellExpressionViolin = document.getElementById( "plotly_sclncrna_expression_violine" );
// object_data.setting.plot.single_cell_scatter = { 
//     max_height: 750,
//     marker_size: 3,
//     int_factor_axis_range_to_marker_size : 30, 
//     int_factor_marker_size_multiply : 3
// }; // defsult single-cell scatter plot setting
// object_data.setting.plot.single_cell_violin = { };
// var config_plotly = { responsive: true, displaylogo: false, toImageButtonOptions: { hoverClosestCartesian: true, format: 'png', filename: name_application, height: 750, width: 1100, scale: 1 }, modeBarButtonsToRemove: [ 'autoScale2d', 'toggleSpikelines', 'hoverCompareCartesian', 'hoverClosestCartesian' ] } // flexible plot width according to the window size  // do not display plotly logo
// function SortViolinTrace_Expression( trace_a, trace_b ) { return - ( trace_a.mean_expression_for_sorting - trace_b.mean_expression_for_sorting ) } // Sort Plotly Violin traces displaying expression values based on parameter values
// // assign color to violine plot traces
// function String_Check_Substring( string, l_substring ) {
//     let flag_contains_substring = false;
//     string = string.toLowerCase( );
//     for ( let i = 0; i < l_substring.length; i ++ ) {
//         let substring = l_substring[ i ].toLowerCase( );
//         if ( string.includes( substring ) ) {
//             flag_contains_substring = true;
//             break;
//         }
//     }
//     return flag_contains_substring;
// }
// function PlotExpression_scRNA_Seq_Get_Color_for_name_clus( str_name_clus ) { // return color for the given str_name_clus
//     str_name_clus = str_name_clus.toLowerCase( ); // convert name_clus to lower cases
//     let color = "#48D1CC"
//     if ( String_Check_Substring( str_name_clus, [ 'platelet' ] ) ) {
//         color = "#aec2c1";
//     } else if ( String_Check_Substring( str_name_clus, [ 'mast cell' ] ) ) {
//         color = "#ceb3fc";
//     } else if ( String_Check_Substring( str_name_clus, [ 'uninfected' ] ) ) {
//         color = "#9ef274";
//     } else if ( String_Check_Substring( str_name_clus, [ 'infected' ] ) ) {
//         color = "#ff6b6b";
//     } else if ( String_Check_Substring( str_name_clus, [ 'rbc' ] ) ) {
//         color = "#fc4970";
//     } else if ( String_Check_Substring( str_name_clus, [ 'endo', 'lymphatic', 'endotheli', 'capillary', 'luminal' ] ) ) {
//         color = "#faf75f";
//     } else if ( String_Check_Substring( str_name_clus, [ 'dendritic', 'pdc', 'cdc', 'dc_', ' dcs' ] ) ) {
//         color = "#64b9fa";
//     } else if ( String_Check_Substring( str_name_clus, [ 'stromal', 'fibroblasts', 'fibs', 'mesenchyme', 'cartilage' ] ) ) {
//         color = "#fa5f5f";
//     } else if ( String_Check_Substring( str_name_clus, [ 'goblet', 'ciliated', 'secretory', 'ionocyte', 'club' ] ) ) {
//         color = "#fce6b6";
//     } else if ( String_Check_Substring( str_name_clus, [ 'alveolar', 'basal', 'squamous', 'epithelia' ] ) ) {
//         color = "#ffbad9";
//     } else if ( String_Check_Substring( str_name_clus, [ 'tcell', 't cell', 't_cell', 't_', 'gd t', 'cd8', 'cd4', 'treg' ] ) ) {
//         color = "#b89eff";
//     } else if ( String_Check_Substring( str_name_clus, [ 'mono', 'lymphoid', 'hematopo', 'leukocyt', 'immuno', 'monocyte', 'neutrop', 'macro', 'b_cell', 'b cell', 'plasma cell', 'nk', 'eosinophil', 'naive' ] ) ) {
//         color = "#e79eff";
//     } else if ( String_Check_Substring( str_name_clus, [ 'myo' ] ) ) {
//         color = "#e8a78b";
//     }
//     return color;
// }
// async function UpdateGene( flag_restyle = false ) { // draw a new plot by default
//     console.log( "[UpdateGene] updating gene started" );
//     let str_tissue = object_data.main.umap.tissue, // retrieve current tissue
//         gene_symbol = object_data.main.gene.gene_symbol;

//     // update plot (Single Cell Expression)
//     // update cache of expression data
//     let object_cache = object_data.main.gene.expr;
//     await UpdateCache( object_cache, preprocess_expr, [ gene_symbol ] ); // retrieve the single cells expression data of the current gene.

//     plotSingleCellExpression.style.height = Math.min( plotSingleCellExpression.offsetWidth, object_data.setting.plot.single_cell_scatter.max_height ) + 'px'; // responsive height ( width = height )

//     let dictarr = object_data.main.umap.dictarr,
//         l_expr = object_data.main.gene.expr.data[ gene_symbol ].data,
//         col_name_cell_type = 'cell_type';
//     if ( ! object_data.main.umap.flag_all_tissues ) {
//         l_expr = ArrayBooleanIndexing( l_expr, object_data.main.umap.l_bool_index_tissue );
//         col_name_cell_type = 'tissue_cell_type';
//     }
//     // update x-axis values from gene expression data
//     if ( object_data.main.scatter.x_axis_col_name == '__x_axis_gene_expr__' ) {
//         let gene_symbol_x_axis = object_data.main.scatter.x_axis_option,
//             l_expr_x_axis = [ ];
//         await UpdateCache( object_cache, preprocess_expr, [ gene_symbol_x_axis ] ); // retrieve the single cells expression data of the current gene.
//         l_expr_x_axis = object_data.main.gene.expr.data[ gene_symbol_x_axis ].data;
//         if ( ! object_data.main.umap.flag_all_tissues ) {
//             l_expr_x_axis = ArrayBooleanIndexing( l_expr_x_axis, object_data.main.umap.l_bool_index_tissue );
//         }
//         dictarr[ '__x_axis_gene_expr__' ] = l_expr_x_axis;
//     } else {
//         object_data.main.scatter.x_axis_col_name = ( object_data.main.umap.flag_all_tissues ) ? 'UMAP_1' : 'tissue_UMAP_1';
//     }
//     if ( object_data.main.scatter.y_axis_col_name == '__y_axis_gene_expr__' ) {
//         let gene_symbol_y_axis = object_data.main.scatter.y_axis_option,
//             l_expr_y_axis = [ ];
//         await UpdateCache( object_cache, preprocess_expr, [ gene_symbol_y_axis ] ); // retrieve the single cells expression data of the current gene.
//         l_expr_y_axis = object_data.main.gene.expr.data[ gene_symbol_y_axis ].data;
//         if ( ! object_data.main.umap.flag_all_tissues ) {
//             l_expr_y_axis = ArrayBooleanIndexing( l_expr_y_axis, object_data.main.umap.l_bool_index_tissue );
//         }
//         dictarr[ '__y_axis_gene_expr__' ] = l_expr_y_axis;
//     } else {
//         object_data.main.scatter.y_axis_col_name = ( object_data.main.umap.flag_all_tissues ) ? 'UMAP_2' : 'tissue_UMAP_2';
//     }
//     // complete the selection process by re-enabling the selection button
//     $id( 'select_scatter_x_axis' ).disabled = false; 
//     $id( 'select_scatter_y_axis' ).disabled = false; 
//     object_data.setting.plot.single_cell_scatter.int_factor_axis_range_to_marker_size = object_data.main.scatter.flag_axis_using_gene_expr ? 7 : 30;
//     object_data.setting.plot.single_cell_scatter.marker_size = ResponsiveMarkerSize( plotSingleCellAnnotation, object_data.setting.plot.single_cell_scatter.int_factor_axis_range_to_marker_size, object_data.setting.plot.single_cell_scatter.int_factor_marker_size_multiply );
//     console.log( object_data.setting.plot.single_cell_scatter.marker_size );
//     if ( flag_restyle ) { // restyle existing plot
//         console.log( "[UpdateGene] restyling existing plot for", gene_symbol );
//         let update = { 
//             hovertemplate: ["Expression of <b>" + gene_symbol + "</b>: <b>%{marker.color:.3f}</b>",
//                             "tissue: <b>%{customdata[1]}</b>",
//                             "cluster: <b>%{customdata[0]}</b>",
//                             "",
//                             object_data.main.scatter.x_label + ": <b>%{x:.2f}</b>",
//                             object_data.main.scatter.y_label + ": <b>%{y:.2f}</b>",
//                             "%{customdata[2]}",
//                             "<extra></extra>" ].join( "<br>" ),
//             marker: { 
//                 color: l_expr,
//                 showscale: true,
//                 colorscale: "YlOrRd",
//                 reversescale: true,
//                 size: object_data.setting.plot.single_cell_scatter.marker_size
//             } };
//         Plotly.restyle( plotSingleCellExpression, update, [ 0 ] );
//     } 
//     else { // draw a new plot
//         let trace = {
//             mode: 'markers',
//             type: 'scattergl',
//             x: dictarr[ object_data.main.scatter.x_axis_col_name ],
//             y: dictarr[ object_data.main.scatter.y_axis_col_name ],
//             customdata: ArrayTranspose( [ dictarr[ col_name_cell_type ],
//                                           dictarr[ "tissue" ],
//                                           dictarr[ 'id_cell' ]
//                                         ] ),
//             hovertemplate: ["Expression of <b>" + gene_symbol + "</b>: <b>%{marker.color:.3f}</b>",
//                             "tissue: <b>%{customdata[1]}</b>",
//                             "cell type: <b>%{customdata[0]}</b>",
//                             "",
//                             object_data.main.scatter.x_label + ": <b>%{x:.2f}</b>",
//                             object_data.main.scatter.y_label + ": <b>%{y:.2f}</b>",
//                             "%{customdata[2]}",
//                             "<extra></extra>" ].join( "<br>" ),
//             marker: { 
//                 color: l_expr,
//                 showscale: true,
//                 colorscale: "YlOrRd",
//                 reversescale: true,
//                 size: object_data.setting.plot.single_cell_scatter.marker_size
//             },
//             line: { 
//                 width: 0
//             },
//         };
//         Plotly.newPlot( plotSingleCellExpression, [ trace ], { margin: { l: 65, r: 65, b: 90, t: 50, pad: 4 }, xaxis: { title : object_data.main.scatter.x_label, zeroline: false }, yaxis: { title : object_data.main.scatter.y_label, zeroline: false }, hovermode: "closest" }, { ... config_plotly, filename: name_application + '__Expression_of_' + gene_symbol, height: 1100, width: 1100 } ); // draw scatter plot of the annotation
//         plotSingleCellExpression.on( "plotly_relayout" , function( ed ) {
//             PlotlySynchronizedLayout( ed, l_div_plotly );
//         });
//         plotSingleCellExpression.on( 'plotly_click', async function( data ) {
//             PlotlyCallBackSingleCellMarker( data.points[ 0 ] );
//         });
//     }
//     // Update correlated genes 

//     object_cache = object_data.main.gene.correl;
//     await UpdateCache( object_cache, null, [ gene_symbol ] ); // update cache of correlated gene data
//     Display_DataTable( 'container_datatable_correl', 'datatable_correl', object_cache.data[ gene_symbol ].data, [ "gene_symbol", "correlation_coefficient", "probability" ] );
//     // change panel name
//     document.getElementById( "panel_name_correl_gene").innerHTML = "Co-Expressed Genes of " + gene_symbol;
//     // change datatable name 
//     object_data.main.datatable[ 'datatable_correl' ].name = `correl_gene.${gene_symbol}`;
//     // show datatable panel
//     $( "#container_panel_datatable_correl" ).collapse( 'show' )

//     // Update interaction graph
// //         LoadRemoteTextFile( "http://www.rna-society.org/rnainter/php_mysql/api.php?keyword=Actb&species=Mus musculus" )

//     // Violin plots
//     object_data.setting.plot.single_cell_violin.ignore_cells_with_zero_counts = ! document.getElementById( "checkbox__plotly_sclncrna_expression_violine__ignore_cells_with_zero_counts" ).checked; // retrieve current setting
//     // build list of traces for each category
//     dictarr = Pivot( object_data.main.umap.dictarr[ col_name_cell_type ], l_expr ); // key = cluster, value = list of expression values.
//     let trace_template = { 
//         type: 'violin',
//         opacity: 0.6,
//         box: { visible: true, width: 0.075 },
//         meanline: { visible: true }
//     },
//         l_category = Object.keys( dictarr ),
//         str_separation = ( plotSingleCellExpressionViolin.offsetWidth > 3000 ) ? '<br>' : ' ' ; // set 'str_separation' based on current width to increase responsiveness of the plot
//     let l_trace = [ ];
//     for ( let category in dictarr ) {
//         let l_expr = dictarr[ category ],
//             n_cells = l_expr.length, // retrieve number of cells for the current category
//             float_mean_expression = ArrayAverage( l_expr ), // retrieve a mean expression of cells for the current trace
//             object_RemoveNegativeCells = RemoveNegativeCells( l_expr ), // retrieve list of expression values excluding cells with zero counts
//             n_cells_with_zero_count = object_RemoveNegativeCells.n_cells_nagative,
//             l_expr_without_negative_cells = object_RemoveNegativeCells.l_expr_without_negative_cells;

//         let trace = { ... trace_template,
//                      x0: "", 
//                      y: [ ],
//                      name: category,
//                      line: { color: 'black', width: 2 },
//                      fillcolor: object_data.setting.plot.annotation.dict_tissue_to_dict_cell_type_to_color[ str_tissue ][ category ],
//                      points: false, // do not show outliers to increase responsivity
//                      y_ignore_cells_with_zero_counts__true: l_expr_without_negative_cells,
//                      y_ignore_cells_with_zero_counts__false: ArrayFull( n_cells_with_zero_count, 0 ).concat( l_expr_without_negative_cells ),
//                      x0_ignore_cells_with_zero_counts__true: category + str_separation + "(n=" + ( n_cells - n_cells_with_zero_count ) + ' of ' + n_cells + ')',
//                      x0_ignore_cells_with_zero_counts__false: category + str_separation + "(n=" + n_cells + ')',
//                      mean_expression_for_sorting: float_mean_expression
//                     };
//         l_trace.push( trace );
//     }
//     l_trace = l_trace.sort( SortViolinTrace_Expression ); // sort by mean expression
//     let layout = {
//         margin: { l: 50, r: 65, b: 150, t: 50, pad: 4 },
//         yaxis: { title : "Normalized Expression", rangemode: "nonnegative" },
//         legend: { tracegroupgap: 0 },
//         violingap: 0, // split violin plot for two covid statuses
//         violingroupgap: 0,
//         violinmode: "overlay",
//     }
//     for ( let i = 0; i < l_trace.length; i ++ ) { // swap y and x0 values based on the 'object_plot_scrnaseq.option.ignore_cells_with_zero_counts' setting
//         l_trace[ i ].x0 = object_data.setting.plot.single_cell_violin.ignore_cells_with_zero_counts ? l_trace[ i ].x0_ignore_cells_with_zero_counts__true : l_trace[ i ].x0_ignore_cells_with_zero_counts__false ;
//         l_trace[ i ].y = object_data.setting.plot.single_cell_violin.ignore_cells_with_zero_counts ? l_trace[ i ].y_ignore_cells_with_zero_counts__true : l_trace[ i ].y_ignore_cells_with_zero_counts__false ;
//     }
//     Plotly.newPlot( plotSingleCellExpressionViolin, l_trace, layout, { ... config_plotly, filename: name_application + '__Expression_of_' + gene_symbol, height: 600, width: 1100 } );
// }
// object_data.setting.plot.annotation = { };
// object_data.setting.plot.annotation.dict_tissue_to_dict_cell_type_to_color = {
//     'All': {'kidney_PT': '#9ACD32', 'kidney_nephrone': '#9932CC', 'lung_AT1': '#FF0000', 'lung_AT2': '#27408B', 'liver_hepatocyte': '#CD5555', 'heart_Fibroblast': '#EEB422', 'lung_Fibroblast': '#CD2626', 'Endothelial': '#90EE90', 'liver_Endo': '#EE4000', 'SMC': '#000080', 'Pericyte': '#8B1C62', 'Plasma': '#00BFFF', 'Intestine_SC': '#8B8B83', 'Intestine TA': '#4EEE94', 'DN': '#EE5C42', 'DP': '#EE00EE', 'DP2': '#7A67EE', 'B cell': '#CDB79E', 'B cell2': '#CDAD00', 'B cell3': '#1874CD', 'T cell': '#CD853F', 'NK': '#4A708B', 'liver_Kuffer': '#8B5742', 'lung_AM': '#CD5555', 'Macrophage': '#5D478B', 'Macrophage2': '#EE9572', 'Myeloid': '#9ACD32', 'Myeloid2': '#009ACD', 'Platlet': '#8B668B', 'RBC': '#CD6839', 'RBC2': '#8B7B8B'},'Kidney': {'PTS1': '#9ACD32', 'PTS1-S2': '#9932CC', 'PTS2': '#FF0000', 'PTS3': '#1874CD', 'ALOH': '#CD5555', 'DCT': '#EEB422', 'CNT': '#00C5CD', 'CD PC': '#90EE90', 'CD IC': '#FF1493', 'Mesangium': '#000080', 'Podocyte': '#8B1C62', 'ENDO': '#00BFFF', 'ENDO2': '#B22222', 'Proliferation': '#4EEE94', 'B cell': '#EE5C42', 'NK': '#EE00EE', 'Macro': '#EE4000', 'Monocyte': '#CDB79E', 'RBC': '#CDAD00'},'Heart': {'Cardiomyocyte': '#EE6AA7', 'Fibro1': '#9932CC', 'Fibro2': '#FF0000', 'Endo': '#CD5555', 'Endo2': '#EEB422', 'Vascular Endothelia': '#00C5CD', 'Pericyte': '#90EE90', 'SMC_pericyte': '#FF1493', 'SMC': '#000080', 'Myofirboblast': '#8B1C62', 'B cell': '#00BFFF', 'NK cell': '#CD96CD', 'Resident Macro': '#4EEE94', 'Resident Macro2': '#EE5C42', 'DC': '#EE00EE', 'Granulocyte': '#EE4000', 'Platelet': '#CDB79E', 'novel': '#1874CD', 'RBC': '#27408B', 'high mt': '#008B45'},'Lung': {'AT1': '#9ACD32', 'AT2': '#9932CC', 'AC': '#FF0000', 'Ciliated': '#1874CD', 'AM': '#CD5555', 'Pericyte': '#EEB422', 'ENDO': '#00C5CD', 'ENDO2': '#90EE90', 'ENDO3': '#FF1493', 'ENDO4': '#000080', 'Mesothelial': '#8B1C62', 'Fibroblast': '#00BFFF', 'Myofibroblast': '#B22222', 'SMC': '#4EEE94', 'SMC2': '#EE5C42', 'Proliferation': '#EE00EE', 'B cell': '#EE4000', 'B cell2': '#CDB79E', 'Naive T cell': '#CDAD00', 'T cell': '#CDC9A5', 'NK cell': '#8B8B83', 'Basophils': '#27408B', 'DC': '#8B5742', 'Neutrophils': '#CD5555', 'Macrophage': '#5D478B', 'Monocyte': '#CD6839', 'Monocyte2': '#9ACD32', 'Immune stromal cell': '#00008B', 'RBC': '#8B668B'},'Thymus': {'DN': '#9ACD32', 'ISP': '#9932CC', 'DP(P)': '#FF0000', 'DP2(P)': '#27408B', 'DP': '#EEB423', 'gd T': '#EEB422', 'ab T': '#CD1076', 'CD8 aa': '#90EE90', 'Cd4 SP': '#EE4000', 'Cd4 SP2': '#000080', 'Cd8 SP': '#8B1C62', 'Cd4 SP(M)': '#00BFFF', 'NK': '#8B8B83', 'DC': '#27408B'},'Liver': {'Hepatocyte': '#9ACD32', 'Hepatocyte2': '#9932CC', 'Cholangiocyte': '#FF0000', 'Stellate cell': '#1874CD', 'Cycling': '#CD5555', 'Kupffer': '#EEB422', 'Kupffer2': '#90EE90', 'ENDO': '#00C5CD', 'ENDO2': '#FF1493', 'B cell': '#000080', 'T cell': '#8B1C62', 'T cell2': '#00BFFF', 'T cell3': '#8B8B83', 'NK cell': '#4EEE94', 'NK cell2': '#EE5C42', 'Macro': '#EE00EE', 'Macro2': '#EE4000', 'Activated Macro': '#CDB79E', 'Granulocyte': '#CDAD00', 'Myeloid': '#FF0000', 'RBC': '#8B8B83'},'Intestine': {'Entero': '#5D478B', 'SC': '#90EE90', 'TA': '#000080', 'Tuft': '#8B8B83', 'PSC': '#EEB422', 'PSC2': '#EE00EE', 'Pericyte': '#8B1C62', 'Pericyte2': '#8B8B83', 'Epithelial': '#CD5555', 'Endo': '#9ACD32', 'Endo2': '#00C5CD', 'Endo3': '#00BFFF', 'BV': '#27408B', 'B cell': '#FF0000', 'B cell2': '#8B5742', 'T cell': '#CD5555', 'T cell2': '#EE4000', 'NK cell': '#CDAD00', 'plasma cell': '#9932CC', 'plasma cell2': '#27408B', 'plasma cell3': '#CDB79E', 'Macro': '#EE4000', 'Mast cell': '#4EEE94', 'Basophile': '#1874CD', 'DC': '#EE5C42'}}; // define color for each cell type
// object_data.setting.plot.annotation.dict_tissue_to_color = {
//     "Heart" : '#F8766D', 
//     "Intestine" : '#B79F00', 
//     "Kidney" : "#00BA38", 
//     "Lung" : "#619CFF", 
//     "Liver" : "#00BFC4", 
//     "Thymus" : "#F564E3", 
// }; // define color for each tissue
// async function PlotCellAnnotation( flag_restyle = false ) { // draw a new plot by default
//     let str_tissue = object_data.main.umap.tissue, // retrieve current tissue
//         option_selected = Select_Get_Selected_Option_Using_ID( "select_umap_annotation_data" ),
//         str_name_data_annotation = option_selected.value, // retrieve name of data for annotations
//         str_name_option_selected = option_selected.innerHTML; // retrieve the name of the selected option

//     plotSingleCellAnnotation.style.height = Math.min( plotSingleCellAnnotation.offsetWidth, object_data.setting.plot.single_cell_scatter.max_height ) + 'px'; // responsive height ( width = height )
//     // demonstration
//     let object_cache = object_data.main.gene.expr;
//     let dictarr = object_data.main.umap.dictarr, 
//         col_name_cell_type = ( object_data.main.umap.flag_all_tissues ) ? 'cell_type' : 'tissue_cell_type',
//         l_color = [ ], marker_colormap = { }, str_hovertemplate_additional_line = '';
//     // set color 
//     switch( str_name_data_annotation ) {
//       case 'tissue':
//         l_color = ArrayMap( dictarr[ str_name_data_annotation ], object_data.setting.plot.annotation.dict_tissue_to_color );
//         break;
//       case 'cell type':
//         l_color = ArrayMap( dictarr[ col_name_cell_type ], object_data.setting.plot.annotation.dict_tissue_to_dict_cell_type_to_color[ str_tissue ] );
//         break;
//       default:
//         l_color = dictarr[ str_name_data_annotation ];
//         marker_colormap = { showscale: true, colorscale: "YlOrRd", reversescale: true }; // setting for showing colormap
//         str_hovertemplate_additional_line = "<b>" + str_name_option_selected + "</b>: <b>%{marker.color:." + ( ( str_name_option_selected == 'MT Percentage' ) ? 1 : 0 ).toString( ) + "f}</b><br>"; // only MT percentage data will be shown as floating point numbers
//         break;
//     }
//     // update x-axis values from gene expression data
//     if ( object_data.main.scatter.x_axis_col_name == '__x_axis_gene_expr__' ) {
//         let gene_symbol_x_axis = object_data.main.scatter.x_axis_option,
//             l_expr_x_axis = [ ];
//         await UpdateCache( object_cache, preprocess_expr, [ gene_symbol_x_axis ] ); // retrieve the single cells expression data of the current gene.
//         l_expr_x_axis = object_data.main.gene.expr.data[ gene_symbol_x_axis ].data;
//         if ( ! object_data.main.umap.flag_all_tissues ) {
//             l_expr_x_axis = ArrayBooleanIndexing( l_expr_x_axis, object_data.main.umap.l_bool_index_tissue );
//         }
//         dictarr[ '__x_axis_gene_expr__' ] = l_expr_x_axis;
//     } else {
//         object_data.main.scatter.x_axis_col_name = ( object_data.main.umap.flag_all_tissues ) ? 'UMAP_1' : 'tissue_UMAP_1';
//     }
//     if ( object_data.main.scatter.y_axis_col_name == '__y_axis_gene_expr__' ) {
//         let gene_symbol_y_axis = object_data.main.scatter.y_axis_option,
//             l_expr_y_axis = [ ];
//         await UpdateCache( object_cache, preprocess_expr, [ gene_symbol_y_axis ] ); // retrieve the single cells expression data of the current gene.
//         l_expr_y_axis = object_data.main.gene.expr.data[ gene_symbol_y_axis ].data;
//         if ( ! object_data.main.umap.flag_all_tissues ) {
//             l_expr_y_axis = ArrayBooleanIndexing( l_expr_y_axis, object_data.main.umap.l_bool_index_tissue );
//         }
//         dictarr[ '__y_axis_gene_expr__' ] = l_expr_y_axis;
//     }  else {
//         object_data.main.scatter.y_axis_col_name = ( object_data.main.umap.flag_all_tissues ) ? 'UMAP_2' : 'tissue_UMAP_2';
//     }
//     // complete the selection process by re-enabling the selection button
//     $id( 'select_scatter_x_axis' ).disabled = false; 
//     $id( 'select_scatter_y_axis' ).disabled = false; 
//     object_data.setting.plot.single_cell_scatter.int_factor_axis_range_to_marker_size = object_data.main.scatter.flag_axis_using_gene_expr ? 7 : 30;
//     object_data.setting.plot.single_cell_scatter.marker_size = ResponsiveMarkerSize( plotSingleCellAnnotation, object_data.setting.plot.single_cell_scatter.int_factor_axis_range_to_marker_size, object_data.setting.plot.single_cell_scatter.int_factor_marker_size_multiply );
//     if ( flag_restyle ) { // restyle existing plot
//         console.log( "[PlotCellAnnotation] restyling existing plot for", str_name_data_annotation );
//         let update = {
//             hovertemplate: [ str_hovertemplate_additional_line + "tissue: <b>%{customdata[1]}</b>",
//                             "cell type: <b>%{customdata[0]}</b>",
//                             "",
//                             object_data.main.scatter.x_label + ": <b>%{x:.2f}</b>",
//                             object_data.main.scatter.y_label + ": <b>%{y:.2f}</b>",
//                             "%{customdata[2]}",
//                             "<extra></extra>" ].join( "<br>" ),
//             marker: { 
//                 color: l_color,
//                 size: object_data.setting.plot.single_cell_scatter.marker_size
//             } };
//         update.marker = { ... update.marker, ... marker_colormap }; // update setting for showing colormap
//         Plotly.restyle( plotSingleCellAnnotation, update, [ 0 ] );
//     } 
//     else {
//         let trace = {
//             mode: 'markers',
//             type: 'scattergl',
//             x: dictarr[ object_data.main.scatter.x_axis_col_name ],
//             y: dictarr[ object_data.main.scatter.y_axis_col_name ],
//             customdata: ArrayTranspose( [ dictarr[ col_name_cell_type ],
//                                           dictarr[ "tissue" ],
//                                           dictarr[ 'id_cell' ]
//                                         ] ),
//             hovertemplate: [ str_hovertemplate_additional_line + "tissue: <b>%{customdata[1]}</b>",
//                             "cell type: <b>%{customdata[0]}</b>",
//                             "",
//                             object_data.main.scatter.x_label + ": <b>%{x:.2f}</b>",
//                             object_data.main.scatter.y_label + ": <b>%{y:.2f}</b>",
//                             "%{customdata[2]}",
//                             "<extra></extra>" ].join( "<br>" ),
//             marker: { 
//                 color: l_color,
//                 size: object_data.setting.plot.single_cell_scatter.marker_size            
//             },
//             line: { 
//                 width: 0
//             },
//         };
//         trace.marker = { ... trace.marker, ... marker_colormap }; // update setting for showing colormap
//         Plotly.newPlot( plotSingleCellAnnotation, [ trace ], { margin: { l: 65, r: 65, b: 90, t: 50, pad: 4 }, xaxis: { title : object_data.main.scatter.x_label, zeroline: false }, yaxis: { title : object_data.main.scatter.y_label, zeroline: false }, hovermode: "closest" }, { ... config_plotly, filename: name_application + '__Annotation', height: 1100, width: 1100 } ); // draw scatter plot of the annotation

//         // add interactions
//         plotSingleCellAnnotation.on( 'plotly_click', async function( data ) {
//             PlotlyCallBackSingleCellMarker( data.points[ 0 ] );
//         });
//         plotSingleCellAnnotation.on( "plotly_relayout" , function( ed ) {
//             PlotlySynchronizedLayout( ed, l_div_plotly );
//         });
//     }
// }
}
    
// when document is ready for interaction
$(document).ready( function( ) {
    $('[data-toggle="tooltip"]').tooltip( ); // enable tooltips
    $('[data-tooltip="tooltip"]').tooltip( );
    $('[data-tooltip-always-active="tooltip"]').tooltip( );
//     $( '#modal_introduction' ).modal( 'show' ); // show introduction modal
//     Toggle_Tooltips( ); // set tooltips status
//     object_plot_MolecularMimicryMap.hovermode = "closest"; // set initial status
    Initialize( );
});
    
var ram = 1,
    adata = 1;
async function Initialize( ) { // initialize the web application
    // add names of ramdata objects to the loadramdata panel
    let id_select_ramdata = 'select_ramdata_object';
    Select_RemoveOptions_Using_ID( id_select_ramdata );
    Select_AddOptions_Using_ID( id_select_ramdata, dict_ramdata_locations ); // add ramdata objects in the settings
    
    // set default options
    document.getElementById( 'input_int_fig_size_x' ).value = '1250';
    document.getElementById( 'input_int_fig_size_y' ).value = '1000';
    document.getElementById( 'input_int_marker_size' ).value = '3';
    document.getElementById( "input_str_name_panel" ).value = 'ELDB';
    document.getElementById( "input_str_name_figure" ).value = '';
    document.getElementById( "input_float_vmax" ).value = '5';
    Select_SelectOption_Using_ID( 'select_ramdata_object', 'http://172.27.30.99/web_applications/20220718_sce.js/20220910_EBI_Broad_HCA_TS_combined_ramdata_subset_160000_barcodes/' ); // select ELDB database
    
    /*
    Demonstration
    */
    // load ELDB
    await LoadRamData( name_ramdata = 'ram', name_adata_default = 'adata', name_col_filter_default_bc = 'filtered_barcodes', l_name_col_obs_default = [ 'metadata__EBI_SCE__cell_type', 'dataset_source' ], l_name_col_obsm_default = [ "X_umap_filter_normalized_log1p_highly_variable_12000_excluding_degs_between_ebi_hca_and_ts_100comp_scanpy_embedding" ], name_col_filter_default_ft = 'no filter (all entries)', input_str_gene_names_default = "PTPRC, ITGAM, CD3D, CD19, KRT5, PDGFRB, TNFRSF17, CTRB1, TEKT1, ISL1, CLDN11, SFTPA1, PHGR1, NPHS2, AQP2, CLCNKA, UPK1A, LHCGR, TPSB2, TH, MUC16, MPZ, FEV, ORM1, INS" );
    await RetrieveAnnData( name_ramdata = 'ram' );
    // select data to plot
    document.getElementById( "select_str_entry_ft" ).value = 'CLDN11';
    document.getElementById( "select_annotations_bc_for_plot" ).value = 'metadata__EBI_SCE__cell_type';
    await PlotAnnData( ); // plot graph
    
//     // testing anndata for ELDB (subsampled)
//     ram = new RamData(  "http://172.27.30.99/web_applications/20220718_sce.js/20220910_EBI_Broad_HCA_TS_combined_ramdata_subset_160000_barcodes/", 'normalized_log1p_scaled' )
//     await ram.initialize( )
//     await ram.bc.change_filter( 'filtered_barcodes' )
//     await ram.ft.change_filter( 'filter_normalized_log1p_highly_variable' )
//     ram.ft.create_view( )
//     await ram.ft.load_str( )

//     // test anndata and plotting functions
//     adata = await ram.get_item( [ 'normalized_log1p_scaled', [ ], [ [ "X_umap_filter_normalized_log1p_highly_variable_12000_excluding_degs_between_ebi_hca_and_ts_100comp_scanpy_embedding" ] ], [ 'CNN3', 'STAG3', 'CACNB4', 'XPO6', 'FGG', 'MAVS', 'CRIM1', 'RBFOX1', 'LYL1', 'HMGCLL1', 'NBPF19', 'LPAR1', 'ALPK3', 'TRIM59', 'MMP1', 'FCN3', 'PEX14', 'CSAD', 'SQLE', 'AKR1C3', 'ABCA1', 'ZNF264', 'FILIP1L', 'ADAM8', 'TBCK', 'MARCHF3' ], [ 'str' ] ] )
//     create_div( 'new_graph' )
    
//     draw_graph( 'new_graph', adata, { 'name_gene' : 'CNN3', 'name_col_embedding' : "X_umap_filter_normalized_log1p_highly_variable_12000_excluding_degs_between_ebi_hca_and_ts_100comp_scanpy_embedding" } )
}
    

async function LoadRamData( name_ramdata = 'ram', name_adata_default = 'adata', name_col_filter_default_bc = 'filtered_barcodes', l_name_col_obs_default = [ 'metadata__EBI_SCE__cell_type', 'dataset_source' ], l_name_col_obsm_default = [ "X_umap_filter_normalized_log1p_highly_variable_12000_excluding_degs_between_ebi_hca_and_ts_100comp_scanpy_embedding" ], name_col_filter_default_ft = 'no filter (all entries)', input_str_gene_names_default = "PTPRC, ITGAM, CD3D, CD19, KRT5, PDGFRB, TNFRSF17, CTRB1, TEKT1, ISL1, CLDN11, SFTPA1, PHGR1, NPHS2, AQP2, CLCNKA, UPK1A, LHCGR, TPSB2, TH, MUC16, MPZ, FEV, ORM1, INS" ) {
    // get the name of the selected ramdata object
    let id_select_ramdata = 'select_ramdata_object',
        path_folder_ramdata = Select_Get_Selected_Option_Using_ID( id_select_ramdata ).value,
        name_option_no_filter = dict_data.misc.name_option_no_filter;
    
    // set default adata name
    document.getElementById( "input_str_name_adata_output" ).value = name_adata_default;
    // set default string representations of the entries of the feature axis
    document.getElementById( "input_str_gene_names" ).value = input_str_gene_names_default;
    
    // load ramdata
    let ram = new RamData( path_folder_ramdata );
    dict_data[ 'dict_ramdata' ][ name_ramdata ] = ram; // add the reference
    await ram.initialize( ); // initialize the RamData
    
    // update axis labels
    document.getElementById( "div_repr_bc" ).innerHTML = `<h5>Barcode Axis <span class="badge text-bg-secondary">${ram.metadata[ 'int_num_barcodes' ]} entries</span></h5>`;
    document.getElementById( "div_repr_ft" ).innerHTML = `<h5>Feature Axis <span class="badge text-bg-secondary">${ram.metadata[ 'int_num_features' ]} entries</span></h5>`;
    
    // retrieve sorted lists of columns for bc and ft axes
    let l_name_col_bc = [ name_option_no_filter, ... ram.bc.meta.columns ], // default setting is no filter (all entries)
        l_name_col_ft = [ name_option_no_filter, ... ram.ft.meta.columns ], // default setting is no filter (all entries)
        l_name_layer = [ ... ram.layers ];
    l_name_col_bc = l_name_col_bc.sort( );
    l_name_col_ft = l_name_col_ft.sort( );
    l_name_layer = l_name_layer.sort( );
    
    // remove options
    Select_RemoveOptions_Using_ID( 'select_filter_bc' );
    Select_RemoveOptions_Using_ID( 'select_annotations_bc' );
    Select_RemoveOptions_Using_ID( 'select_embedding' );
    Select_RemoveOptions_Using_ID( 'select_filter_ft' );
    Select_RemoveOptions_Using_ID( 'select_layer' );
    
    // add appropriate options
    Select_AddOptions_Using_ID( 'select_filter_bc', l_name_col_bc ); 
    Select_AddOptions_Using_ID( 'select_annotations_bc', l_name_col_bc ); 
    Select_AddOptions_Using_ID( 'select_embedding', l_name_col_bc ); 
    Select_AddOptions_Using_ID( 'select_filter_ft', l_name_col_ft ); 
    Select_AddOptions_Using_ID( 'select_layer', l_name_layer ); 
    
    // select default filters
    Select_SelectOption_Using_ID( 'select_filter_bc', name_col_filter_default_bc );
    Select_SelectOption_Using_ID( 'select_filter_ft', name_col_filter_default_ft );
    Select_SelectOption_Using_ID( 'select_annotations_bc', l_name_col_obs_default );
    Select_SelectOption_Using_ID( 'select_embedding', l_name_col_obsm_default );
    
    // close current panel
    dict_data.bs_components.offcanvasLoadRamData.hide( );
    // show next panel
    dict_data.bs_components.offcanvasRetrieveAnnData.show( );
}
    
async function RetrieveAnnData( name_ramdata = 'ram' ) {
    /*
    Retrieve AnnData and set attributes for the next panel
    */
    // retrieve RamData
    let ram = dict_data[ 'dict_ramdata' ][ name_ramdata ],
        name_option_no_filter = dict_data.misc.name_option_no_filter;
    
    // retrieve list of input columns and values
    let name_col_filter_bc = Select_Get_Selected_Option_Using_ID( 'select_filter_bc' ).value,
        l_name_col_obs = Select_Get_Selected_Option_Using_ID( 'select_annotations_bc' ).map( ( opt ) => { return opt.value; } ).sort( ),
        l_name_col_obsm = Select_Get_Selected_Option_Using_ID( 'select_embedding' ).map( ( opt ) => { return opt.value; } ).sort( ),
        name_col_filter_ft = Select_Get_Selected_Option_Using_ID( 'select_filter_ft' ).value,
        name_layer = Select_Get_Selected_Option_Using_ID( 'select_layer' ).value,
        name_anndata = document.getElementById( 'input_str_name_adata_output' ).value,
        l_str_entry_feature = document.getElementById( 'input_str_gene_names' ).value.split( ',' ).map( ( e ) => { return e.trim( ); } ).filter( e => e.length > 0 ); // retrieve a list of string representations of the entries of the feature axis // filter out invalid entries (zero length)

    // load barcode filter
    if ( name_col_filter_bc == name_option_no_filter ) {
        await ram.bc.change_filter( name_col_filter_bc );
    }
    // load feature filter
    if ( name_col_filter_ft == name_option_no_filter ) {
        await ram.ft.change_filter( name_col_filter_ft )
    }
    // create view before retrieving data
    ram.ft.create_view( )
    
    // load string representations of the feature axis
    await ram.ft.load_str( )
    
    // test anndata and plotting functions
    let adata = await ram.get_item( [ name_layer, [ ], [ l_name_col_obsm, ... l_name_col_obs ], l_str_entry_feature, [ 'str' ] ] )
    dict_data[ 'dict_anndata' ][ name_anndata ] = adata; // add the reference
    
    let l_name_adata = Object.keys( dict_data[ 'dict_anndata' ] ).sort( ), // retrieve list of available name_adata
        l_str_entry_ft = adata.var.get_column( 'str' ).sort( ); // retrieve list of str_entry_ft
    
    // reset options
    Select_RemoveOptions_Using_ID( 'select_adata' );
    Select_RemoveOptions_Using_ID( 'select_str_entry_ft' );
    Select_RemoveOptions_Using_ID( 'select_annotations_bc_for_plot' );
    Select_RemoveOptions_Using_ID( 'select_embedding_for_plot' );
    
    // add appropriate options
    Select_AddOptions_Using_ID( 'select_adata', l_name_adata ); 
    Select_AddOptions_Using_ID( 'select_str_entry_ft', l_str_entry_ft ); 
    Select_AddOptions_Using_ID( 'select_annotations_bc_for_plot', l_name_col_obs ); 
    Select_AddOptions_Using_ID( 'select_embedding_for_plot', l_name_col_obsm ); 
    
    // close current panel
    dict_data.bs_components.offcanvasRetrieveAnnData.hide( );
    // show next panel
    dict_data.bs_components.offcanvasPlotAnnData.show( );
}
    
async function PlotAnnData( ) {
    // retrieve list of input columns and values
    let name_anndata = Select_Get_Selected_Option_Using_ID( 'select_adata' ).value,
        name_panel = document.getElementById( 'input_str_name_panel' ).value,
        name_fig = document.getElementById( 'input_str_name_figure' ).value,
        name_col_obsm = Select_Get_Selected_Option_Using_ID( 'select_embedding_for_plot' ).value,
        str_entry_ft = Select_Get_Value_from_Option( Select_Get_Selected_Option_Using_ID( 'select_str_entry_ft' ) ),
        name_col_obs = Select_Get_Value_from_Option( Select_Get_Selected_Option_Using_ID( 'select_annotations_bc_for_plot' ) ),
        flag_responsive_marker_size = document.getElementById( 'switch_responsive_marker_size_or_static' ).checked,
        int_marker_size = parseInt( document.getElementById( 'input_int_marker_size' ).value ),
        input_float_vmax = parseFloat( document.getElementById( 'input_float_vmax' ).value ),
        int_fig_size_x = document.getElementById( 'input_int_fig_size_x' ).value,
        int_fig_size_y = document.getElementById( 'input_int_fig_size_y' ).value,
        adata = dict_data[ 'dict_anndata' ][ name_anndata ], // add the reference
        dict_key_args_for_draw_graph = { 'name_gene' : str_entry_ft, 'name_col_obs' : name_col_obs, 'name_col_embedding' : name_col_obsm, 'title' : name_fig, 'flag_responsive_marker_size' : flag_responsive_marker_size, 'fig_size' : [ int_fig_size_x, int_fig_size_y ], 'vmax' : isNaN( input_float_vmax ) ? undefined : input_float_vmax, 'marker_size' : isNaN( int_marker_size ) ? 3 : int_marker_size }; // keyworded arguments for the draw_graph function
    
    // draw graph
    if ( document.getElementById( 'radio_select_type_graph_feature' ).checked ) { // plot feature values
        draw_graph( name_panel, adata, { ... dict_key_args_for_draw_graph, 'flag_recreate_div' : true, 'flag_plot_feature' : true } );
    } else if ( document.getElementById( 'radio_select_type_graph_obs' ).checked ) { // plot annotation values
        draw_graph( name_panel, adata, { ... dict_key_args_for_draw_graph, 'flag_recreate_div' : true, 'flag_plot_feature' : false } );
    } else if ( document.getElementById( 'radio_select_type_graph_feature_and_obs' ).checked ) { // plot both feature and annotations
        
        // create div with dual graphs
        create_div( name_panel, style = `width:${int_fig_size_x}px;height:${int_fig_size_y}px;`, flag_create_dual_div = true );
        // draw graphs
        draw_graph( `${name_panel}__top__`, adata, { ... dict_key_args_for_draw_graph, 'flag_recreate_div' : false, 'flag_plot_feature' : false } );
        draw_graph( `${name_panel}__bottom__`, adata, { ... dict_key_args_for_draw_graph, 'flag_recreate_div' : false, 'flag_plot_feature' : true } );
        
        // sync two plots
        let l_div_plotly = [ document.getElementById( `${name_panel}__top__` ), document.getElementById( `${name_panel}__bottom__` ) ];
        for ( let div of l_div_plotly ) { // for each division with plotly graphs
            div.on( "plotly_relayout" , function( ed ) { // add event listner for synchronizing layouts
                synchronized_layout( ed, l_div_plotly );
            });
        }
        
    } else if ( document.getElementById( 'radio_select_type_graph_violin' ).checked ) { // plot violin plots using both feature and annotations
        
    } else {
        return;
    }
    // close current panel
    dict_data.bs_components.offcanvasRetrieveAnnData.hide( );
}

</script>
</html>



















































