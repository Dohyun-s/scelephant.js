<!doctype html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8WBMQ5B3N0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8WBMQ5B3N0');
</script>
<!--  
# release note

# 2022/11/17
minor modification of plotting functions

# 2022/12/15
commit prior to major modification of interface 

# 
v0.0.2 update
scelephant.js v0.0.1 is incompatible with RamData analyzed with scelephant.py v0.0.10

# 20221226
improved initialization of tagify instances of the UI components

# 20230106
resolved an error in a method ploting a dot plot when None values were included.

# 20230515
added a word cloud plotting function for exploring metadata

# 20230516
remaining part of word cloud plotting function was implemented

# 20230712
RAMtx sparse matrix load gene expression data of each batch asynchronously
also utilizing asynchronous functions for loading data for RamData and ZarrDataFrame.
RamDataLayer initialization also utilizes asynchronous loading.

# 20231228
a critial error causing a significant performance reduction was fixed (RAMtx.__getitem__) for both scelephant.js and scelephant.py
-->
    
<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="SC-Elephant DB Server">
<title>SC-Elephant Viewer</title>
    
<!-- bootstrap5 -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">

<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js" integrity="sha256-qXBd/EfAdjOA2FGrGAG+b3YBn2tn5A6bhz+LSgYD96k=" crossorigin="anonymous"></script>
<script> lodash = _.noConflict(); // load script of lodash </script>     
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><!-- JQuery -->
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
<script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js" integrity="sha512-zInFF17qBFVvvvFpIfeBzo7Tj7+rQxLeTJDmbxjBz5/zIr89YVbTNelNhdTT+/DCrxoVzBeUPVFJsczKbB7sew==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- for colormaps -->
    
<script src="https://cdn.jsdelivr.net/npm/hotkeys-js@3.8.1/dist/hotkeys.min.js" integrity="sha256-4nmnbhmVpr2Rg64+7ysAr93+vQrfc0UvHWwm4W6uXJM=" crossorigin="anonymous"></script><!--hotkeys to add keyboard shortcuts-->
    
<!-- Tagify -->
<script src="https://cdn.jsdelivr.net/npm/@yaireo/tagify"></script>
<script src="https://cdn.jsdelivr.net/npm/@yaireo/tagify/dist/tagify.polyfills.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/@yaireo/tagify/dist/tagify.css" rel="stylesheet" type="text/css" />
    
<!-- 
<script type="module">
  import * as zarr from "https://cdn.skypack.dev/zarrita/v2";
  import { get } from "https://cdn.skypack.dev/zarrita/ops";
  import FetchStore from "https://cdn.skypack.dev/zarrita/storage/fetch";
  // must add codecs to global registry if compression is used
  import Blosc from "https://cdn.skypack.dev/numcodecs/blosc";
  zarr.registry.set( Blosc.codecId, () => Blosc );
  
  // add to top level
  window.zarr = zarr;
  window.get = get;
  window.Blosc = Blosc
  window.FetchStore = FetchStore
</script> -->
    
<!-- ES import -->
<script type="module">
    // import * as dataframeJs from 'https://cdn.skypack.dev/dataframe-js';
//     import * as papaparse from 'https://cdn.skypack.dev/papaparse';
//     window.Papa = papaparse;
    import * as pako from 'https://cdn.skypack.dev/pin/pako@v2.1.0-45rMaYN3B7tIGOhONLdV/mode=imports,min/optimized/pako.js';
    window.pako = pako;
    
    // import modules for plotting
//     import Plotly from 'https://cdn.skypack.dev/plotly.js'; // cannot be imported from skypack...
//     import * as chromaJs from 'https://cdn.skypack.dev/chroma-js';
//     import * as d3 from 'https://cdn.skypack.dev/d3';
    
//     // import modules for interactions
//     import datatablesNet from 'https://cdn.skypack.dev/datatables.net';
//     import yaireoTagify from 'https://cdn.skypack.dev/@yaireo/tagify';
//     import hotkeysJs from 'https://cdn.skypack.dev/hotkeys-js';
//     import html2canvas from 'https://cdn.skypack.dev/html2canvas';
//     import fileSaver from 'https://cdn.skypack.dev/file-saver';
//     import fontAwesome from 'https://cdn.skypack.dev/font-awesome';
    
//     // import Zarrita
//     import * as zarrita from "https://cdn.skypack.dev/zarrita/v2";
//     import { get } from "https://cdn.skypack.dev/zarrita/ndarray"; // "https://cdn.skypack.dev/zarrita/ops";
//     import FetchStore from "https://cdn.skypack.dev/zarrita/storage/fetch";
//     import Blosc from "https://cdn.skypack.dev/numcodecs/blosc";
//     zarrita.registry.set(Blosc.codecId, () => Blosc); // using compression
//     window.Blosc = Blosc
//     window.zarrita = zarrita;
//     window.zarrita_get = get;
//     window.zarrita_FetchStore = FetchStore;
    
    // import Zarr
    import * as zarr from "https://cdn.skypack.dev/pin/zarr@v0.6.0-qeD2x2OIoVXZ7XErLyTp/mode=imports,min/optimized/zarr.js";
    window.zarr = zarr;
    
    // import bitset for BitArray
    import bitset from 'https://cdn.skypack.dev/pin/bitset@v5.1.1-4j2vEKZuIS8eQEzMCWou/mode=imports,min/optimized/bitset.js';
    window.BitSet = bitset;
    
    // import d3
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
    window.d3 = d3;
    
    // import d3-cloud for [drawing word cloud]
    import d3Cloud from "https://cdn.skypack.dev/pin/d3-cloud@v1.2.5-j5Ds8gBHbaXQbwAFnZV9/mode=imports,min/optimized/d3-cloud.js";
    window.d3Cloud = d3Cloud;
    
    // import wordcloud2.js
    import WordCloud from "https://cdn.skypack.dev/pin/wordcloud@v1.2.2-MCYCA3j8DHnkGUPArmCC/mode=imports,min/optimized/wordcloud.js";
    window.WordCloud = WordCloud;
    
    // import zip.js
    import * as zip from "https://deno.land/x/zipjs@v2.7.32/index.js";
    window.zip = zip;
    
    // FileSaver
    import fileSaver from 'https://cdn.jsdelivr.net/npm/file-saver@2.0.5/+esm'
    window.fileSaver = fileSaver;
    
//     // for writing HDF5
//     import h5wasm from "https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/hdf5_hl.js";
//     const Module = await h5wasm.ready;
//     const { FS } = Module;
//     window.h5wasm = h5wasm;
//     window.FS = FS;
    
//     // import umap.js for embedding
//     import * as umapJs from 'https://cdn.skypack.dev/umap-js';
//     window.umapJs = umapJs;
    
//     // import hdbscan for clustering
//     import * as hdbscan from 'https://cdn.skypack.dev/hdbscan';
//     window.hdbscan = hdbscan;
    
//     // import pca for dimension reduction
//     import * as mlPca from 'https://cdn.skypack.dev/ml-pca';
//     window.mlPca = mlPca;
</script>

<style>
<style>
.image {
  max-width: 100%; !important; 
  width: 750px !important;
}
.image-small {
  max-width: 100%; !important; 
  width: 500px !important;
}
.image-very-small {
  max-width: 100%; !important; 
  width: 350px !important;
}
.rcorner {
  border-radius: 5px;
  padding: 5px;
}
    
.tags-look .tagify__dropdown__item{
  display: inline-block;
  vertical-align: middle;
  border-radius: 3px;
  padding: .3em .5em;
  border: 1px solid #CCC;
  background: #F3F3F3;
  margin: .2em;
  font-size: .85em;
  color: black;
  transition: 0s;
}

.tags-look .tagify__dropdown__item--active{
  color: black;
}

.tags-look .tagify__dropdown__item:hover{
  background: lightyellow;
  border-color: gold;
}

.tags-look .tagify__dropdown__item--hidden {
    max-width: 0;
    max-height: initial;
    padding: .3em 0;
    margin: .2em 0;
    white-space: nowrap;
    text-indent: -20px;
    border: 0;
}

</style>
<!-- icon of the document -->
<link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2020%2020'%3E%3Ctext%20x='0'%20y='16'%20style='filter:%20invert(100%);'%3E🐘%3C/text%3E%3C/svg%3E" type="image/svg+xml" />
</head>

<body>
<nav class="navbar navbar-expand-lg bg-light">
  <div class="container-fluid">
    <a class="navbar-brand" href="#">SC-Elephant RamData Viewer</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item">
          <a class="nav-link active" data-bs-toggle="offcanvas" data-bs-target="#offcanvasLoadRamData" aria-controls="offcanvasLoadRamData">1) Load RamData</a>
        </li>
        <li class="nav-item">
          <a class="nav-link active" data-bs-toggle="offcanvas" data-bs-target="#offcanvasRetrieveAnnData" aria-controls="offcanvasRetrieveAnnData">2) Retrieve AnnData</a>
        </li>
        <li class="nav-item">
          <a class="nav-link active" data-bs-toggle="offcanvas" data-bs-target="#offcanvasPlotAnnData" aria-controls="offcanvasPlotAnnData">3) Plot AnnData</a>
        </li>
<!--         <li class="nav-item">
          <a class="nav-link" href="#">Link</a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            Dropdown
          </a>
          <ul class="dropdown-menu">
            <li><a class="dropdown-item" href="#">Action</a></li>
            <li><a class="dropdown-item" href="#">Another action</a></li>
            <li><hr class="dropdown-divider"></li>
            <li><a class="dropdown-item" href="#">Something else here</a></li>
          </ul>
        </li>
        <li class="nav-item">
          <a class="nav-link disabled">Disabled</a>
        </li> -->
      </ul>
      <form class="d-flex">
        <div class="form-check form-switch" id="global_switch_simple_or_advanced">
            <input class="form-check-input" type="checkbox" id="switch_simple_or_advanced" onchange="SwitchAdvancedSetting( );">
            <label class="form-check-label" for="switch_simple_or_advanced">Advanced Mode</label>
        </div>
      </form>
    </div>
  </div>
</nav>
    
<div class="content" id="canvas">
</div>
<br>
<nav class="navbar navbar-light bg-light">
  <div class="container-fluid">
<!--     RamData, SC-Elephant, SC-Elephant.js, and ELDB were developed by Hyunsu An at the Gwangju Institute of Science and Technology under the supervision of Professor JiHwan Park.<br>© 2023 Functional Genomics Lab, Gwangju Institute of Science and Technology -->
    © 2023 Gwangju Institute of Science and Technology
  </div>
</nav>
    
<!-- offcanvases -->
<div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasLoadRamData" aria-labelledby="offcanvasLoadRamDataLabel" style="width: 75vw">
  <div class="offcanvas-header">
    <h4 class="offcanvas-title" id="offcanvasLoadRamDataLabel">Load RamData</h4>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="d-grid mx-3 gap-2">
    <button class="btn btn-primary" type="button" onclick="LoadRamData( )">Load RamData</button>
  </div>
  <div class="offcanvas-body">
    <div class="form-check">
      <input class="form-check-input" type="radio" name="input_ramdata" id="input_ramdata_from_select" checked>
        <div class="form-floating">
            <select class="form-select" aria-label="select_ramdata_object" id="select_ramdata_object">
            </select>
          <label for="select_ramdata_object" class="form-label">Select RamData Object</label>
        </div>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="radio" name="input_ramdata" id="input_ramdata_from_text">
        <div class="form-floating">
            <textarea class="form-control" placeholder="RamData object" id="input_path_remote_ramdata" style="height: 100px"></textarea>
            <label for="input_path_remote_ramdata">URL of an RamData object</label>
        </div>
    </div>      
  </div>
</div>
    
<!-- offcanvas -->
<div class="offcanvas offcanvas-bottom" tabindex="-1" id="offcanvasRetrieveAnnData" aria-labelledby="offcanvasRetrieveAnnDataLabel" style="height: 90vh">
  <div class="offcanvas-header">
    <h4 class="offcanvas-title" id="offcanvasRetrieveAnnDataLabel">Retrieve AnnData from RamData</h4>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="d-grid mx-3 gap-2">
    <button class="btn btn-primary" type="button" onclick="RetrieveAnnData( )" id="button_for_retrieving_anndata">Retrieve AnnData
    </button>
  </div>
  <div class="offcanvas-body">
    <div class="form-floating" id="panel_input_str_name_adata_output">
        <textarea class="form-control" placeholder="adata" id="input_str_name_adata_output"></textarea>
        <label for="input_str_name_adata_output">Output AnnData Name</label>
        <br>
    </div>
      
    <div id="div_repr_bc">
        <h5>Barcode Axis</h5>
    </div>
      
<!-- <input id="choose_filter_bc_input" value='css, html, javascript, css' data-blacklist='.NET,PHP'> -->
    <label for="select_filter_bc" class="form-label">Select Barcode Filter</label>
    <select class="form-select" aria-label="select_filter_bc" id="select_filter_bc">
    </select>
    <br>
      
    <label for="choose_annotations_bc" class="form-label">Select Barcode Annotations</label>
    <div class="d-grid mx-1 gap-1"><textarea id="choose_annotations_bc" class="rcorner" aria-label="choose_annotations_bc"></textarea></div>
    <br>
      
    <label for="choose_embedding" class="form-label">Select Embeddings</label>
    <div class="d-grid mx-1 gap-1"><textarea id="choose_embedding" class="rcorner" aria-label="choose_embedding"></textarea></div>
    <br>
      
    <div id="div_repr_ft">
      <h5>Feature Axis</h5>
    </div>
      
    <div id="panel_select_filter_ft">
        <label for="select_filter_ft" class="form-label">Select Feature Filter</label>
        <select class="form-select" aria-label="select_filter_ft" id="select_filter_ft">
        </select>
        <br>
    </div>      
    <label for="input_str_gene_names">Gene Symbols</label>
    <div class="d-grid mx-1 gap-1"><textarea id="input_str_gene_names" class="rcorner" aria-label="input_str_gene_names"></textarea></div>
    <br>
     
    <div id="panel_select_layer">
        <div>
          <h5>Layer</h5>
        </div>

        <label for="select_layer" class="form-label">Select Layer</label>
        <select class="form-select" aria-label="select_layer" id="select_layer">
        </select>
        <br>
    </div>
  </div>
</div>
    
<!-- offcanvas -->
<div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvasPlotAnnData" aria-labelledby="offcanvasPlotAnnDataLabel" style="width: 485px">
  <div class="offcanvas-header">
    <h4 class="offcanvas-title" id="offcanvasPlotAnnDataLabel">Plot AnnData</h4>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="d-grid mx-3 gap-2">
    <button class="btn btn-primary" type="button" onclick="PlotAnnData( )" id="button_plot_anndata">Plot AnnData</button>
  </div>
  <div class="offcanvas-body">
    <div class="form-floating" id="plotting_panel_select_adata">
        <select class="form-select" aria-label="select_adata" id="select_adata" onchange="UpdatePanelPlotAnnData( );">
        </select>
      <label for="select_adata" class="form-label">Select AnnData</label>
      <br>
    </div>
    
      
    <div class="btn-group d-flex justify-content-center" role="group" aria-label="Basic radio toggle button group" onclick="RearrangePlottingPanel( );" id="radio_select_type_graph">
      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_feature" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_feature">Feature</label>

      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_obs" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_obs">Annotation</label>

      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_feature_and_obs" autocomplete="off" checked>
      <label class="btn btn-outline-primary" for="radio_select_type_graph_feature_and_obs">Both</label>

      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_violin" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_violin">Violin</label>
        
      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_dot" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_dot">Dot</label>
        
      <input type="radio" class="btn-check" name="radio_select_type_graph" id="radio_select_type_graph_word_cloud" autocomplete="off">
      <label class="btn btn-outline-primary" for="radio_select_type_graph_word_cloud">Cloud</label>
    </div>

    <br>  
    <div id="name_graph_type"></div>
    <br>
      
    <div>
      <h5>Data</h5>
    </div>

    <div class="form-floating" id="plotting_panel_select_str_entry_ft">
        <select class="form-select" aria-label="select_str_entry_ft" id="select_str_entry_ft">
        </select>
      <label for="select_str_entry_ft" class="form-label">Select Feature Entry</label>
    </div>
      
    <div id="plotting_panel_input_l_str_entry_ft_for_plotting">
        <label for="input_l_str_entry_ft_for_plotting">Select Gene Symbols</label>
        <div class="d-grid mx-1 gap-1"><textarea id="input_l_str_entry_ft_for_plotting" class="rcorner" aria-label="input_l_str_entry_ft_for_plotting"></textarea></div>
    </div>
      
    <div class="form-floating" id="plotting_panel_select_annotations_bc_for_plot">
        <select class="form-select" aria-label="select_annotations_bc_for_plot" id="select_annotations_bc_for_plot" onchange="UpdateCategories( );">
        </select>
      <label for="select_annotations_bc_for_plot" class="form-label">Select Barcode Annotation</label>
    </div>
      
    <div id="plotting_panel_select_l_annotations_bc_for_plot">
        <label for="input_l_annotations_bc_for_plot">Select Barcode Annotations</label>
        <div class="d-grid mx-1 gap-1"><textarea id="input_l_annotations_bc_for_plot" class="rcorner" aria-label="input_l_annotations_bc_for_plot"></textarea></div>
    </div>
      
    <div id="plotting_panel_input_l_category_for_plotting">
        <br>
        <label for="input_l_category_for_plotting">Select Categories</label>
        <div class="d-grid mx-1 gap-1"><textarea id="input_l_category_for_plotting" class="rcorner" aria-label="input_l_category_for_plotting"></textarea></div>
    </div>
    
    <div id="plotting_panel_data_setting_advanced">
        <div class="form-floating" id="plotting_panel_input_float_vmax">
            <textarea class="form-control" placeholder="10" id="input_float_vmax"></textarea>
            <label for="input_float_vmax">maximum value cutoff</label>
        </div>
    </div>
    <br>
      
    <div id="plotting_panel_title_coordinates">
      <h5>Coordinates</h5>
    </div>
      
    <div class="form-floating" id="plotting_panel_select_embedding_for_plot">
        <select class="form-select" aria-label="select_embedding_for_plot" id="select_embedding_for_plot">
        </select>
      <label for="select_embedding_for_plot" class="form-label">Select Embedding</label>
    <br>
    </div>

    <div id="panel_figure_setting_advanced">
        <div>
          <h5>Figure</h5>
        </div>

        <div id="panel_figure_name_setting_for_scatter_graph">
            <div class="form-floating">
                <textarea class="form-control" placeholder="ELDB" id="input_str_name_panel_for_scatter_graph"></textarea>
                <label for="input_str_name_panel_for_scatter_graph">Output Panel Name (no white spaces)</label>
            </div>

            <div class="form-floating">
                <textarea class="form-control" placeholder="sc-elephant database" id="input_str_name_figure_for_scatter_graph"></textarea>
                <label for="input_str_name_figure_for_scatter_graph">Output Figure Name</label>
            </div>
        </div>

        <div id="panel_figure_name_setting_for_violin_graph">
            <div class="form-floating">
                <textarea class="form-control" placeholder="ELDB" id="input_str_name_panel_for_violin_graph"></textarea>
                <label for="input_str_name_panel_for_violin_graph">Output Panel Name (no white spaces)</label>
            </div>

            <div class="form-floating">
                <textarea class="form-control" placeholder="sc-elephant database" id="input_str_name_figure_for_violin_graph"></textarea>
                <label for="input_str_name_figure_for_violin_graph">Output Figure Name</label>
            </div>
        </div>

        <div id="panel_figure_name_setting_for_dot_graph">
            <div class="form-floating">
                <textarea class="form-control" placeholder="ELDB" id="input_str_name_panel_for_dot_graph"></textarea>
                <label for="input_str_name_panel_for_dot_graph">Output Panel Name (no white spaces)</label>
            </div>

            <div class="form-floating">
                <textarea class="form-control" placeholder="sc-elephant database" id="input_str_name_figure_for_dot_graph"></textarea>
                <label for="input_str_name_figure_for_dot_graph">Output Figure Name</label>
            </div>
        </div>
        <br>

        <div>
          <h5>Figure Size</h5>
        </div>
        <div id="panel_figure_size_and_margin_setting_for_scatter_graph">
            <div class="row g-2">
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1200" id="input_int_fig_size_x_for_scatter_graph"></textarea>
                    <label for="input_int_fig_size_x_for_scatter_graph">Width (pixels)</label>
                </div>
              </div>
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1000" id="input_int_fig_size_y_for_scatter_graph"></textarea>
                    <label for="input_int_fig_size_y_for_scatter_graph">Height (pixels)</label>
                </div>
              </div>
            </div>

            <div class="row g-2">
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1200" id="input_int_margin_l_for_scatter_graph"></textarea>
                    <label for="input_int_margin_l_for_scatter_graph">Left Margin (pixels)</label>
                </div>
              </div>
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1000" id="input_int_margin_b_for_scatter_graph"></textarea>
                    <label for="input_int_margin_b_for_scatter_graph">Bottom Margin (pixels)</label>
                </div>
              </div>
            </div>
            <br>
        </div>

        <div id="panel_figure_size_and_margin_setting_for_violin_graph">
            <div class="row g-2">
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1200" id="input_int_fig_size_x_for_violin_graph"></textarea>
                    <label for="input_int_fig_size_x_for_violin_graph">Width (pixels)</label>
                </div>
              </div>
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1000" id="input_int_fig_size_y_for_violin_graph"></textarea>
                    <label for="input_int_fig_size_y_for_violin_graph">Height (pixels)</label>
                </div>
              </div>
            </div>

            <div class="row g-2">
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1200" id="input_int_margin_l_for_violin_graph"></textarea>
                    <label for="input_int_margin_l_for_violin_graph">Left Margin (pixels)</label>
                </div>
              </div>
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1000" id="input_int_margin_b_for_violin_graph"></textarea>
                    <label for="input_int_margin_b_for_violin_graph">Bottom Margin (pixels)</label>
                </div>
              </div>
            </div>
        </div>

        <div id="panel_figure_size_and_margin_setting_for_dot_graph">
            <div class="row g-2">
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1200" id="input_int_fig_size_x_for_dot_graph"></textarea>
                    <label for="input_int_fig_size_x_for_dot_graph">Width (pixels)</label>
                </div>
              </div>
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1000" id="input_int_fig_size_y_for_dot_graph"></textarea>
                    <label for="input_int_fig_size_y_for_dot_graph">Height (pixels)</label>
                </div>
              </div>
            </div>

            <div class="row g-2">
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1200" id="input_int_margin_l_for_dot_graph"></textarea>
                    <label for="input_int_margin_l_for_dot_graph">Left Margin (pixels)</label>
                </div>
              </div>
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1000" id="input_int_margin_b_for_dot_graph"></textarea>
                    <label for="input_int_margin_b_for_dot_graph">Bottom Margin (pixels)</label>
                </div>
              </div>
            </div>
        </div>
        
        <div id="panel_figure_size_and_margin_setting_for_word_cloud_graph">
            <div class="row g-2">
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="1100" id="input_int_fig_size_x_for_word_cloud_graph"></textarea>
                    <label for="input_int_fig_size_x_for_word_cloud_graph">Width (pixels)</label>
                </div>
              </div>
              <div class="col-md">
                <div class="form-floating">
                    <textarea class="form-control" placeholder="300" id="input_int_fig_size_y_for_word_cloud_graph"></textarea>
                    <label for="input_int_fig_size_y_for_word_cloud_graph">Height (pixels)</label>
                </div>
              </div>
            </div>
        </div>

        <div id="plotting_panel_title_marker_size">
          <h5>Marker (Point) Size</h5>
        </div>
        <div class="form-check form-switch" id="plotting_panel_switch_responsive_marker_size_or_static">
            <input class="form-check-input" type="checkbox" id="switch_responsive_marker_size_or_static">
            <label class="form-check-label" for="switch_responsive_marker_size_or_static">Responsive Marker (Point) Size</label>
        </div>
        <div class="form-floating" id="plotting_panel_input_int_marker_size_for_scatter">
            <textarea class="form-control" placeholder="3" id="input_int_marker_size_for_scatter"></textarea>
            <label for="input_int_marker_size_for_scatter">Marker Size (pixels)</label>
        </div>
        <div class="form-floating" id="plotting_panel_input_int_marker_size_for_dot_plot">
            <textarea class="form-control" placeholder="3" id="input_int_marker_size_for_dot_plot"></textarea>
            <label for="input_int_marker_size_for_dot_plot">Marker Size (pixels)</label>
        </div>
        <br>
    </div>
        
  </div>
</div>
    
    
<!-- Modals for tutorials -->
<div class="modal fade" id="modal_for_tutorial" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1" aria-labelledby="modal_for_tutorial" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="staticBackdropLabel">Welcome to SC-Elephant🐘<b><tt>.js</tt></b> Web Viewer</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <b>SC-Elephant.js</b> Viewer can be used to analyze <b><tt>RamData</tt></b> hosted on the web, including <b>GitHub Page</b> or <b>Amazon AWS S3</b>, without the use of expensive <i>server-side</i> applications, like that of cellxgene or Shiny-based applications. All the scripts of SC-Elephant.js are executed in the <i>client-side</i>.
          <br>  
          <div class="d-flex justify-content-center">
            <img class="image-very-small" src="images/scelephant.js.logo.png" alt="scelephant_logo"/>
          </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" onclick="StartTutorial( );">Start Tutorial</button>
      </div>
    </div>
  </div>
</div>
    
<div class="modal fade" id="modal_for_tutorial_intro" data-bs-backdrop="false" data-bs-keyboard="false" aria-hidden="true" aria-labelledby="modal_for_tutorial_label_intro" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="modal_for_tutorial_label_intro">What is <b><tt>SC-Elephant.js?</tt></b></h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>
            <b><tt>SC-Elephant.js</tt></b> is a JavaScript implementation of <a href="https://github.com/ahs2202/scelephant" target="_blank" rel="noopener noreferrer"><b>SC-Elephant</b></a> (Single-Cell Extremely Large Data Analysis Platform), a Python package for the analysis of extremely large single-cell data in a very memory-efficient manner. <tt>SC-Elephant.js</tt> allows analysis of <tt>RamData</tt> in a web browser, increasing the accessibility of a single-cell data.
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary" onclick="StartTutorialRamData( );">1) Load RamData</button>
      </div>
    </div>
  </div>
</div>
    
<div class="modal fade" id="modal_for_tutorial_ramdata" data-bs-backdrop="false" data-bs-keyboard="false" aria-hidden="true" aria-labelledby="modal_for_tutorial_ramdata_label" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="modal_for_tutorial_ramdata_label">1) Load RamData</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <tt>SC-Elephant.py</tt> generates a <b><tt>RamData</tt></b> object for the analysis of a single-cell data matrix.
          <br><br>The resulting <tt>RamData</tt> object, once uploaded to the GitHub Page (or any web location with <i>CORS</i> enabled), can be analyzed by <tt>SC-Elephant.py</tt> or <tt>.js</tt>. Here, using <tt>SC-Elephant.js</tt>, a <tt>RamData</tt> object can be visualized and explored.
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary me-auto" onclick="StartTutorial( );">1) Load RamData</button>
        <button class="btn btn-primary" onclick="StartTutorialAnnData( );">2) Retrieve AnnData</button>
      </div>
    </div>
  </div>
</div>
    
<div class="modal fade" id="modal_for_tutorial_anndata" data-bs-backdrop="false" data-bs-keyboard="false" aria-hidden="true" aria-labelledby="modal_for_tutorial_anndata_label" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="modal_for_tutorial_anndata_label">2) Retrieve AnnData</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        A <tt>RamData</tt> object is composed of two <b><tt>RamDataAxis</tt></b> (<b>Axis</b>) objects and multiple <b><tt>RamDataLayer</tt></b> (<b>Layer</b>) objects.
        <br>
        <br>
        The two RamDataAxis objects, <b>'Barcode'</b> and <b>'Feature'</b> objects, use <b><tt>'filter'</tt></b> to select cells (barcodes) and genes (features) before retrieving data from the <tt>RamData</tt> object, respectively.
        <br>
        <br>
          <div class="d-flex justify-content-center">
            <img class="image-small" src="images/scelephant.js.structure.png" alt="scelephant_logo"/>
          </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary me-auto" onclick="StartTutorialRamData( );">1) Load RamData</button>
        <button class="btn btn-primary" onclick="StartTutorialPlotAnnData( );">3) Plot AnnData</button>
      </div>
    </div>
  </div>
</div>
    
<div class="modal fade" id="modal_for_tutorial_plot_anndata" data-bs-backdrop="false" data-bs-keyboard="false" aria-hidden="true" aria-labelledby="modal_for_tutorial_plot_anndata_label" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="modal_for_tutorial_plot_anndata_label">3) Plot AnnData</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        Once an <b><tt>AnnData</tt></b> object (a single-cell data container, like the AnnData object of SCANPY) is retrieved, various plots can be drawn, including the <b>Scatter</b>, <b>Violin</b>, and <b>Dot</b> plots.
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary me-auto" onclick="StartTutorialAnnData( );">2) Retrieve AnnData</button>
        <button class="btn btn-primary" onclick="CompleteTutorial( );">Complete Tutorial</button>
      </div>
    </div>
  </div>
</div>
    
<div class="modal fade" id="modal_keyboard_shortcuts" data-bs-backdrop="true" data-bs-keyboard="true" aria-hidden="true" aria-labelledby="modal_keyboard_shortcuts_label" tabindex="-1">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="modal_keyboard_shortcuts_label">Keyboard Shortcuts</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="modal-body">
            <h5 class="text-muted mb-2" style="font-size:20px">Panels</h5>
            <p><kbd>Alt</kbd> + <kbd>q</kbd> - open <b>1) Load RamData</b> panel.</p>
            <p><kbd>Alt</kbd> + <kbd>w</kbd> - open <b>2) Retrieve AnnData</b> panel.</p>
            <p><kbd>Alt</kbd> + <kbd>e</kbd> - open <b>3) Plot AnnData</b> panel.</p>
            <br>
            <h5 class="text-muted mb-2" style="font-size:20px">Plotting</h5>
            <p><kbd>Alt</kbd> + <kbd>r</kbd> - draw a graph using the settings, equivalent to clicking <button type="button" class="btn btn-primary">Plot AnnData</button> button.</p>
            
            <h5 class="text-muted mb-2" style="font-size:20px">Miscellaneous</h5>
            <p><kbd>Ctrl</kbd> + <kbd>i</kbd> - open an introduction modal</p>
            <br>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary me-auto" onclick="StartTutorialPlotAnnData( );">3) Plot AnnData</button>
        <button class="btn btn-primary" type="button" data-bs-dismiss="modal" aria-label="Close">Close</button>
      </div>
    </div>
  </div>
</div>
    
<!-- bootstrap5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
    
<script>
// dependencies of Tagify
var DragSort=function(t){var e,i=0,s={},r={},a=(e=window.MutationObserver||window.WebKitMutationObserver,function(t,i){t&&1===t.nodeType&&(e?new e((function(t,e){i(t)})).observe(t,{childList:!0,subtree:!1}):window.addEventListener&&t.addEventListener("DOMNodeInserted",i,!1))});function n(t,e){if(!t)return this;e=e||{},this.parentElm=t,this.uid=e.uid,this.settings={selector:"*",callbacks:{}},Object.assign(this.settings,e),this.setup(),a(this.parentElm,this.setup.bind(this)),this.bindEvents()}return n.prototype={namespace:"dragsort",setup(){[...this.parentElm.childNodes].forEach(t=>{if(1!=t.nodeType)return t.parentNode.removeChild(t);t.matches(this.settings.selector)&&(t.draggable=!0)}),this.gap=this.getItemsGap(this.parentElm.firstElementChild)},throttle(t,e){var i=!1,s=this;return function(r){i||(t.call(s,r),i=!0,setTimeout(()=>i=!1,e))}},getDraggableElm(t){var e=t.closest('[draggable="true"]');return this.uid==s.uid?e:null},dragstart(t,e){s=this;var i,r=this.getDraggableElm(e);r?(this.source=this.getInitialState(),this.target=this.getInitialState(),i=r.getBoundingClientRect(),this.source.elm=r,this.source.idx=this.getNodeIndex(r),this.source.size.width=i.width,this.source.size.height=i.height,t.dataTransfer.effectAllowed="move",setTimeout(this.afterDragStart.bind(this))):s={}},afterDragStart(){var t="vertical"==this.settings.mode?"height":"width";this.parentElm.classList.add(this.namespace+"--dragStart"),this.source.elm.style[t]=this.source.size[t]+"px",this.source.elm.classList.add(this.namespace+"--dragElem")},dragover(t){t.preventDefault(),t.stopPropagation();var e=t.target;if((e=this.getDraggableElm(e))&&this.target){var i=this.target.elm,s=this.target.hoverDirection;t.dataTransfer.dropEffect="move",this.target.hoverDirection=this.getTargetDirection(t),i==e&&s==this.target.hoverDirection||this.directionAwareDragEnter(t,e)}},dragenter(t,e){(e=this.getDraggableElm(e))&&this.target&&this.isValidElm(e)&&this.source.elm!=e&&this.source.elm&&(this.target.bounding=e.getBoundingClientRect())},directionAwareDragEnter(t,e){var i;t.preventDefault(),t.stopPropagation(),t.dataTransfer.dropEffect="none",this.isValidElm(e)&&this.source.elm!=e&&this.source.elm&&(t.dataTransfer.dropEffect="move",this.cleanupLastTarget(),this.target.elm=e,this.target.idx=this.getNodeIndex(e),e.classList.add("over"),i=Math.abs(this.target.idx-this.source.idx),this.source.elm.classList.toggle(this.namespace+"--hide",i>0),"vertical"==this.settings.mode?this.target.elm.style[this.target.hoverDirection?"marginBottom":"marginTop"]=this.source.size.height+this.gap+"px":this.target.elm.style[this.target.hoverDirection?"marginRight":"marginLeft"]=this.source.size.width+this.gap+"px")},dragend(t){if(clearTimeout(this.dragoverTimeout),this.dragoverTimeout=null,this.parentElm.classList.remove(this.namespace+"--dragStart"),!this.isValidElm(this.target.elm))return this.cleanup();var e=this.target.hoverDirection?this.target.elm.nextElementSibling:this.target.elm;return this.source.elm!=this.target.elm&&this.target.elm&&(this.target.elm.classList.add(this.namespace+"--noAnim"),this.cleanup(),this.parentElm.insertBefore(this.source.elm,e)),this.source.elm&&this.source.elm.classList.remove(this.namespace+"--dragElem",this.namespace+"--hide"),this.settings.callbacks.dragEnd(this.source.elm),this},isTargetLastChild(){return this.parentElm.lastElementChild==this.target.elm},getTargetDirection(t){if(this.target.bounding)return"vertical"==this.settings.mode?t.pageY>this.target.bounding.top+this.target.bounding.height/2?1:0:t.pageX>this.target.bounding.left+this.target.bounding.width/2?1:0},getNodeIndex(t){for(var e=0;t=t.previousSibling;)3==t.nodeType&&/^\s*$/.test(t.data)||e++;return e},isValidElm(t){return t&&t.nodeType&&t.parentNode==this.parentElm},cleanup(){s={},[...this.parentElm.children].forEach(t=>{t.removeAttribute("style"),setTimeout(()=>{t.classList.remove(this.namespace+"--over",this.namespace+"--noAnim",this.namespace+"--dragElem")},50)})},cleanupLastTarget(){this.target.elm&&(this.target.elm.classList.remove(this.namespace+"--hide",this.namespace+"--over"),this.target.elm.removeAttribute("style"))},getInitialState:()=>({elm:null,size:{}}),getItemsGap(t){var e=getComputedStyle(t);return"vertical"==this.settings.mode?parseInt(e.marginTop)+parseInt(e.marginBottom):parseInt(e.marginLeft)+parseInt(e.marginRight)},bindEvents(t){for(var e in this.listeners=this.listeners||{dragstart:t=>this.dragstart(t,t.target),dragenter:t=>this.dragenter(t,t.target),dragend:t=>this.dragend(t,t.target),dragover:this.throttle(this.dragover,350)},this.listeners)this.parentElm[t?"removeEventListener":"addEventListener"](e,this.listeners[e])},destroy(){this.cleanup(),this.bindEvents(!0),delete r[this.uid]}},function(t,e){return r[++i]=t._DragSort?r[t._DragSort]:new n(t,{...e,uid:i}),t._DragSort=i,r[i]}}();
    
/*
Implementation of RamData.js [START]
*/
// functions from the external references
// set operations
function isSuperset(set, subset) {
  for (const elem of subset) {
    if (!set.has(elem)) {
      return false;
    }
  }
  return true;
}
function union(setA, setB) {
  const _union = new Set(setA);
  for (const elem of setB) {
    _union.add(elem);
  }
  return _union;
}
function intersection(setA, setB) {
  const _intersection = new Set();
  for (const elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem);
    }
  }
  return _intersection;
}
function symmetricDifference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    if (_difference.has(elem)) {
      _difference.delete(elem);
    } else {
      _difference.add(elem);
    }
  }
  return _difference;
}
function difference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}
    
// string functions
function isString ( value ) { // Returns if a value is a string
    return typeof value === 'string' || value instanceof String;
}
// define hashing funciton of string -> not recommended. please use cyrb53 hashing function
Object.defineProperty(String.prototype, 'hashCode', {
        value: function() {
            var hash = 0, i, chr;
            for (i = 0; i < this.length; i++) {
                chr   = this.charCodeAt(i);
                hash  = ((hash << 5) - hash) + chr;
                hash |= 0; // Convert to 32bit integer
            }
        return hash;
    }
});
function reverseString(str) {
    var newString = "";
    for (var i = str.length - 1; i >= 0; i--) {
        newString += str[i];
    }
    return newString;
}
// 53-bit hash with less collision rate than 32-bit hash (from 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript')
const cyrb53 = (str, seed = 0) => {
  let h1 = 0xdeadbeef ^ seed,
    h2 = 0x41c6ce57 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  
  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
  
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
// code for pseudorandom number generator (PRNG) with random seed from https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
function xmur3(str) { // random seed generator
    for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353),
        h = h << 13 | h >>> 19;
    return function() {
        h = Math.imul(h ^ h >>> 16, 2246822507);
        h = Math.imul(h ^ h >>> 13, 3266489909);
        return (h ^= h >>> 16) >>> 0;
    }
}
function mulberry32(a) { // a simple (PRNG) generator with a 32-bit state
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}   
let prng_seed = xmur3( "sc-elephant" ), 
    rand = mulberry32( prng_seed( ) ); // retrieve seed for a PRNG // retrieve a function for PRNG
    
// implemented functions
// implemented functions - str
function string_insert_every_n_chars( str_main, str_to_be_inserted, n_chars ) {
    /*
    string_insert_every_n_chars( str_main, str_to_be_inserted, n_chars )
    
    'str_to_be_inserted' will be inserted to 'str_main' string every 'n_chars'
    the resulting string will be returned
    */
    let l_substrings = [ ]; // initialize the array that will contain substrings for composing the result string
    for ( let pos = 0; pos < str_main.length; pos += n_chars ) {
        l_substrings.push( str_main.slice( pos, pos + n_chars ) );
    }
    return l_substrings.join( str_to_be_inserted ); // return the resulting string
}
function string_shorten( str_to_be_shortened, len_string_output = 75, str_ellipsis = '...' ) {
    if ( str_to_be_shortened.length > len_string_output ) {
        let length_string_flanking_ellipsis = parseInt( ( len_string_output - str_ellipsis.length ) / 2 ),
            string_left = str_to_be_shortened.slice( 0, length_string_flanking_ellipsis ),
            string_right = str_to_be_shortened.slice( str_to_be_shortened.length - length_string_flanking_ellipsis ),
            str_shortened = string_left + str_ellipsis + string_right; // compose shortened string
        return str_shortened
    } else {
        return str_to_be_shortened
    }
}
// implemented functions - unclassified
function check_none( val ) {
    // check whether the given value 'val' is either undefined or null
    return ( val === undefined ) | ( val === null );
}
function sort_number( a, b ) {
    return a - b;
}
function count_ba( ba, length ) {
    // count the number of active entries in the given BitSet object 'ba' of the given length 'length'
    let int_num_active_entries = 0;
    for ( let i = 0; i < length; i ++ ) {
        int_num_active_entries += ba.get( i );
    }
    return int_num_active_entries;
}
function ba_to_integer_indices( ba, length ) {
    /*
    convert BitSet array to an array of integer indices of the active entries
    */
    // initialize the list of integer indices
    let l_int_index = [ ];
    for ( let i = 0; i < length; i ++ ) {
        if ( ba.get( i ) > 0 ) {
            l_int_index.push( i );
        }
    }
    return l_int_index;
}
function to_ba( arr ) {
    /*
    convert arrays to a BitSet object
    */
    // if BitSet object is given, return the object and exit
    if ( arr instanceof BitSet ) {
        return arr;
    }

    // if 'NestedArray' is given, check shape and flatten the array
    if ( arr instanceof zarr.NestedArray ) {
        // if a given 'arr' is a NestedArray, check its shape (the length of the filter should be same as the number of rows of the current object)
        if ( ! ( arr.shape.length == 1 ) ) {
            if ( this.verbose ) {
                console.log( "the shape of the given filter is invalid, exiting" );
            }
            return;
        }
        arr = arr.flatten( ); // flatten the nested array

    } else if ( arr instanceof Int8Array ) {
        // if flattened 'Int8Array' is given, check shape
        // if the length of the given array is different from the number of rows of the object
    } else {
        if ( this.verbose ) {
            console.log( "date type of given input is invalid" );
        }
        return;
    }
    // initialize BitSet object
    let ba = new BitSet,
        i = 0,
        val = 0;
    // set BitSet object
    for ( i = 0; i < arr.length ; i ++ ) {
        val = arr[ i ];
        if ( val != 0 ) {
            ba.set( i, 1 )
        }
    }
    return ba;
}
function ParseBase64GzippedText( str_base64_gzipped ) {
    // Decode base64 (convert ascii to binary) // Convert binary string to character-number array // Turn number array into byte-array // Convert gunzipped byteArray back to ascii string:
    let l_char = pako.inflate( new Uint8Array( atob( str_base64_gzipped ).split( '' ).map( function( x ) { return x.charCodeAt( 0 ); } ) ) ); 
    let str_content = ""; // convert ASCII value to character and concatenate the characters into a string
    for ( let i = 0; i < l_char.length; i ++ ) {
        str_content += String.fromCharCode( l_char[ i ] );
    }
    return str_content;
}
function ParseTransposedArrayWithHeader( l_l ) { // return a dictionary of arrays ( similar to the DataFrame.toDict() output ) from an array of arrays
    let dictarr = { };
    for ( let i = 0; i < l_l.length; i ++ ) {
        let key = l_l[ i ].shift( );
        dictarr[ key ] = l_l[ i ];
    }
    return dictarr;
}

// sparse matrix
class SparseMatrix {
    /*
    a class for storing 2D sparse matrix 
    l_arr_data : an array containing the following arrays:
        l_int_index_for_querying : a list of int_index values for querying
        l_l_int_index_not_for_querying : a list of lists containing int_index of the axis not for querying
        l_l_value : a list of lists containing values
    shape // shape of the sparse matrix. required for to_dense operation
    is_for_querying_primary_axis // is the axis for querying is primary, set this flag to true. 
    */
    constructor( l_arr_data, shape, is_for_querying_primary_axis = true, verbose = true ) {
        /*
        2022/11/03
        */
        // set attributes
        this.is_for_querying_primary_axis = is_for_querying_primary_axis;
        this.shape = shape;
        this.verbose = verbose;
        // set attributes
        this.length = this.shape[ ( this.is_for_querying_primary_axis ) ? 0 : 1 ]; // retrieve the number of queries 
        if ( l_arr_data instanceof Array ) {
            // construct a sparse matrix from the array input
            // validate input
            if ( l_arr_data.length != 3 ) {
                if ( this.verbose ) {
                    console.log( 'invalid input. the length of the array should be 3.' )
                }
                return;
            }
            let int_num_entries_axis_for_querying_with_data = l_arr_data[ 0 ].length; // retrieve the number of entries in the input array
            this._data = { }
            for ( let i = 0; i < int_num_entries_axis_for_querying_with_data; i ++ ) {
                let int_index_for_querying = l_arr_data[ 0 ][ i ],
                    l_int_index_not_for_querying = l_arr_data[ 1 ][ i ],
                    l_value = l_arr_data[ 2 ][ i ];
                this._data[ int_index_for_querying ] = [ l_int_index_not_for_querying, l_value ];
            }
        } else if ( l_arr_data instanceof Object ) {
            // build a sparse matrix from the Object input
            this._data = l_arr_data; // use the given object directly as the data source
        }
    }
    subset( args ) {
        /*
        args : an integer or list of integer indices for the axis for querying
        
        return a subset of the current sparse matrix that contains entries of a given list of integer indices for the current axis for querying 
        */
        // if a single integer was given, 
        if ( typeof args == 'number' ) {
            args = [ args ];
        }
        // retrieve a list of all the integer indices for the axis for querying for subsetting
        let len_axis_for_querying = this.shape[ ( this.is_for_querying_primary_axis ) ? 0 : 1 ], // retrieve the length of the axis for querying
            l_int_entry_subset = [ ... new Set( args ) ].filter( e => ( e >= 0 ) & ( e < len_axis_for_querying ) ).sort( sort_number ), // sort by int_entry // filter out queried indices that are out of the range of the queried axis
            data_subset =  { }, // initialize a new data that will contain a subset of the sparse matrix
            int_entry_new = 0; // 'int_entry_new' after subsetting
        // subset array
        for ( let int_entry of l_int_entry_subset ) {
            if ( int_entry in this._data ) { // if current object contains data for the 'int_entry' entry
                data_subset[ int_entry_new ] = this._data[ int_entry ]; // retrieve data
            }
            int_entry_new += 1; // update 'int_entry_new' 
        }
        // set new shape
        let shape_new = [ ... this.shape ];
        shape_new[ ( this.is_for_querying_primary_axis ) ? 0 : 1 ] = int_entry_new; // compose the new shape. now the length of the axis for querying should be the number of entries that were used in the subsetting
        return new SparseMatrix( data_subset, shape_new, this.is_for_querying_primary_axis ); // return a new SparseMatrix object containing a subset of data
    }
    to_dense( dtype = 'float64' ) {
        /*
        return a dense matrix (using Array) of the current sparse matrix
        */
        let arr = nj.zeros( this.shape, dtype ); // initialize the dense array using numjs
        for ( let int_entry in Object.keys( this._data ) ) { // iterate over the int_entry for querying
            let res = this._data[ int_entry ],
                l_int_index_not_for_querying = res[ 0 ],
                l_value = res[ 1 ];
            for ( let i = 0; i < l_value.length; i ++ ) {
                let int_index_not_for_querying = l_int_index_not_for_querying[ i ],
                    value = l_value[ i ];
                // set value
                if ( this.is_for_querying_primary_axis ) {
                    arr.set( int_entry, int_index_not_for_querying, value ); // set value
                } else {
                    arr.set( int_index_not_for_querying, int_entry, value ); // set value
                }
            }
        }
        return arr; // return a dense numjs array
    }
    detect_data_type( ) {
        /*
        detect data type contained in the sparse matrix
        # 20231225 HSA
        */
        let flag_integer = true, // initialize 'flag_integer' with true
            int_num_records_to_survey = 100, // internal settings, the number of values to survey
            int_num_records_surveyed = 0, // initialize 'int_num_records_surveyed'
            data = this._data; // retrieve the data
        for ( let key of Object.keys( data ) ) { // iterate over axis 0
            for ( let val of data[ key ][ 1 ].slice( 0, int_num_records_to_survey ) ) { // survey 'int_num_records_to_survey' number of values maximum.
                if ( parseInt( val ) != val ) { // if the value is not integer data type
                    flag_integer = false; // update 'flag_integer'
                    break;
                }
                int_num_records_surveyed += 1;
                if ( int_num_records_surveyed > int_num_records_to_survey ) { // exit if sufficient number of values were surveyed
                    break;
                }; 
            }
            if ( ( flag_integer == false ) | ( int_num_records_surveyed > int_num_records_to_survey ) ) {
                break;
            }; 
        }
        return flag_integer; // return the result
    }
    to_matrix_market_text( flag_switch_primary_and_secondary_axes = true ) {
        /*
        convert the matrix to matrix market formatted text file
        
        flag_switch_primary_and_secondary_axes = true // to export in the 10x MEX format, AnnData's axes should be switched.
        # 20231225 HSA
        */
        let flag_integer = this.detect_data_type( ), // detect the datatype
            str_data_type = flag_integer ? "integer" : "real", // retrieve 'str_data_type' for the matrix market format
            data = this._data,
            int_total_n_records = 0, // initialize 'int_total_n_records'
            l_str_content = [ ], // initialize the content
            i = 0; // for looping
        
        // survey the total number of records
        for ( let key in data ) { // for each column
            int_total_n_records += data[ key ][ 0 ].length; // update 'int_total_n_records' with the number of records of the column
        }
        
        // add the header
        l_str_content.push( `%%MatrixMarket matrix coordinate ${str_data_type} general\n%\n${this.shape[ 1 ]} ${this.shape[ 0 ]} ${int_total_n_records}` ); // add the header
        
        // write each record
        if ( this.is_for_querying_primary_axis ) {
            for ( let idx_row in data ) { // for each row
                let arr_idx_col = data[ idx_row ][ 0 ],
                    arr_val = data[ idx_row ][ 1 ],
                    int_num_records = arr_val.length,
                    str_idx_row = ( parseInt( idx_row ) + 1 ).toString( ); // 0>1 based coordinates
                for ( i = 0; i < int_num_records; i ++ ) {
                    let str_idx_col = parseInt( arr_idx_col[ i ] + 1 ).toString( ), // 0>1 based coordinates 
                        str_val = ( flag_integer ? parseInt( arr_val[ i ] ) : arr_val[ i ] ).toString( );
                    if ( flag_switch_primary_and_secondary_axes ) {
                        l_str_content.push( [ str_idx_col, str_idx_row, str_val ].join( ' ' ) ); // using join appear to be more performant 
                    } else {
                        l_str_content.push( [ str_idx_row, str_idx_col, str_val ].join( ' ' ) ); // using join appear to be more performant 
                    }
                }
            }
        } else {
            for ( let idx_col in data ) { // for each column
                let arr_idx_row = data[ idx_col ][ 0 ],
                    arr_val = data[ idx_col ][ 1 ],
                    int_num_records = arr_val.length,
                    str_idx_col = ( parseInt( idx_col ) + 1 ).toString( ); // 0>1 based coordinates
                for ( i = 0; i < int_num_records; i ++ ) {
                    let str_idx_row = parseInt( arr_idx_row[ i ] + 1 ).toString( ), // 0>1 based coordinates 
                        str_val = ( flag_integer ? parseInt( arr_val[ i ] ) : arr_val[ i ] ).toString( );
                    if ( flag_switch_primary_and_secondary_axes ) {
                        l_str_content.push( [ str_idx_col, str_idx_row, str_val ].join( ' ' ) ); // using join appear to be more performant 
                    } else {
                        l_str_content.push( [ str_idx_row, str_idx_col, str_val ].join( ' ' ) ); // using join appear to be more performant 
                    }
                }
            }
        }
        l_str_content.push( '' ); // add the last line
        return l_str_content.join( '\n' ); // return the content in string format
    }
}
class DataFrame {
    /*
    name_col_index : name of the index.
    length : the number of rows of the dataframe
    */
    constructor( dict_data, name_col_index = undefined, length = undefined, verbose = true ) {
        /*
        retrieve length of dataframe
        */
        if ( check_none( length ) ) {
            if ( Object.keys( dict_data ).length == 0 ) {
                if ( verbose ) {
                    console.log( 'Error, dict_data is empty yet length is not given, exiting' );
                }
                return;
            }
            let col = dict_data[ Object.keys( dict_data )[ 0 ] ]; // retrieve any column
            length = check_none( col.length ) ? col.shape[ 0 ] : col.length; // retrieve the length of a dataframe
        }
        this.length = length;
        this._dict_data = dict_data; // add data
        
        // set columns attribute (a set of column names)
        this.columns = new Set( Object.keys( this._dict_data ) );
        
        /*
        Build Index of DataFrame
        */
        let flag_use_default_index = check_none( name_col_index ) | ( ! this.columns.has( name_col_index ) ), // retrieve a flag indicating whether a default index should be used.
            arr_index = flag_use_default_index ? nj.arange( this.length ).tolist( ) : this._dict_data[ name_col_index ], // use integer indices by default
            dict_mapping_index = { }; // initialize a dictionary for mapping
        this.index = arr_index // set index values
        for ( let i = 0; i < arr_index.length; i ++ ) {
            let e = arr_index[ i ]; // retrieve index value at 'i'
            if ( ! ( e in dict_mapping_index ) ) {
                dict_mapping_index[ e ] = [ ];
            }
            dict_mapping_index[ e ].push( i );
        }
        this._dict_mapping_index = dict_mapping_index;
        this.name_col_index = flag_use_default_index ? undefined : name_col_index; // retrieve the name_col for building an index // update a name_col used for building an index
    }
    set_index( name_col_index ) {
        /*
        set index of a DataFrame object
        */
        let flag_use_default_index = check_none( name_col_index ) | ( ! this.columns.has( name_col_index ) ), // retrieve a flag indicating whether a default index should be used.
            arr_index = flag_use_default_index ? nj.arange( this.length ).tolist( ) : this._dict_data[ name_col_index ], // use integer indices by default
            dict_mapping_index = { }; // initialize a dictionary for mapping
        this.index = arr_index // set index values
        for ( let i = 0; i < arr_index.length; i ++ ) {
            let e = arr_index[ i ]; // retrieve index value at 'i'
            if ( ! ( e in dict_mapping_index ) ) {
                dict_mapping_index[ e ] = [ ];
            }
            dict_mapping_index[ e ].push( i );
        }
        this._dict_mapping_index = dict_mapping_index;
        this.name_col_index = flag_use_default_index ? undefined : name_col_index; // retrieve the name_col for building an index // update a name_col used for building an index
    }
    add_column( name_col, arr_val ) {
        /*
        add a new column to the dataframe
        
        name_col : the name of new column
        arr_val : array of values
        */
        let length_new_col = check_none( arr_val.length ) ? arr_val.shape[ 0 ] : arr_val.length; // retrieve the length of the new column
        if ( length_new_col == this.length ) { // check the length of the new column is the same as the length of the current dataframe
            this._dict_data[ name_col ] = arr_val; // add/update the column of the dataframe
            this.columns.add( name_col ); // add the column name to the columns attribute.
        }
    }
    get_column( name_col ) {
        /*
        retrieve values of the column
        */
        if ( this.columns.has( name_col ) ) { // check whether the current dataframe contains 'name_col' column
            return this._dict_data[ name_col ]; // return the values of the column
        }
    }
    get_integer_indices_of_rows( l_index_value = undefined ) {
        /*
        retrieve integer indices of rows according to the given row index values
        
        'l_index_value' // a list of index values ('row') for retrieving integer indices 
        */
        // retrieve l_int_index for the subset
        let l_int_index = [ ];
        if ( check_none( l_index_value ) ) {
            l_int_index = nj.arange( this.length ).tolist( ); // if no selection was given, use the integer indices of all rows.
        } else {
            for ( let index_val of l_index_value ) {
                if ( index_val in this._dict_mapping_index ) { // check 'index_val' exists in the dataframe
                    l_int_index.push( ... this._dict_mapping_index[ index_val ] )
                }
            }
        }
        return l_int_index;
    }
    subset( l_index_value = undefined, l_column_value = undefined ) {
        /* 
        return a subset of dataframe according to 'l_index_value' and 'l_column_value'
        */
        // retrieve l_int_index for the subset
        let l_int_index = this.get_integer_indices_of_rows( l_index_value );
        
        // retrieve a subset of data
        let dict_data_subset = { }; // initialize dict_data of a new dataframe
        for ( let col of l_column_value ) {
            if ( col in this._dict_data ) { // if column name exists in the dataframe
                let arr_val_subset = [ ], // initialize the array that will contain a subset of data
                    arr_val = this._dict_data[ col ], // retrieve values of the column
                    flag_is_array = arr_val instanceof Array; // retrieve 'flag_is_array' indicating whether 'arr_val' is an instance of Array
                for ( let int_index of l_int_index ) { // for each 'int_index'
                    arr_val_subset.push( flag_is_array ? arr_val[ int_index ] : arr_val.get( int_index ) ); // retrieve values from NestedArray (class from Zarr.js)
                }
                dict_data_subset[ col ] = arr_val_subset; // retrieve the subset 
            }
        }
        return new DataFrame( dict_data_subset, this.name_col_index, l_int_index.length ); // return a subset of DataFrame, using the same index as the current DataFrame
    }
}
// AnnData
class AnnData {
    /*
    a javascript object for containing an AnnData data object
    
    X : a sparse/dense/empty matrix containing expression data.
    */
    constructor( X = undefined, df_obs = { }, df_var = { }, dict_data_obsm = { }, dict_data_varm = { }, dict_data_uns = { }, verbose = true ) {
        /*
        */
        // set attributes
        this.verbose = verbose;
        
        // check inputs
        if ( ! ( check_none( X ) | ( X instanceof nj.NdArray ) | ( X instanceof SparseMatrix ) ) ) { // X should be an empty value, numjs array, or a sparse matrix.
            if ( this.verbose ) {
                console.log( 'invalid X was given, exiting' )
            }
            return;
        }
        // set attributes
        this.X = X; // sparse/dense matrix
        this.obs = df_obs; // dataframe
        this.var = df_var;
        this.obsm = dict_data_obsm;
        this.varm = dict_data_varm;
        this.uns = dict_data_uns;
    }
    repr( ) {
        /*
        a function to represent AnnData in the javascript
        */
        return `<AnnData object>` // return string representation of the AnnData
        
    }
}
    
class ZarrDataFrame {
    constructor( path_folder_zdf, filter = undefined, flag_retrieve_categorical_data_as_integers = false, verbose = true ) {
        // set attributes
        this.path_folder_zdf = path_folder_zdf;
        this.filter = filter;
        this.flag_retrieve_categorical_data_as_integers = flag_retrieve_categorical_data_as_integers;
        this.verbose = verbose;
        // initialize attributes
        this._columns = { };
    }
    async initialize( ) {
        // load metadata of zarrdataframe
        // should be run before using zdf
        let zattrs = await $.getJSON( `${this.path_folder_zdf}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        
        // set attributes using the metadata
        this.columns = new Set( Object.keys( this.metadata.columns ) ); // retrieve list of column names
        this._n_rows_unfiltered = this.metadata.int_num_rows;
        this.set_filter( this.filter ); // set filter once metadata is loaded_
        this._int_num_rows_in_a_chunk = this.metadata.int_num_rows_in_a_chunk;
    }
    async load_column( name_col ) {
        // load metadata if it has not been loaded
        if ( check_none( this.metadata ) ) {
            await this.initialize( );
        }
        
        // load zarr object and metadata of a given column name
        if ( this.columns.has( name_col ) & ! ( name_col in this._columns ) ) {
            let za = await zarr.openArray({
                store : this.path_folder_zdf,
                path : `${name_col}/`,
                mode: "r"
            });
            // if binary data encoded in '|i1' format ('b1') format was detected, change dtype to '|i1', since '|b1' is currently not supported in the Zarr.js implementation
            if ( za.meta.dtype == '|b1' ) {
                za.meta.dtype = '|i1'; // change dtype to '|i1'
            }
            this._columns[ name_col ] = { 
                'zarr_object' : za,
                'metadata' : ( await $.getJSON( `${this.path_folder_zdf}${name_col}/.zattrs` ) )[ 'dict_col_metadata' ] // read column metadata
            }
        }
    }
    set_filter( ba_filter ) {   
        // if filter is removed
        if ( check_none( ba_filter ) ) {
            this.filter = undefined;
            this._n_rows_after_applying_filter = undefined;
            return;
        }
        
        function count_active_entries( zdf ) {
            // count the number of active entries in the active filter of a given zdf object
            let int_num_active_entries = 0,
                filter = zdf.filter;
            for ( let i = 0; i < zdf._n_rows_unfiltered; i ++ ) {
                int_num_active_entries += filter.get( i );
            }
            zdf._n_rows_after_applying_filter = int_num_active_entries;
        }
        // if BitSet object is given, set the filter and exit
        if ( ba_filter instanceof BitSet ) {
            this.filter = ba_filter;
            count_active_entries( this ); // count active number of entries in the given filter
            return;
        }
            
        // if 'NestedArray' is given, check shape and flatten the array
        if ( ba_filter instanceof zarr.NestedArray ) {
            // if a given 'ba_filter' is a NestedArray, check its shape (the length of the filter should be same as the number of rows of the current object)
            if ( ! ( ba_filter.shape.length == 1 & ba_filter.shape[ 0 ] == this._n_rows_unfiltered ) ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
            ba_filter = ba_filter.flatten( ); // flatten the nested array

        } else if ( ba_filter instanceof Int8Array ) {
            // if flattened 'Int8Array' is given, check shape
            // if the length of the given array is different from the number of rows of the object
            if ( ba_filter.length != this._n_rows_unfiltered ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
        }
        // initialize BitSet object
        let ba = new BitSet,
            i = 0,
            val = 0;
        // set BitSet object
        for ( i = 0; i < ba_filter.length ; i ++ ) {
            val = ba_filter[ i ];
            if ( val != 0 ) {
                ba.set( i, 1 )
            }
        }
        
        // set filter for the object
        this.filter = ba;
        count_active_entries( this ); // count active number of entries in the given filter
    }
    async get_item( name_col, coord_primary_axis = undefined, coord_other_axes = undefined ) {
        /*
        name_col : the name of the column
        coord_primary_axis = undefined : if undefined is given, all entries (if filter is not applied) or filtered entries (if filter is active) will be returned.
        coord_other_axes = undefined : slices or coordinates for a secondary axis and other axes other than the primary axis
        */
        // load metadata if it has not been loaded
        if ( check_none( this.metadata ) ) {
            await this.initialize( );
        }
        
        // retrieve flags
        let flag_coord_primary_axis_not_given = check_none( coord_primary_axis ),
            flag_coord_other_axes_not_given = check_none( coord_other_axes ),
            flag_filter_is_not_active = check_none( this.filter );
        
        // if the 'name_col' is not valid, exit
        if ( ! this.columns.has( name_col ) ) {
            if ( this.verbose ) {
                console.log( `the given column name ${name_col} does not exist in the current ZarrDataFrame, exiting` );
            }
            return;
        }
        await this.load_column( name_col ); // load zarr object of the 'name_col'
        
        let arr_data = [ ];
        if ( flag_coord_primary_axis_not_given ) {
            if ( flag_filter_is_not_active ) {
                if ( flag_coord_other_axes_not_given ) { // when no indexing occurs other than the primary axis
                    arr_data = await this._columns[ name_col ].zarr_object.get( null ); // retrieve all entries (filter is not active, no indexing were given)
                } else {
                    if ( Array.isArray( coord_other_axes ) ) { // when coordinates for multiple axes were given
                        let coords = [ null ];
                        coords.push( ... coord_other_axes );
                        arr_data = await this._columns[ name_col ].zarr_object.get( coords );
                    } else { // when only secondary axis was given
                        arr_data = await this._columns[ name_col ].zarr_object.get( [ null, coord_other_axes ] );
                    }
                }
            } else {
                // filter is active. apply the active filter to the current zarr object
                // exit when the number of active entries in the filter is 0.
                if ( this._n_rows_after_applying_filter == 0 ) {
                    if ( this.verbose ) {
                        console.log( "the number of active entries in the filter is zero, exiting" );
                    }
                    return;
                }
                
                // prepare
                let int_num_entries_in_a_chunk = this._columns[ name_col ].zarr_object.chunks[ 0 ];
                
                // compose an array of coordinates for axes other than the primary axis
                let coords_other_than_primary_axis = [ ];
                if ( ! flag_coord_other_axes_not_given ) {
                    if ( Array.isArray( coord_other_axes ) ) { // when coordinates of more than two axes were given
                        coords_other_than_primary_axis.push( ... coord_other_axes );
                    } else { // when only secondary axis was given
                        coords_other_than_primary_axis.push( coord_other_axes );
                    }
                }
                
                async function _filter_a_portion_of_zarr_object( int_index_start, int_index_end, zdf, coords_other_than_primary_axis, int_num_active_entries_in_a_batch ) {
                    // retrieve data for a portion of zarr object, filter using the given ba_filter, and return filtered records
                    let coords = [ zarr.slice( int_index_start, int_index_end ) ];
                    coords.push( ... coords_other_than_primary_axis ); // combine coordinates of all axes
                    
                    // fetch data
                    let arr = await zdf._columns[ name_col ].zarr_object.get( coords );
                    
                    // initialize the output, filtered array
                    let dtype = arr.dtype, // retrieve dtype of the array
                        l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
                        int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry // when 1D data is given, there will be one value for each entry
                        l_dims_filtered = [ int_num_active_entries_in_a_batch ];
                    l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis
                    
                    arr = arr.flatten( ); // flatten the array
                    let int_num_bytes_for_a_value = arr.byteLength / arr.length, // retrieve the number of bytes for each value
                        filter = zdf.filter;

                    let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * int_num_active_entries_in_a_batch ) ), // initialize the typedarray that will contain the output, filtered data
                        int_index_entry_after_filtering = 0; 
                    
                    for ( let i = int_index_start; i < int_index_end; i ++ ) {
                        if ( filter.get( i ) > 0 ) {
                            arr_filtered.set( arr.slice( int_num_values_for_an_entry * ( i - int_index_start ), int_num_values_for_an_entry * ( i - int_index_start + 1 ) ), int_num_values_for_an_entry * int_index_entry_after_filtering )
                            int_index_entry_after_filtering += 1; // update 'int_index_entry_after_filtering'
                        }
                    }
                    
                    // return the filtered array as a nested array
                    return new zarr.NestedArray( arr_filtered, l_dims_filtered );
                }
                
                let l_promise_filtered = [ ]; // initialize a list of promises that will contain filtered results
                for ( let i = 0; i < Math.ceil( this._n_rows_unfiltered / int_num_entries_in_a_chunk ); i ++ ) { // iterate each chunk
                    // count the number of active entries in a chunk
                    let int_index_start = i * int_num_entries_in_a_chunk,
                        int_index_end = Math.min( ( i + 1 ) * int_num_entries_in_a_chunk, this._n_rows_unfiltered ), 
                        int_num_active_entries_in_a_batch = 0,
                        filter = this.filter;
                    for ( let i = int_index_start; i < int_index_end; i ++ ) {
                        int_num_active_entries_in_a_batch += filter.get( i );
                    }
                    // if there is active entries in the current chunk, fetch and process the data
                    if ( int_num_active_entries_in_a_batch > 0 ) { 
                        l_promise_filtered.push( _filter_a_portion_of_zarr_object( int_index_start, int_index_end, this, coords_other_than_primary_axis, int_num_active_entries_in_a_batch ) );
                    }
                }
                
                // collect filtered results for each valid chunk
                let l_arr_filtered = await Promise.all( l_promise_filtered ),
                    arr = l_arr_filtered[ 0 ]; // retrieve the first filtered result to gather information about the returned results
                
                // initialize the output that will contain the combined filtered array
                let dtype = arr.dtype, // retrieve dtype of the array
                    l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
                    int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry
                    l_dims_filtered = [ this._n_rows_after_applying_filter ];
                l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis

                arr = arr.flatten( ); // flatten the first filtered array
                let int_num_bytes_for_a_value = arr.byteLength / arr.length, // retrieve the number of bytes for each value
                    filter = this.filter;

                let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * this._n_rows_after_applying_filter ) ), // initialize the typedarray that will contain the output, filtered data
                    int_num_values_copied = 0; 

                // iterate through each filtered result and combine data
                for ( let i = 0; i < l_arr_filtered.length; i ++ ) {
                    let arr = l_arr_filtered[ i ].flatten( ); // retrieve a filtered result and flatten the nested array
                    arr_filtered.set( arr, int_num_values_copied ) // copy the filtered result of a chunk to the combined result
                    int_num_values_copied += arr.length; // update 'int_num_values_copied'
                }
                // retrieve the filtered array as a nested array
                arr_data = new zarr.NestedArray( arr_filtered, l_dims_filtered );
            }
        } else {
            // when indexing through primary axis is active
            if ( flag_coord_other_axes_not_given ) { // when no indexing occurs other than the primary axis
                arr_data = await this._columns[ name_col ].zarr_object.get( coord_primary_axis ); // retrieve all entries
            } else {
                if ( Array.isArray( coord_other_axes ) ) { // when coordinates of more than two axes were given
                    let coords = [ coord_primary_axis ];
                    coords.push( ... coord_other_axes );
                    arr_data = await this._columns[ name_col ].zarr_object.get( coords );
                } else { // when only secondary axis was given
                    arr_data = await this._columns[ name_col ].zarr_object.get( [ coord_primary_axis, coord_other_axes ] );
                }
            }
        }
        // retrieve column metadata
        let col_metadata = this._columns[ name_col ].metadata;
        if ( col_metadata[ 'flag_categorical' ] ) { // retrieve categorical data
            if ( arr_data.shape.length > 1 ) { // currently, only a categorical data with 1D shape is supported.
                return arr_data;
            }
            let l_unique_categories = col_metadata[ 'l_value_unique' ], // retrieve a list of unique categories of the given column
                arr_data_category = [ ];
            
            // retrieve categorical data
            for ( let int_index_category of arr_data.flatten( ) ) {
                arr_data_category.push( l_unique_categories[ int_index_category ] );
            }
            arr_data = arr_data_category;
        }
        // return retrieved data
        return arr_data;
    }
    async get_df( l_col ) {
        /*
        return a DataFrame for the given list of columns
        
        loading data of each column asynchronously
        */
        let dict_data = { }, // a dictionary that will contain data for building the output DataFrame
            l_promise_col = [ ], // list of promisess for data of each column
            l_name_col = [ ], // list of name of the columns for the retrieved promises
            name_col_int_repr = 'int_repr'; // name of the column containing the integer representations of each entries
        for ( let col of l_col ) { // for each column in the given list of columns
            if ( this.columns.has( col ) ) { // if the column exists in the dataframe
                l_promise_col.push( this.get_item( col ) ); // retrieve a promise for the column
                l_name_col.push( col ); // retrieve the name of column
            }
        }
        let l_data = await Promise.all( l_promise_col ); // wait until data of all columns has been retrieved.
        
        // compose 'dict_data' using the retrieved data
        for ( let i = 0; i < l_name_col.length; i ++ ) { // iterate each column with retrieved data
            dict_data[ l_name_col[ i ] ] = l_data[ i ]; 
        }
        
        // add integer representations
        dict_data[ name_col_int_repr ] = check_none( this.filter ) ? nj.arange( this._n_rows_unfiltered ).tolist( ) : ba_to_integer_indices( this.filter, this._n_rows_unfiltered );
        
        return new DataFrame( dict_data, name_col_int_repr, this.n_rows, this.verbose ); // return the retrieved data as a dataframe // use inter representations of the entries as the index column
    }
    get_n_rows( ) {
        /* # 2022-06-22 16:36:54 
        retrieve the number of rows after applying filter. if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
        */
        if ( check_none( this.filter ) ) { // if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
            return this._n_rows_unfiltered;
        } else { // if a filter is active
            return this._n_rows_after_applying_filter; // return the number of active rows in the filter
        }
    }
    get n_rows( ) {
        /* # 2022-06-22 16:36:54 
        retrieve the number of rows after applying filter. if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
        */
        if ( check_none( this.filter ) ) { // if the filter is not active, return the number of rows of the unfiltered ZarrDataFrame
            return this._n_rows_unfiltered;
        } else { // if a filter is active
            return this._n_rows_after_applying_filter; // return the number of active rows in the filter
        }
    }
}
async function zarr_get_by_l_int_index( za, l_int_index, coord_other_axes = undefined ) {
    /* 
    'l_int_index' WILL BE SORTED
    */
    // prepare (retrieve the number of entries in the primary axis of a chunk
    let int_num_entries_in_a_chunk = za.chunks[ 0 ],
        flag_coord_other_axes_not_given = check_none( coord_other_axes );

    // compose an array of coordinates for axes other than the primary axis
    let coords_other_than_primary_axis = [ ];
    if ( ! flag_coord_other_axes_not_given ) {
        if ( Array.isArray( coord_other_axes ) ) { // when coordinates of more than two axes were given
            coords_other_than_primary_axis.push( ... coord_other_axes );
        } else { // when only secondary axis was given
            coords_other_than_primary_axis.push( coord_other_axes );
        }
    }
    // sort 'l_int_index
    l_int_index = l_int_index.sort( sort_number );

    async function _filter_a_portion_of_zarr_object( int_index_start, int_index_end, za, l_int_index, coords_other_than_primary_axis ) {
        // retrieve data for a portion of zarr object, filter using the given ba_filter, and return filtered records
        let coords = [ zarr.slice( int_index_start, int_index_end ) ];
        coords.push( ... coords_other_than_primary_axis ); // combine coordinates of all axes
        
        // fetch data
        let arr = await za.get( coords );
        
        // initialize the output, filtered array
        let dtype = arr.dtype, // retrieve dtype of the array
            l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
            int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry
            int_num_active_entries_in_a_batch = l_int_index.length,
            l_dims_filtered = [ int_num_active_entries_in_a_batch ];
        l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis

        arr = arr.flatten( ); // flatten the array
        let int_num_bytes_for_a_value = arr.byteLength / arr.length; // retrieve the number of bytes for each value

        let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * int_num_active_entries_in_a_batch ) ), // initialize the typedarray that will contain the output, filtered data
            int_index_entry_after_filtering = 0; 

        for ( let int_index of l_int_index ) {
            arr_filtered.set( arr.slice( int_num_values_for_an_entry * ( int_index - int_index_start ), int_num_values_for_an_entry * ( int_index - int_index_start + 1 ) ), int_num_values_for_an_entry * int_index_entry_after_filtering )
            int_index_entry_after_filtering += 1; // update 'int_index_entry_after_filtering'
        }
        // return the filtered array as a nested array
        return new zarr.NestedArray( arr_filtered, l_dims_filtered );
    }

    let l_promise_filtered = [ ], // initialize a list of promises that will contain filtered results
        l_int_index_of_a_chunk = [ ],
        int_index_chunk_current = undefined;
    for ( let int_index of l_int_index ) {
        // retrieve 'int_index_chunk' of the current int_index
        let int_index_chunk = parseInt( int_index / int_num_entries_in_a_chunk );
        // when chunk boundary has been crossed, flush batch and update the chunk boundary
        if ( int_index_chunk != int_index_chunk_current ) {
            // flush batch
            if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
                l_promise_filtered.push( _filter_a_portion_of_zarr_object( int_index_chunk_current * int_num_entries_in_a_chunk, ( int_index_chunk_current + 1 ) * int_num_entries_in_a_chunk, za, l_int_index_of_a_chunk, coords_other_than_primary_axis ) );
                l_int_index_of_a_chunk = [ ]; // initialize the next batch
            } 
            // update 'int_index_chunk_current'
            int_index_chunk_current = int_index_chunk; 
        }
        // collect 'int_index'
        l_int_index_of_a_chunk.push( int_index ); // initialize the next batch
    }
    // flush batch
    if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
        l_promise_filtered.push( _filter_a_portion_of_zarr_object( int_index_chunk_current * int_num_entries_in_a_chunk, ( int_index_chunk_current + 1 ) * int_num_entries_in_a_chunk, za, l_int_index_of_a_chunk, coords_other_than_primary_axis ) );
        l_int_index_of_a_chunk = [ ]; // initialize the next batch
    } 
    
    // collect filtered results for each valid chunk
    let l_arr_filtered = await Promise.all( l_promise_filtered ),
        arr = l_arr_filtered[ 0 ]; // retrieve the first filtered result to gather information about the returned results

    // initialize the output that will contain the combined filtered array
    let dtype = arr.dtype, // retrieve dtype of the array
        l_dims_excluding_primary_axis = arr.shape.slice( 1, arr.shape.length ), // retrieve dimensions of the axes excluding the primary axis
        int_num_values_for_an_entry = ( l_dims_excluding_primary_axis.length > 0 ) ? l_dims_excluding_primary_axis.reduce( ( a, b ) => a * b ) : 1, // retrieve the number of values for each entry
        l_dims_filtered = [ l_int_index.length ];
    l_dims_filtered.push( ... l_dims_excluding_primary_axis ); // retrieve dimensions of the axes other than the primary axis

    arr = arr.flatten( ); // flatten the first filtered array
    let int_num_bytes_for_a_value = arr.byteLength / arr.length; // retrieve the number of bytes for each value

    let arr_filtered = new arr.constructor( new ArrayBuffer( int_num_bytes_for_a_value * int_num_values_for_an_entry * l_int_index.length ) ), // initialize the typedarray that will contain the output, filtered data
        int_num_values_copied = 0; 

    // iterate through each filtered result and combine data
    for ( let i = 0; i < l_arr_filtered.length; i ++ ) {
        let arr = l_arr_filtered[ i ].flatten( ); // retrieve a filtered result and flatten the nested array
        arr_filtered.set( arr, int_num_values_copied ) // copy the filtered result of a chunk to the combined result
        int_num_values_copied += arr.length; // update 'int_num_values_copied'
    }
    // return the filtered array as a nested array
    return new zarr.NestedArray( arr_filtered, l_dims_filtered );
}
class StringZarr {
    /*
    a stringzarr object contains 2D-array of strings of variable length with chunk shape of ('int_num_of_entries_in_a_chunk', 1), meaning each chunk contains values of a single column
    */
    constructor( path_folder, verbose = true ) {
        // set attributes
        this.path_folder = path_folder;
        this.verbose = verbose;
        // initialize attributes
    }
    async initialize( ) {
        // load metadata of the object
        // should be run before using the object
        let zattrs = await $.getJSON( `${this.path_folder}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        
        // set attributes
        this.int_num_entries = this.metadata[ 'int_num_entries' ]
        this.int_num_of_entries_in_a_chunk = this.metadata[ 'int_num_of_entries_in_a_chunk' ]
        
        this.length = this.int_num_entries;
    }
    async get_by_l_int_index( l_int_index, int_index_column = 0 ) {
        /*
        'l_int_index' list of integer indices for retrieving data. the indices WILL BE SORTED!, and the list of returned values will contains the list of sorted indices.
        'int_index_column' : the index of the column for retrieving data
        */
        // prepare (retrieve the number of entries in the primary axis of a chunk
        let int_num_entries_in_a_chunk = this.int_num_of_entries_in_a_chunk;

        // sort 'l_int_index
        l_int_index = l_int_index.sort( sort_number );

        async function _filter_a_portion_of_stringzarr_object( int_index_chunk_row, stringzarr, l_int_index, int_index_chunk_column ) {
            // fetch data
            let arr = await stringzarr.load_a_chunk( int_index_chunk_row, int_index_chunk_column ),
                int_num_active_entries_in_a_batch = l_int_index.length,
                arr_filtered = [ ], // initialize an array that will contain the filtered data
                int_index_start = int_index_chunk_row * stringzarr.int_num_of_entries_in_a_chunk;
            
            // filter data
            for ( let int_index of l_int_index ) {
                arr_filtered.push( arr[ int_index - int_index_start ] );
            }
            // return the filtered array as a nested array
            return arr_filtered;
        }

        let l_promise_filtered = [ ], // initialize a list of promises that will contain filtered results
            l_int_index_of_a_chunk = [ ],
            int_index_chunk_current = undefined;
        for ( let int_index of l_int_index ) {
            // retrieve 'int_index_chunk' of the current int_index
            let int_index_chunk = parseInt( int_index / int_num_entries_in_a_chunk );
            // when chunk boundary has been crossed, flush batch and update the chunk boundary
            if ( int_index_chunk != int_index_chunk_current ) {
                // flush batch
                if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
                    l_promise_filtered.push( _filter_a_portion_of_stringzarr_object( int_index_chunk_current, this, l_int_index_of_a_chunk, int_index_column ) );
                    l_int_index_of_a_chunk = [ ]; // initialize the next batch
                } 
                // update 'int_index_chunk_current'
                int_index_chunk_current = int_index_chunk; 
            }
            // collect 'int_index'
            l_int_index_of_a_chunk.push( int_index ); // initialize the next batch
        }
        // flush batch
        if ( ( l_int_index_of_a_chunk.length > 0 ) & ( int_index_chunk_current !== undefined ) ) {
            l_promise_filtered.push( _filter_a_portion_of_stringzarr_object( int_index_chunk_current, this, l_int_index_of_a_chunk, int_index_column ) );
            l_int_index_of_a_chunk = [ ]; // initialize the next batch
        } 

        // collect filtered results for each valid chunk
        let l_arr_filtered = await Promise.all( l_promise_filtered ),
            arr_filtered = [ ]; // initialize the typedarray that will the output values

        // iterate through each filtered result and combine data
        for ( let i = 0; i < l_arr_filtered.length; i ++ ) {
            arr_filtered.push( ... l_arr_filtered[ i ] ); // retrieve a filtered result
        }
        // return the filtered array
        return arr_filtered;
    }
    parse_chunk( file ) { 
        /*
        retrieve data of a chunk
        */
        return new Promise ( function( resolve, reject ) {
            fetch( file )
                .then( ( response ) => {
                  return response.text( );
               }).then( ( text_base64 ) => {
                  return ParseBase64GzippedText( text_base64 );
               }).then( ( text ) => {
                let arr = text.split( '\n' );
                arr = arr.slice( 0, arr.length - 1 );
                resolve( arr );
               }).catch( err => { reject } );
        });
    }
    async load_a_chunk( index_chunk_row, index_chunk_col = 0 ) {
        /*
        load data of a chunk of 'index_chunk_row' and 'index_chunk_col'
        */
        return await this.parse_chunk( `${this.path_folder}${index_chunk_row}.${index_chunk_col}` );
    }
    async load_all_data( ) {
        let l_file = [ `${this.path_folder}8.0`, `${this.path_folder}7.0`, `${this.path_folder}6.0` ];
        let l_promise = l_file.map( function( file ) { 
            return new Promise ( function( resolve, reject ) {
                fetch( file )
                    .then( ( response ) => {
                      return response.text( );
                   }).then( ( text_base64 ) => {
                      return ParseBase64GzippedText( text_base64 );
                   }).then( ( text ) => {
                    let arr = text.split( '\n' );
                    arr = arr.slice( 0, arr.length - 1 );
                    resolve( arr );
                   }).catch( err => { reject } );
            });
        }); // 'skipEmptyLines' is set to false to allow reading empty lines in some input files // due to 'skipEmptyLines: false' option, the last line is empty, and should be discarded
        let results = await Promise.all( l_promise ); // wait until all files have been parsed 
        let l_parsed_data = [ ]; 
        l_parsed_data.push( ... results );
        return l_parsed_data;
    }
}
class RAMtx {
    constructor( path_folder_ramtx, ramdata = undefined, verbose = true, flag_debugging = false ) {
        // these values will be fixed: dtype_of_feature_and_barcode_indices = np.uint32, dtype_of_values = np.float64
        // set attributes
        this.path_folder_ramtx = path_folder_ramtx;
        this._ramdata = ramdata;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        
        // set filters using the given RamData
        this.ba_filter_features = check_none( this._ramdata ) ? undefined : this._ramdata.ft.filter;
        this.ba_filter_barcodes = check_none( this._ramdata ) ? undefined : this._ramdata.bc.filter;
    }
    async initialize( ) {
        // 2023-07-12
        // initialize RAMtx
        // load metadata of RAMtx and zarr objects containing sparse data
        // should be run before using RAMtx
        let zattrs = await $.getJSON( `${this.path_folder_ramtx}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        
        // set attributes
        this.flag_ramtx_sorted_by_id_feature = this.metadata[ 'flag_ramtx_sorted_by_id_feature' ];
        this._int_num_barcodes = this.metadata[ 'int_num_barcodes' ];
        this._int_num_features = this.metadata[ 'int_num_features' ];
        this._int_num_records = this.metadata[ 'int_num_records' ];
        this.mode = this.metadata[ 'mode' ];

        this.is_for_querying_features = this.flag_ramtx_sorted_by_id_feature;
        
        // # open zarr objects asynchronously // currently only support dense matrix
        this.is_sparse = this.mode != 'dense' 
        if ( this.is_sparse ) {
            // collect promises for the Zarr Arrays
            let l_promise = [ ]; 
            l_promise.push( zarr.openArray( { store : this.path_folder_ramtx, path : `matrix.index.zarr/`, mode: "r" } ) );
            l_promise.push( zarr.openArray( { store : this.path_folder_ramtx, path : `matrix.zarr/`, mode: "r" } ) );
            let res = await Promise.all( l_promise ); // wait until all zarr arrays to load
            this._za_mtx_index = res[ 0 ];
            this._za_mtx = res[ 1 ];
        }
    }
    async load_ba_active_entries( ) {
        // load 'ba_active_entries'
        let name_axis_for_querying = this.flag_ramtx_sorted_by_id_feature ? 'features' : 'barcodes',
            za_ba_active_entries = await zarr.openArray({
            store : this.path_folder_ramtx,
            path : `matrix.${name_axis_for_querying}.active_entries.zarr/`,
            mode: "r"
        });
        // if binary data encoded in '|i1' format ('b1') format was detected, change dtype to '|i1', since '|b1' is currently not supported in the Zarr.js implementation
        if ( za_ba_active_entries.meta.dtype == '|b1' ) {
            za_ba_active_entries.meta.dtype = '|i1'; // change dtype to '|i1'
        }
        this.ba_active_entries = to_ba( await za_ba_active_entries.get( null ) ); // retrieve a filter of active entries
    }
    get int_num_barcodes( ) {
        return this._int_num_barcodes;
    }
    get int_num_features( ) {
        return this._int_num_features;
    }
    get int_num_records( ) {
        return this._int_num_records;
    }
    async get_item( l_int_entry ) {
        /*
        get sparse data for the given list of 'l_int_entry'
        */
        // get expression of a list of int_entry
        // initialize the object if metadata has not been loaded
        if ( check_none( this.metadata ) ) {
            await this.initialize( );
        }

        // initialize the output data structures
        let l_int_entry_of_axis_for_querying = [ ], 
            l_arr_int_entry_of_axis_not_for_querying = [ ], 
            l_arr_value = [ ];

        // wrap in a list if a single entry was queried
        if ( ! Array.isArray( l_int_entry ) ) { // check whether the given entry is not an array
            l_int_entry = [ l_int_entry ];
        }

        // retrieve flag indicating an empty input
        let flag_empty_input = l_int_entry.length == 0;

        // retrieve zarr objects
        let za_mtx = this._za_mtx,
            za_mtx_index = this._za_mtx_index;

        // internal settings
        let int_num_chunks_for_a_batch = 2 // number of chunks in a batch for retrieving data for the sparse matrix // retrieve entries that are situated closely together

        // retrieve filters 
        let is_for_querying_features = this.is_for_querying_features,
            ba_filter_axis_for_querying = ( is_for_querying_features ) ? this.ba_filter_features : this.ba_filter_barcodes, 
            ba_filter_not_axis_for_querying = ( is_for_querying_features ) ? this.ba_filter_barcodes : this.ba_filter_features,
            int_num_entries_axis_for_querying = ( is_for_querying_features ) ? this._ramdata.ft.int_num_entries : this._ramdata.bc.int_num_entries; // retrieve the number of entries for the axis for querying

        // create view 
        // retrieve dictionaries for changing coordinates
        // initialize the dictionaries
        let dict_change_int_entry_of_axis_for_querying = undefined,
            dict_change_int_entry_of_axis_not_for_querying = undefined;
        if ( ! check_none( this._ramdata ) ) { // if RAMtx has been attached to RamData, retrieve dictionaries that can be used to change coordinate
            let ram = this._ramdata; // retrieve ramdata from which view will be retrieved. if current RAMtx is component, use composite RamData. else, use RamData to which current RAMtx has been attached to.
            if ( this.is_for_querying_features ) {
                dict_change_int_entry_of_axis_for_querying = ram.ft.dict_change
                dict_change_int_entry_of_axis_not_for_querying = ram.bc.dict_change
            } else {
                dict_change_int_entry_of_axis_for_querying = ram.bc.dict_change
                dict_change_int_entry_of_axis_not_for_querying = ram.ft.dict_change
            }
        }

        // compose a vectorized function for the conversion of int_entries of the non-indexed axis.
        let vchange_int_entry_of_axis_not_for_querying = undefined;
        if ( ! check_none( dict_change_int_entry_of_axis_not_for_querying ) ) {
            vchange_int_entry_of_axis_not_for_querying = ( arr ) => {
                /*
                arr : typed array
                */
                let arr_changed = new arr.constructor( new ArrayBuffer( arr.buffer.byteLength ) ); // initialize an empty typed array with the same type length 
                for ( let i = 0; i < arr.length; i ++ ) {
                    arr_changed[ i ] = dict_change_int_entry_of_axis_not_for_querying[ arr[ i ] ];
                }
                return arr_changed;
            }
        }

        // retrieve filtered 'l_int_entry'
        if ( ! check_none( ba_filter_axis_for_querying ) ) { // if 'ba_filter_axis_for_querying' is validz
            let l_int_entry_filtered = [ ];
            if ( flag_empty_input ) {
                // ''' handle when empty 'l_int_entry' has been given and filter has been set  '''
                l_int_entry_filtered = ba_to_integer_indices( ba_filter_axis_for_querying, int_num_entries_axis_for_querying );
            } else {
                // filter 'l_int_entry' according to 'ba_filter_axis_for_querying'
                for ( let int_entry of l_int_entry ) {
                    if ( ba_filter_axis_for_querying.get( int_entry ) > 0 ) {
                        l_int_entry_filtered.push( int_entry );
                    }
                }
            }
            l_int_entry = l_int_entry_filtered; // use filtered 'l_int_entry' as 'l_int_entry'
        }

        // if no valid entries are available, return an empty result
        if ( l_int_entry.length == 0 ) {
            return [ l_int_entry_of_axis_for_querying, l_arr_int_entry_of_axis_not_for_querying, l_arr_value ];
        }

        // sort 'int_entry' so that closely located entries can be retrieved together
        // sort indices of entries so that the data access can occur in the same direction
        let int_num_entries = l_int_entry.length;
        l_int_entry = l_int_entry.sort( sort_number );

        // single thread mode
        /* # 2022-08-16 01:54:31 
        retrieve data as a worker in a worker process or in the main processs (in single-process mode)
        */
        // initialize 

        function _process_entry( int_entry, arr_int_entry_of_axis_not_for_querying, arr_value ) {
            /* # 2022-07-30 22:07:46 
            process retrieve data. apply filter and change coordinates
            */
            // if a filter for not-indexed axis has been set, apply the filter to the retrieved records
            if ( ! check_none( ba_filter_not_axis_for_querying ) ) {                
                // create empty arrays
                let arr_int_entry_of_axis_not_for_querying_filtered = [ ],
                    arr_value_filtered = [ ];

                // iterate through each record
                for ( let i = 0; i < arr_value.length; i ++ ) {
                    // check whether the current int_entry is included in the filter
                    if ( ba_filter_not_axis_for_querying.get( arr_int_entry_of_axis_not_for_querying[ i ] ) > 0 ) { 
                        // include the record
                        arr_int_entry_of_axis_not_for_querying_filtered.push( arr_int_entry_of_axis_not_for_querying[ i ] );
                        arr_value_filtered.push( arr_value[ i ] );
                    }
                }

                // if no valid data exists (all data were filtered out), continue to the next 'int_entry'
                if ( arr_value_filtered.length == 0 ) {
                    return;
                }

                // convert arrays to typed arrays
                arr_int_entry_of_axis_not_for_querying = new arr_int_entry_of_axis_not_for_querying.constructor( arr_int_entry_of_axis_not_for_querying_filtered );
                arr_value = new arr_value.constructor( arr_value_filtered );
            }

            // apply view
            if ( ! check_none( dict_change_int_entry_of_axis_for_querying ) ) {
                int_entry = dict_change_int_entry_of_axis_for_querying[ int_entry ]
            }
            // convert int_entry for the non-indexed axis if a mapping has been given (create view)
            if ( ! check_none( vchange_int_entry_of_axis_not_for_querying ) ) {
                arr_int_entry_of_axis_not_for_querying = vchange_int_entry_of_axis_not_for_querying( arr_int_entry_of_axis_not_for_querying )
            }

            // append the retrieved data to the output results 
            l_int_entry_of_axis_for_querying.push( int_entry ); 
            l_arr_int_entry_of_axis_not_for_querying.push( arr_int_entry_of_axis_not_for_querying );
            l_arr_value.push( arr_value );
        }
        async function __fetch_from_sparse_ramtx( l_int_entry_in_a_batch, l_index_in_a_batch ) {
            /* # 2022-07-30 22:32:14 
            fetch data from sparse ramtx for a batch
            */
            ba_filter_not_axis_for_querying instanceof BitSet; // use 'ba_filter_not_axis_for_querying' in the subsequent scopes

            let st_batch = l_index_in_a_batch[ 0 ][ 0 ], // retrieve start and end positions of the current batch
                en_batch = l_index_in_a_batch[ l_index_in_a_batch.length - 1 ][ 1 ],
                arr = await za_mtx.get( zarr.slice( st_batch, en_batch ) ), // fetch data from the Zarr object
                arr_int_entry_of_axis_not_for_querying = arr.get( [ null, 0 ] ), // retrieve nested array of each component
                arr_value = arr.get( [ null, 1 ] );

            for ( let i = 0; i < l_index_in_a_batch.length; i ++ ) { // iterate over each entry
                let int_entry = l_int_entry_in_a_batch[ i ],
                    index = l_index_in_a_batch[ i ],
                    st = index[ 0 ] - st_batch, // substract the start position of the batch to retrieve the local index
                    en = index[ 1 ] - st_batch,
                    sl = zarr.slice( st, en ); // retrieve a slice object for the current entry
                _process_entry( int_entry, arr_int_entry_of_axis_not_for_querying.get( sl ).flatten( ), arr_value.get( sl ).flatten( ) );
            }
        }
        // retrieve data
        // handle sparse ramtx
        // %% Sparse ramtx %% 
        // prepare
        let int_num_records_in_a_chunk = za_mtx.meta.chunks[ 0 ], // retrieve the number of records in a chunk
            index_chunk_start_current_batch = undefined, // initialize the index of the chunk at the start of the batch
            l_int_entry_in_a_batch = [ ],
            l_index_in_a_batch = [ ], // several entries will be processed together as a batch if they reside in the same or nearby chunk ('int_num_chunks_for_a_batch' setting)
            arr_index = await zarr_get_by_l_int_index( za_mtx_index, l_int_entry ), // retrieve arr_index of the given list of 'int_entry'
            l_promise_batch = [ ]; // list of promisess for batches

        // iterate through each 'int_entry'
        for ( let i = 0; i < l_int_entry.length; i ++ ) { // iterate through each entry
            // retrieve mtx_index data and remove invalid entries
            let int_entry = l_int_entry[ i ];
            let index = arr_index.get( i ).flatten( ), // retrieve mtx_index data 
                st = index[ 0 ],
                en = index[ 1 ];
            if ( st == en ) { // if there is no count data for the 'int_entry', continue on to the next 'int_entry' # drop 'int_entry' lacking count data (when start and end index is the same, the 'int_entry' does not contain any data)
                continue
            }

            // if batch is full, flush the batch 
            let index_chunk_end = Math.floor( ( en - 1 ) / int_num_records_in_a_chunk ); // retrieve the index of the last chunk
            if ( ( index_chunk_start_current_batch !== undefined ) & ( index_chunk_end >= index_chunk_start_current_batch + int_num_chunks_for_a_batch ) ) { // if start has been set 
                l_promise_batch.push( __fetch_from_sparse_ramtx( l_int_entry_in_a_batch, l_index_in_a_batch ) );
                // initialize the next batch
                l_int_entry_in_a_batch = [ ]; 
                l_index_in_a_batch = [ ];
                index_chunk_start_current_batch = undefined; // reset start
            }
            // start the batch 
            // if start has not been set, set the start of the current batch
            if ( index_chunk_start_current_batch === undefined ) { // start the batch
                index_chunk_start_current_batch = Math.floor( st / int_num_records_in_a_chunk );
            }

            // add int_entry to the batch 
            l_int_entry_in_a_batch.push( int_entry ) 
            l_index_in_a_batch.push( [ st, en ] )
        }
        if ( l_int_entry_in_a_batch.length > 0 ) { // if some entries remains unprocessed, flush the buffer
            l_promise_batch.push( __fetch_from_sparse_ramtx( l_int_entry_in_a_batch, l_index_in_a_batch ) );
        }
        
        await Promise.all( l_promise_batch ); // wait until all batches become completed

        // return the retrieved data
        return [ l_int_entry_of_axis_for_querying, l_arr_int_entry_of_axis_not_for_querying, l_arr_value ];
    }
    async get_sparse_matrix( l_int_entry ) {
        /* # 2022-08-30 11:03:14 
        
        get sparse matrix for the given list of integer representations of the entries.
        
        'l_int_entry' : list of int_entries for query
        'flag_return_as_arrays' : if True, return three arrays and a single list, 'l_int_barcodes', 'l_int_features', 'l_values', 'l_int_num_records'. 
                'l_int_barcodes', 'l_int_features', 'l_values' : for building a sparse matrix
                'l_int_num_records' : for building an index
                if False, return a scipy.csr sparse matrix
        */
        // return data as a sparse matrix
        return new SparseMatrix( await this.get_item( l_int_entry ), check_none( this._ramdata ) ? [ this._int_num_barcodes, this._int_num_features ] : [ this._ramdata.bc.length, this._ramdata.ft.length ], ! this.flag_ramtx_sorted_by_id_feature, this.verbose ); // convert count data to a sparse matrix // feature = secondary axis, barcode = primary axis
    }
}
class RamDataAxis {
    constructor( path_folder, name_axis, ba_filter = undefined, ramdata = undefined, dict_kw_zdf = { 'flag_retrieve_categorical_data_as_integers' : false }, dict_kw_view = { 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' : 0.1 }, int_index_str_rep = 0, verbose = true, flag_debugging = false ) {
        // set attributes
        this.path_folder = path_folder;
        this._path_folder = path_folder;
        this._name_axis = name_axis;
        this.filter = ba_filter;
        this._ramdata = ramdata;
        this.dict_kw_zdf = dict_kw_zdf;
        this.dict_kw_view = dict_kw_view;
        this.int_index_str_rep = int_index_str_rep;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        // initialize viewer (coordinate converter, a dictionary for converting coordinates) 
        this.dict_change = undefined ;
        this._dict_change_backup = undefined;
    }
    async initialize( ) {
        // initialize RamDataAxis
        // initialize the mapping dictionaries
        this._dict_str_to_i = undefined; 
        this._dict_i_to_str = undefined; 
        
        // open a ZarrDataFrame with a given filter
        this.meta = new ZarrDataFrame( 
            `${this.path_folder}${this._name_axis}.num_and_cat.zdf/`, 
            this.filter, 
            this.dict_kw_zdf[ 'flag_retrieve_categorical_data_as_integers' ],
            this.verbose
        );
        await this.meta.initialize( ); // initialize the ZarrDataFrame object
        // retrieve number of entries
        this.int_num_entries = this.meta._n_rows_unfiltered;
        
        // load string representations of the entries of the axis
        this._sza = new StringZarr( `${this._path_folder}${this._name_axis}.str.chunks/`, this.verbose );
        await this._sza.initialize( ); // initialize the stringzarr object
    }
    set_filter( ba_filter ) {
        /* 
        set filter for the axis
        */       
        function change_filter( ax ) {
            // set filter of the ZarrDataFrame
            ax.meta.set_filter( ax.filter );
            
            // set filter of the layer if a layer has been loaded
            if ( ! check_none( ax._ramdata ) ) {
                if ( ! check_none( ax._ramdata.layer ) ) {
                    ax._ramdata.layer.set_filter( ax.filter, ax._name_axis == 'features' ); // set filter of the axis
                }
            }
        }
        
        // if filter is removed
        if ( check_none( ba_filter ) ) {
            this.filter = undefined;
            change_filter( this ); // change filters 
            return;
        }
        
        // if BitSet object is given, set the filter and exit
        if ( ba_filter instanceof BitSet ) {
            this.filter = ba_filter;
            change_filter( this ); // change filters 
            return;
        }
            
        // if 'NestedArray' is given, check shape and flatten the array
        if ( ba_filter instanceof zarr.NestedArray ) {
            // if a given 'ba_filter' is a NestedArray, check its shape (the length of the filter should be same as the number of rows of the current object)
            if ( ! ( ba_filter.shape.length == 1 & ba_filter.shape[ 0 ] == this.int_num_entries ) ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
            ba_filter = ba_filter.flatten( ); // flatten the nested array

        } else if ( ba_filter instanceof Int8Array ) {
            // if flattened 'Int8Array' is given, check shape
            // if the length of the given array is different from the number of rows of the object
            if ( ba_filter.length != this.int_num_entries ) {
                if ( this.verbose ) {
                    console.log( "the shape of the given filter is invalid, exiting" );
                }
                return;
            }
        } else {
            if ( this.verbose ) {
                console.log( "the data type of the given 'ba_filter' object is not supported, exiting" );
            }
            return;
        }
        // initialize BitSet object
        let ba = new BitSet,
            i = 0,
            val = 0;
        // set BitSet object
        for ( i = 0; i < ba_filter.length ; i ++ ) {
            val = ba_filter[ i ];
            if ( val != 0 ) {
                ba.set( i, 1 )
            }
        }
        
        // set filter for the object
        this.filter = ba;
        change_filter( this ); // change filters 
    }
    create_view( ) {
        /*
        create the view of the axis
        
        build 'dict_change' (dictionaries for conversion of coordinates) from the given filter, creating a view of the current 'Axis'
        automatically set filter using the mask containing all active entries with valid data if filter is not active
        
        for example, when filter is 
         0123456789  - index
        '1000101110' - filter 
        
        then, dict_change will be { 0 : 0, 4 : 1, 6 : 2, 7 : 3, 8 : 4 }
        when the number of active entries in an exis > 10% (or above any proportion that can set by 'float_min_proportion_of_active_entries_in_an_axis_for_using_array'), an array with the same length will be used for the conversion of coordinates
        
        'float_min_proportion_of_active_entries_in_an_axis_for_using_array' : a threshold for the transition from dictionary to array for the conversion of coordinates. empirically, dictionary of the same length takes about ~10 times more memory than the array
        'dtype' : dtype of array that will be used as 'dictionary'
        index_component : Union[ None, int ] = None : the index of a component RamData to retrieve view.
        
        */
        // retrieve settings to create a view
        let float_min_proportion_of_active_entries_in_an_axis_for_using_array = ( 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' in this.dict_kw_view ) ? this.dict_kw_view[ 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' ] : 0.1;

        // initialize 'dict_change'
        let dict_change = undefined,
            ba = this.filter;
        if ( ( ! check_none( ba ) ) & ( this.meta._n_rows_after_applying_filter < this.int_num_entries ) ) { // only build 'dict_change' if a filter is active or at least one entry is not active
            // count the number of active entries in the given filter
            let n = this.meta._n_rows_unfiltered,
                n_active_entries = count_ba( ba, n );
            
            // initialize dictionary
            // implement a dictionary using an array if the proportion of active entries in the axis is larger than the given threshold to reduce the memory footprint and increase the efficiency of conversion process
            dict_change = ( ( n_active_entries / n ) > float_min_proportion_of_active_entries_in_an_axis_for_using_array ) ? new Int32Array( new ArrayBuffer( 4 * n ) ) : { }; // 4 bytes (Int32 arrays) for building 'dict_change'
            
            let i = 0; // initialize active entry counter
            for ( let int_index of ba_to_integer_indices( ba, n ) ) { // iterate through 'int_entry' of the active entries
                dict_change[ int_index ] = i; // retrieve active_entry > i mapping
                i ++; // increase index
            }
        }
        this.dict_change = dict_change; // load 'dict_change'
    }
    destroy_view( ) {
        /* # 2022-07-16 15:23:01 
        unload 'this.dict_change' (dictionaries for conversion of coordinates), destroying the current view
        */
        this.dict_change = undefined;
    }
    backup_view( ) {
        /* # 2022-08-20 17:25:12 
        backup view
        */
        this._dict_change_backup = this.dict_change; // back up view
        this.destroy_view( ); // destroy view
    }
    restore_view( ) {
        /* # 2022-08-20 17:25:12 
        restore view
        */
        this.dict_change = this._dict_change_backup;
        this._dict_change_backup = undefined;
    }
    none( ) {
        /* # 2022-09-08 11:30:33 
        return an empty bitarray filter
        */
        ba = new BitSet( );
        return ba
    }
    exclude( filter_to_exclude ) {
        /* # 2022-09-14 00:12:48 
        exclude entries in the given filter 'filter_to_exclude' from the current filter
        */
        // exclude the entries in 'filter_to_exclude'
        this.set_filter( this.filter.andNot( filter_to_exclude ) );
    }
    all( flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-09-02 00:33:56 
        return bitarray filter with all entries marked 'active'
        
        'flag_return_valid_entries_in_the_currently_active_layer' : return bitarray filter containing only the active entries in the current layer 
        */
        let ba;
        if ( flag_return_valid_entries_in_the_currently_active_layer & ( ! check_none( this._ramdata ) ) & ( ! check_none( this._ramdata.layer ) ) ) { // if RamData has an active layer and 'flag_return_valid_entries_in_the_currently_active_layer' setting is True, return bitarray where entries with valid count data is marked as '1' # if valid ramtx data is available
            let rtx = this._ramdata.layer.get_ramtx( this._name_axis == 'features' ); // retrieve associated ramtx object
            if ( ! check_none( rtx ) ) {
                ba = rtx.ba_active_entries;
                return ba;
            }
        }
        // if layer is empty or 'flag_return_valid_entries_in_the_currently_active_layer' is False, just return a bitarray filled with '1'
        ba = new BitSet( );
        ba.setRange( 0, this.int_num_entries, 1 ); // set all entries as 'active' 
        return ba; // return the bitarray filter
    }
    get_ba_active_entries( flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-07-16 17:38:04 
        
        return a bitarray object containing currently active entries in the Axis. 
        if a filter is active, return the current filter
        if a filter is not active, return the return value of Axis.all( flag_return_valid_entries_in_the_currently_active_layer )
        
        'flag_return_valid_entries_in_the_currently_active_layer' : return bitarray filter containing only the active entries in the current layer 
        */
        return check_none( this.filter ) ? this.all( flag_return_valid_entries_in_the_currently_active_layer ) : this.filter;
    }
    subsample( float_prop_subsampling = 1, flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-07-16 17:12:19 
        subsample active entries in the current filter (or all the active entries with valid data) using the proportion of subsampling ratio 'float_prop_subsampling'
        
        'flag_return_valid_entries_in_the_currently_active_layer' : return bitarray filter containing only the active entries in the current layer 
        */
        // retrieve bitarray of active entries
        let ba_active_entries = this.get_ba_active_entries( flag_return_valid_entries_in_the_currently_active_layer );
        
        // return the bitarray of all active entries if no subsampling is required
        if ( check_none( float_prop_subsampling ) | ( float_prop_subsampling == 1 ) ) {
            return ba_active_entries;
        }
        
        // initialize the output bitarray filter that will contain subsampled entries
        let ba_subsampled = new BitSet( ); 
        
        // perform subsampling
        for ( let i = 0; i < this.int_num_entries; i ++ ) { // iterate over each entry
            if ( ( ba_active_entries.get( i ) > 0 ) & ( Math.random( ) < float_prop_subsampling ) ) { // determine whether an active entry should be included in the subsampled set.
                ba_subsampled.set( i, 1 ); 
            }
        }

        // return subsampled entries
        return ba_subsampled;
    }
    async change_filter( name_col_filter ) {
        /* # 2022-07-16 17:17:29 
        change filter using the filter saved in the metadata with 'name_col_filter' column name. if 'name_col_filter' is not available, current filter setting will not be changed.
        
        'name_col_filter' : name of the column of the metadata ZarrDataFrame containing the filter
        */
        if ( this.meta.columns.has( name_col_filter ) ) { // if a given column name exists in the current metadata ZarrDataFrame
            this.set_filter( await this.meta.get_item( name_col_filter, [ null ] ) ); // retrieve filter from the storage and apply the filter to the axis
        }
    }
    async get_str( queries = undefined, int_index_col = undefined ) {
        /* # 2022-09-22 12:07:01 
        get string representations of the queries
        
        'queries' : queries (list of integer indices) of the entries for which string representations will be loaded. if None is given, all entries will be retrieved.
        int_index_col : Union[ int, None ] = None : the index of the column containing string representation to retrieve. if a single integer index is given, retrieve values from a single column. If a list or a tuple of integer indices are given, values of the columns will be retrieved.
        */
        // retrieve all entries for the 'default' queries
        if ( check_none( queries ) ) {
            queries = nj.arange( this.int_num_entries ).tolist( );
        }
        // set default value for 'int_index_col'
        if ( check_none( int_index_col ) ) {
            int_index_col = this.int_index_str_rep;
        }
        // open a zarr object containing the string representation of the entries
        if ( ! check_none( this._sza ) ) {
            return await this._sza.get_by_l_int_index( queries, int_index_col );
        }
    }
    iterate_str( int_num_entries_in_a_batch= 1000, int_index_col = undefined ) {
        /* # iterate through string representations of the active entries of the current axis object
        
        int_num_entries_in_a_batch : int = 1000 # the number of entries that will be included in a batch
        int_index_col : Union[ int, None ] = None : the index of the column containing string representation to retrieve. if a single integer index is given, retrieve values from a single column. If a list or a tuple of integer indices are given, values of the columns will be retrieved.
        */
        return async function* makeIterator( ) { // return an iterator
            let l_int_entry_in_a_batch = [ ] // initialize a batch container 
            for ( let int_entry of ( check_none( this.filter ) ? nj.arange( this.int_num_entries ).tolist( ) : ba_to_integer_indices( this.filter, this.int_num_entries ) ) ) { // iterate through integer indices of the active entries
                l_int_entry_in_a_batch.push( int_entry );
                // if a batch is full, flush the batch
                if ( l_int_entry_in_a_batch.length >= int_num_entries_in_a_batch ) {
                    let arr = await this.get_str( l_int_entry_in_a_batch, int_index_col );
                    yield { 'l_int_entry' : l_int_entry_in_a_batch, 'l_str_entry' : arr };
                    l_int_entry_in_a_batch = [ ]; // initialize the next batch
                }
            }
            // if there are remaining entries, flush the batch
            if ( l_int_entry_in_a_batch.length > 0 ) {
                let arr = await this.get_str( l_int_entry_in_a_batch, int_index_col );
                yield { 'l_int_entry' : l_int_entry_in_a_batch, 'l_str_entry' : arr };
            }
        }( );
    }
    async load_str( int_index_col = undefined ) {
        /* # 2022-09-12 02:28:49 
        load string representation of all the active entries of the current axis, and retrieve a mapping from string representation to integer representation
        
        'int_index_col' : default value is 'this.int_index_str_rep'
        */
        // set default value for 'int_index_col'
        if ( check_none( int_index_col ) ) {
            int_index_col = this.int_index_str_rep;
        }
        
        // compose a pair of dictionaries for the conversion
        let arr_int_entry = check_none( this.filter ) ? nj.arange( this.int_num_entries ).tolist( ) : ba_to_integer_indices( this.filter, this.int_num_entries ), // retrieve integer representations of the entries
            arr_str = await this.get_str( arr_int_entry, int_index_col ); // retrieve string representations of the entries
        
        // build mapping
        let dict_str_to_i = { },
            dict_i_to_str = { };
        for ( let i = 0; i < arr_int_entry.length; i ++ ) {
            let int_entry = arr_int_entry[ i ],
                str_entry = arr_str[ i ];
            dict_str_to_i[ str_entry ] = int_entry;
            dict_i_to_str[ int_entry ] = str_entry;
        }
        // set attributes
        this._dict_str_to_i = dict_str_to_i;
        this._dict_i_to_str = dict_i_to_str;

        if ( this.verbose ) {
            console.log( `[Axis ${this._name_axis}] completed loading of ${arr_str.length} number of strings` );
        }
        return arr_str // return loaded strings
    }
    unload_str( ) {
        /* # 2022-06-25 09:36:59 
        unload a mapping between string representations and integer representations.
        */
        this._dict_str_to_i = undefined;
        this._dict_i_to_str = undefined;
    }
    async get_item( l, flag_return_valid_entries_in_the_currently_active_layer = false ) {
        /* # 2022-07-14 00:42:20 
        a main functionality of 'Axis' class
        translate a given list of entries / mask (bitset/boolean_array), and return a bitarray mask containing valid entries
        
        inputs:
        [list of entries / mask (bitset/boolean_array)]
        
        returns:
        [a bitset object containing valid entries]
        */
        // ''' initialize '''
        let n = this.int_num_entries; // # retrieve the number of entries
        // # initialize the output object
        // # initialize the bitarray for the valid entries
        let ba_filter_of_selected_entries = new BitSet( );
        
        // # retrieve bitarray filter (or a filter of all active entries in the current layer)
        let ba_filter = ! check_none( this.filter ) ? this.filter : this.all( flag_return_valid_entries_in_the_currently_active_layer );
        
        // ''' handle 'None' '''
        if ( check_none( l ) ) {
            return ba_filter; // # if None is given, return all active entries in the filter (or all active entries in the layer if a filter has not been set).
        }
        
        // ''' handle a single value input '''
        if ( ( typeof l == 'number' ) | ( typeof l == 'string' ) ) { // # if a given input is not iterable or a string, wrap the element in a list
            l = [ l ];
        }
        
        // ''' handle an empty list input '''
        // # handle empty inputs // when an empty input is given, use all entries
        if ( l.length == 0 ) {
            return ba_filter; // # return results
        }
        
        // ''' handle string list input '''
        if ( typeof l[ 0 ] == 'string' ) { // # when string representations were given
            let flag_unload_str = false // # a flag to unload string representations before exiting
            // # if str has not been loaded, load the data temporarily
            if ( check_none( this._dict_str_to_i ) ) {
                flag_unload_str = true;
                await this.load_str( );
            }
            
            let dict_mapping = this._dict_str_to_i; // # retrieve a dictionary for mapping str to int
            for ( let e of l ) {
                if ( e in dict_mapping ) {
                    let i = dict_mapping[ e ];
                    if ( ba_filter.get( i ) > 0 ) { // # if the entry is acitve in the filter (or filter object containing all active entries)
                        ba_filter_of_selected_entries.set( i, 1 );
                    }
                }
            }
            
            // unload str data
            if ( flag_unload_str ) {
                this.unload_str( );
            }
            return ba_filter_of_selected_entries;
        }
        
        // ''' handle mask (bitarray / boolean array) '''
        if ( ( l.length == n ) & isSuperset( new Set( l.slice( 0, 10 ) ), new Set( [ 0, 1, true, false ] ) ) ) { // # detect boolean array
            let ba = to_ba( l ) // # convert mask to bitarray 
            return ba.and( ba_filter ); // # apply filter
        }
        
        // ''' handle integer index list input '''
        for ( let i of l ) {
            if ( ( 0 <= i ) & ( i < n ) & ( ba_filter.get( i ) > 0 ) ) {
                ba_filter_of_selected_entries.set( i, 1 );
            }
        }
        return ba_filter_of_selected_entries;
    }
    get map_str( ) {
        /* # 2022-06-25 09:31:32 
        return a dictionary for mapping string representation to integer representation
        */
        return this._dict_str_to_i;
    }
    get map_int( ) {
        /* # 2022-06-25 09:31:32 
        return a dictionary for mapping integer representation to string representation
        */
        return this._dict_i_to_str;
    }
    get length( ) {
        return this.meta.n_rows;
    }
}
class RamDataLayer {
    constructor( path_folder_ramdata, name_layer, ramdata = undefined, verbose = false, flag_debugging = false ) {
        /* 
        # 2022-07-31 14:33:46 
        */
        // these values will be fixed: dtype_of_feature_and_barcode_indices = np.uint32, dtype_of_values = np.float64
        // set attributes
        this._path_folder_ramdata = path_folder_ramdata;
        this._ramdata = ramdata;
        this.name = name_layer;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        this._path_folder_ramdata_layer = `${path_folder_ramdata}${name_layer}/`;
        
        // retrieve filters from the axes
        let ba_filter_features = check_none( ramdata ) ? undefined : ramdata.ft.filter,
            ba_filter_barcodes = check_none( ramdata ) ? undefined : ramdata.bc.filter;
        
        // set filters of the current layer
        this.ba_filter_features = ba_filter_features
        this.ba_filter_barcodes = ba_filter_barcodes
    }
    async initialize( ) {
        /* 
        # 2022-07-31 14:33:46 
        */
        // read metadata
        let zattrs = await $.getJSON( `${this._path_folder_ramdata_layer}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        this.metadata[ 'set_modes' ] = new Set( this.metadata[ 'set_modes' ] ) // convert modes to set
        this.modes = this.metadata[ 'set_modes' ]; // set attributes
        
        // load ramtx
        await this._load_ramtx_objects( );
        
        if ( this.verbose ) {
            console.log( `[RamDataLayer] '${this.name}' layer has been loaded` );
        }
    }
    async _load_ramtx_objects( ) {
        /* # 2023-07-12
        load all ramtx present in the layer
        */
        // load RAMtx objects without filters
        // load ramtx asynchronously
        let l_promise = [ ],
            l_name_mode = [ ]; // list of mode names of RAMtx objects whose initialization process returned a promise.
        for ( let mode of this.modes ) { // iterate through each mode
            let name_mode = `ramtx_${mode}`;
            if ( ! ( name_mode in this ) ) { // if the ramtx object of the current mode has not been load
                let rtx;
                if ( mode.includes( 'dense' ) ) { // currently, dense RAMtx matrix is not supported.
                    continue;
                    // rtx = RAMtx( `${this._path_folder_ramdata_layer}dense/`, is_for_querying_features = mode.rsplit( 'dense_for_querying_', 1 )[ 1 ] == 'features' ) // open dense ramtx in querying_features/querying_barcodes modes
                } else {
                    rtx = new RAMtx( `${this._path_folder_ramdata_layer}${mode}/`, this._ramdata, this.verbose, this.flag_debugging );
                    l_promise.push( rtx.initialize( ) ); // initialize an rtx object
                    l_name_mode.push( name_mode ); // record 'name_mode' of the rtx object
                    // set filters of the RAMtx object
                    rtx.ba_filter_features = this.ba_filter_features;
                    rtx.ba_filter_barcodes = this.ba_filter_barcodes;
                }
                this[ name_mode ] = rtx; // set ramtx as an attribute
            }
        }
        await Promise.all( l_promise ); // wait until all RAMtx object have been initialized.
    }
    select_ramtx( ba_entry_bc, ba_entry_ft ) {
        /* # 2022-07-31 11:46:33 
        select appropriate ramtx based on the queryed barcode and features, given as a bitarray filters 'ba_entry_bc', 'ba_entry_ft'
        */
        // count the number of valid queried entries
        let int_num_entries_queried_bc = count_ba( ba_entry_bc, this._ramdata.bc.int_num_entries ),
            int_num_entries_queried_ft = count_ba( ba_entry_ft, this._ramdata.ft.int_num_entries );
        
        // detect and handle the cases when one of the axes is empty
        if ( ( int_num_entries_queried_bc == 0 ) | ( int_num_entries_queried_ft == 0 ) ) {
            if ( this.verbose ) {
                console.log( `Warning: currently queried view is (barcode x features) ${int_num_entries_queried_bc} x ${int_num_entries_queried_ft}. please change the filter or queries in order to retrieve a valid data` );
            }
        }
        // choose which ramtx object to use
        let flag_use_ramtx_for_querying_feature = int_num_entries_queried_bc >= int_num_entries_queried_ft // select which axis to use. if there is more number of barcodes than features, use ramtx for querying 'features'
        
        let rtx = this.get_ramtx( flag_use_ramtx_for_querying_feature ); // retrieve ramtx
        if ( check_none( rtx ) ) {
            return undefined;
        }
        return rtx;
    }
    get_ramtx( flag_is_for_querying_features = true ) {
        /* # 2022-09-20 12:00:56 
        retrieve ramtx for querying feature/barcodes
        
        flag_is_for_querying_features = True # if True, return RAMtx that can be queried by features
        flag_prefer_dense = False # prefer dense matrix over sparse matrix
        set_int_index_component_to_exclude : Union[ None, set ] = None # set of integer indices of the components to exclude.
            the intended usage of this argument is to exclude RAMtx of the component that will be used as a reference
        */
        
        let name_axis_for_querying = flag_is_for_querying_features ? 'features' : 'barcodes',
            mode_dense = `dense_for_querying_${name_axis_for_querying}`, // retrieve mode name for dense ramtx based on 'flag_is_for_querying_features'
            mode_sparse = `sparse_for_querying_${name_axis_for_querying}`, // retrieve mode name for sparse ramtx based on 'flag_is_for_querying_features'
            mode = mode_sparse, // use sparse mode only
            name_mode = `ramtx_${mode}`; // name of the ramtx object for the selected mode
        if ( name_mode in this ) {
            return this[ name_mode ];
        }
        if ( this.verbose ) {
            console.log( `ramtx for querying ${name_axis_for_querying} efficiently is not available for layer ${this.name}, containing the following modes: ${[ ... this.modes]}` );
        }
        return undefined;
    }
    set_filter( ba_filter, flag_is_filter_for_features = true ) {
        /*
        set_filter of the given axis
        */
        if ( ! ( ( ba_filter instanceof BitSet ) | check_none( ba_filter ) ) ) {
            console.log( 'invalid filter was given for layer' );
        }
        let name_axis_of_filter = flag_is_filter_for_features ? 'features' : 'barcodes';
        
        // set filters of ramtx
        for ( let mode of this.modes ) { // iterate through each mode
            let name_mode = `ramtx_${mode}`;
            if ( mode.includes( 'dense' ) ) {
                continue;
            } else {
                this[ name_mode ][ `ba_filter_${name_axis_of_filter}` ] = ba_filter; // set filter
            }
        }
    }
}   
class RamData {
    constructor(  
        path_folder_ramdata, name_layer = undefined, int_index_str_rep_for_barcodes = 0, int_index_str_rep_for_features = 1, int_num_entries_for_each_weight_calculation_batch = 2000, int_total_weight_for_each_batch = 10000000, dict_kw_zdf = { 'flag_retrieve_categorical_data_as_integers' : false }, dict_kw_view = { 'float_min_proportion_of_active_entries_in_an_axis_for_using_array' : 0.1 }, verbose = true, flag_debugging = false
    ) {
        // set attributes
        this._path_folder_ramdata = path_folder_ramdata;
        this.name_layer_default = name_layer;
        this.int_index_str_rep_for_barcodes = int_index_str_rep_for_barcodes;
        this.int_index_str_rep_for_features = int_index_str_rep_for_features;
        this.int_num_entries_for_each_weight_calculation_batch = int_num_entries_for_each_weight_calculation_batch;
        this.int_total_weight_for_each_batch = int_total_weight_for_each_batch;
        this.dict_kw_zdf = dict_kw_zdf;
        this.dict_kw_view = dict_kw_view;
        this.verbose = verbose;
        this.flag_debugging = flag_debugging;
        this.layer = undefined;
    }
    async initialize( ) {
        // initialize RamData
        // load metadata of RamData
        // should be run before using RamData
        let zattrs = await $.getJSON( `${this._path_folder_ramdata}.zattrs` ); // read metadata
        this.metadata = zattrs[ 'dict_metadata' ]; // set metadata 
        
        // set attributes
        this.int_num_barcodes = this.metadata[ 'int_num_barcodes' ];
        this.int_num_features = this.metadata[ 'int_num_features' ];
        this.identifier = this.metadata[ 'identifier' ];
        this.layers = this.metadata.layers
        
        // load RamDataAxis
        // initialize axis objects
        this.bc = new RamDataAxis( this._path_folder_ramdata, 'barcodes', undefined, this, this.dict_kw_zdf, this.dict_kw_view, this.int_index_str_rep_for_barcodes, this.verbose, this.flag_debugging );
        await this.bc.initialize( );
        this.ft = new RamDataAxis( this._path_folder_ramdata, 'features', undefined, this, this.dict_kw_zdf, this.dict_kw_view, this.int_index_str_rep_for_features, this.verbose, this.flag_debugging );
        await this.ft.initialize( );

        if ( ! check_none( this.name_layer_default ) ) { // if the name_layer_default is valid
            await this.load_layer( this.name_layer_default );
        }
    }
    async load_layer( name_layer = undefined ) {
        /* 
        load layer 
        */
        this.layer = new RamDataLayer( this._path_folder_ramdata, name_layer, this, this.verbose, this.flag_debugging ); // load layer
        await this.layer.initialize( ); // initialize the layer object
    }
    repr( ) {
        /* 
        represent RamDat in a javascript REPL
        */
        let str_filter_bc = check_none( this.bc.filter ) ? '' : this.bc.meta.get_n_rows( ).toString( ) + '/',
            str_filter_ft = check_none( this.ft.filter ) ? '' : this.ft.meta.get_n_rows( ).toString( ) + '/',
            str_layer = check_none( this.layer ) ? '' : `, ${this.layer.int_num_records} records in the currently active layer '${this.layer.name}'`,
            str_name_layer = check_none( this.layer ) ? 'None' : this.layer.name;
        return `<(read-only) RamData object (${str_filter_bc}${this.metadata[ 'int_num_barcodes' ]} barcodes X ${str_filter_ft}${this.metadata[ 'int_num_features' ]} features` + str_layer + `) stored at ${this._path_folder_ramdata} with the following layers : ${Object.keys( this.layers ).length} (current layer is '${str_name_layer}')>` // show the number of records of the current layer if available.
    }
    async change_filter( name_col_filter = undefined, name_col_filter_bc = undefined, name_col_filter_ft = undefined ) {
        /* # 2022-07-16 17:27:58 
        retrieve and apply filters for 'barcode' and 'feature' Axes
        
        'name_col_filter_bc', 'name_col_filter_ft' will override 'name_col_filter' when applying filters.
        if all name_cols are invalid, no filters will be retrieved and applied
        */
        // # check validity of name_cols for filter
        // # bc
        if ( ! this.bc.meta.columns.has( name_col_filter_bc ) ) {
            name_col_filter_bc = ( this.bc.meta.columns.has( name_col_filter ) ) ? name_col_filter : undefined; // # use 'name_col_filter' instead if 'name_col_filter_bc' is invalid
        }
        // # ft
        if ( ! this.ft.meta.columns.has( name_col_filter_ft ) ) {
            name_col_filter_ft = ( this.ft.meta.columns.has( name_col_filter ) ) ? name_col_filter : undefined; // # use 'name_col_filter' instead if 'name_col_filter_ft' is invalid
        }
        
        // # apply filters
        await this.bc.change_filter( name_col_filter_bc ); // # bc
        await this.ft.change_filter( name_col_filter_ft ); // # ft
    }
    create_view( ) {
        /*  # 2022-07-06 21:17:56 
        create view of the RamData using the current filter settings (load dictionaries for coordinate conversion for filtered barcodes/features)
        */
        this.ft.create_view( );
        this.bc.create_view( );
    }
    destroy_view( ) {
        /*  # 2022-07-05 22:55:22 
        unload dictionaries for coordinate conversion for filtered barcodes/features, destroying the current view
        */
        this.ft.destroy_view( );
        this.bc.destroy_view( );
    }
    async compose_filters( l_entry_bc = [ ], l_entry_ft = [ ], flag_use_str_repr_bc = false, flag_use_str_repr_ft = false ) {
        /* # 2022-07-16 17:10:07 
        for the given 'barcodes'/'features' entries, compose filters containing the entries, and apply the filters.
        
        === inputs ===
        'flag_use_str_repr_bc' = False, 'flag_use_str_repr_ft' = False : flags indicating whether to use string representation of the retrieved entries later
        
        === outputs === 
        bitarray mask of mapped entries and list of string representations (if available. if string representations were not used to retrieve entries, None will be returned for the list object).
        */
        // # retrieve flags indicating that the string representations are not loaded
        let flag_str_not_loaded_bc = check_none( this.bc.map_int ),
            flag_str_not_loaded_ft = check_none( this.ft.map_int );
        
        // ''' retrieve filters and string representations for the queried entries '''
        // ''' barcode '''
        // # load str representation data
        if ( flag_use_str_repr_bc & flag_str_not_loaded_bc ) {
            await this.bc.load_str( );
        }
        // # retrieve filter for the queried entries
        let ba_entry_bc = await this.bc.get_item( l_entry_bc );
        
        // # retrieve str representations of the queried entries
        let l_str_bc = undefined;
        if ( flag_use_str_repr_bc ) {
            let dict_map = this.bc.map_int;
            l_str_bc = [ ];
            for ( let i of ba_to_integer_indices( ba_entry_bc, this.bc.int_num_entries ) ) {
                l_str_bc.push( dict_map[ i ] );
            }
            dict_map = undefined; // delete 'dict_map' for garbage collection
        }
        if ( flag_str_not_loaded_bc ) { // # if 'str' data was not loaded, unload the str data once all necessary data has been retrieved
            this.bc.unload_str( );
        }
        
        // ''' feature '''
        // # load str representation data
        if ( flag_use_str_repr_ft & flag_str_not_loaded_ft ) {
            await this.ft.load_str( );
        }
        // # retrieve filter for the queried entries
        let ba_entry_ft = await this.ft.get_item( l_entry_ft );
        // retrieve str representations of the queried entries
        let l_str_ft = undefined;
        if ( flag_use_str_repr_ft ) {
            let dict_map = this.ft.map_int;
            l_str_ft = [ ];
            for ( let i of ba_to_integer_indices( ba_entry_ft, this.ft.int_num_entries ) ) {
                l_str_ft.push( dict_map[ i ] );
            }
            dict_map = undefined; // delete 'dict_map' for garbage collection
        }
        if ( flag_str_not_loaded_ft ) { // # if 'str' data was not loaded, unload the str data once all necessary data has been retrieved
            this.ft.unload_str( );
        }
        
        return [ ba_entry_bc, l_str_bc, ba_entry_ft, l_str_ft ]; // # return composed filters and mapped string representations (if available)
    }
    async get_item( args ) {
        /* # 2022-08-05 17:18:47 
        please include 'str' in 'barcode_column' and 'feature_column' in order to use string representations in the output AnnData object
        
        possible usages:
        
        [ name_layer, barcode_index, barcode_column, feature_index, feature_column ]
        [ barcode_index, barcode_column, feature_index, feature_column ]
        'barcode_column' and 'feature_column' can include multi-dimensional data 
        for example, 
            [ 'str', { 'X_pca' : slice( 0, 10 ), 'X_umap', : None } ] as 'barcode_column' will include X_umap and X_pca in obsm in the resulting anndata object
            [ 'str', { 'X_pca' : slice( 0, 10 ), { 'X_umap' } ] as 'barcode_column' will also include X_umap and X_pca in obsm in the resulting anndata object
        */
        if ( ! ( args instanceof Array ) ) { // # more than one arguments should be given
            if ( this.verbose ) {
                console.log( 'invalid queries, exiting' );
            }
        }
        // if the first argument appears to be 'name_layer', load the layer and drop the argument
        if ( ( typeof args[ 0 ] == 'string' ) & ( args[ 0 ] in this.layers ) ) {
            let name_layer = args[ 0 ];
            await this.load_layer( name_layer ); // load the layer
            args = args.slice( 1 );
        }
        // # assumes layer has been loaded, and remaining arguments are only for barcode/feature indexing
        if ( args.length > 4 ) {
            if ( this.verbose ) {
                console.log( 'the number of arguments are too many, exiting.' )
            }
        }
        
        // # make the number of arguments to 4
        for ( let i = 0; i < 4 - args.length; i ++ ) {
            args.push( [ ] ); // push an empty array
        }
        // # parse arguments
        let l_entry_bc = args[ 0 ], 
            l_col_bc = args[ 1 ], 
            l_entry_ft = args[ 2 ], 
            l_col_ft = args[ 3 ];
        
        // backup the filters
        let ba_filter_bc_backup = this.bc.filter,
            ba_filter_ft_backup = this.ft.filter;
        
        // retrieve flags for using string representations in the output
        let flag_use_str_repr_bc = l_col_bc.includes( 'str' ),
            flag_use_str_repr_ft = l_col_ft.includes( 'str' );
        
        // load a layer
        if ( check_none( this.layer ) ) {
            if ( Object.keys( this.layers ).length == 0 ) { // # if no layer is available
                if ( this.verbose ) {
                    console.log( 'no layer is available. current implementation requires at least one layer, exiting' );
                    return;
                }
            }
            await this.load_layer( Object.keys( this.layers )[ 0 ] ); // load any layer
        }
        
        // compose filters from the queried entries
        let res = await this.compose_filters( l_entry_bc, l_entry_ft, flag_use_str_repr_bc, flag_use_str_repr_ft );
        let ba_entry_bc = res[ 0 ], 
            l_str_bc = res[ 1 ], 
            ba_entry_ft = res[ 2 ], 
            l_str_ft = res[ 3 ];
        
        // retrieve ramtx for retrieving data
        let rtx = this.layer.select_ramtx( ba_entry_bc, ba_entry_ft );
        
        // set barcode/feature filters for the queried entries
        this.bc.set_filter( ba_entry_bc );
        this.ft.set_filter( ba_entry_ft );

        // initialize and destroy the view after retrieving the count matrix
        // # load 'dict_change' for coordinate conversion according to the given filters, creating the view of the RamData
        
        /*
        for faster loading, all fetching works will be done, asynchronously
        */
        let l_promise = [ ]; // list of promises
        
        // # retrieve count data
        this.create_view( ); // create view [RAMtx]
        
        // accumulate promises
        l_promise.push( rtx.get_sparse_matrix( [ ] ) ); // # retrieve count data for all entries currently active in the filter [RAMtx]
        l_promise.push( this.bc.meta.get_df( l_col_bc ) ); // retrieve meta data as dataframes [df_obs]
        l_promise.push( this.ft.meta.get_df( l_col_ft ) ); // retrieve meta data as dataframes [df_var]
        
        // # retrieve promises for obsm/varm
        let l_ax = [ this.ft, this.bc ],
            l_name_adata_attr = [ 'varm', 'obsm' ],
            l_l_col = [ l_col_ft, l_col_bc ],
            l_adata_args = [ ]; // anndata arguments for mapping each result to a specific anndata component
        for ( let i = 0; i < 2; i ++ ) { // for each axis
            let ax = l_ax[ i ], // retrieve axis
                name_adata_attr = l_name_adata_attr[ i ],
                l_col = l_l_col[ i ];
            for ( let e of l_col ) {
                if ( e instanceof Array ) { // # retrieve all data in the secondary axis
                    for ( let name_col of e ) {
                        if ( ax.meta.columns.has( name_col ) ) { // if the column exists in the metadata
                            l_adata_args.push( [ name_adata_attr, name_col ] );
                            l_promise.push( ax.meta.get_item( name_col ) );
                        }
                    }
                } else if ( e instanceof Object ) { // # indexing through secondary axis
                    for ( let name_col in e ) {
                        if ( ax.meta.columns.has( name_col ) ) { // if the column exists in the metadata
                            l_adata_args.push( [ name_adata_attr, name_col ] );
                            l_promise.push( ( check_none( e[ name_col ] ) ? ax.meta.get_item( name_col ) : ax.meta.get_item( name_col, undefined, e[ name_col ] ) ) ); // # if e[ name_col ] is None, load all data on the secondary axis
                        }
                    }
                }
            }
        }
        res = await Promise.all( l_promise ); // wait until all promises become completed
        
        let X = res[ 0 ];
        this.destroy_view( ); // destroy view [RAMtx]
        
        // retrieve meta data as dataframes
        let df_obs = res[ 1 ];
        if ( flag_use_str_repr_bc ) { // # add string representations
            df_obs.add_column( 'str', l_str_bc ); // add a column containing string representations
            df_obs.set_index( 'str' ); // use string representations as index
            l_str_bc = undefined; // delete 'l_str_bc'
        }
        let df_var = res[ 2 ];
        if ( flag_use_str_repr_ft ) { // # add string representations
            df_var.add_column( 'str', l_str_ft ); // add a column containing string representations
            df_var.set_index( 'str' ); // use string representations as index
            l_str_ft = undefined; // delete 'l_str_ft'
        }
        
        // build output AnnData object
        let adata = new AnnData( X, df_obs, df_var ) // # in anndata.X, row = barcode, column = feature // # set obs and var with integer index values // # add count data
        
        // # add obsm/varm
        for ( let i = 0; i < l_adata_args.length; i ++ ) { // for each axis
            let adata_args = l_adata_args[ i ],
                name_adata_attr = adata_args[ 0 ],
                name_col = adata_args[ 1 ];
            adata[ name_adata_attr ][ name_col ] = res[ i + 3 ]; // 3 indicating df_obs, df_var, and RAMtx's sparse matrix, X.
        }

        // restore the filters once the data retrieval has been completed
        this.bc.set_filter( ba_filter_bc_backup );
        this.ft.set_filter( ba_filter_ft_backup );
        
        return adata; // # return resulting AnnData
    }
}
/*
Implementation of RamData.js [END]
*/
    
// functions for UI components
function Select_RemoveOptions_Using_ID( id_selectElement ) { // remove all option in the select element using id
    let sel = document.getElementById( id_selectElement ),
        length = sel.options.length - 1;
    for( let i = length; i >= 0; i -- ) {
        sel.remove( i );
    }
}
function Select_Get_Selected_Option_Using_ID( id_selectElement ) { // get selected option in the select element with its id
    let sel = document.getElementById( id_selectElement );
    // if the number of options is zero, return undefined
    if ( sel.options.length == 0 ) {
        return undefined;
    }
    if ( sel.multiple ) { 
        // if the selection object is multi-selection-object
        let l_option = sel.options, 
            l_option_selected = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) { // for each option
            let option = l_option[ i ]; // retrieve current option 
            if ( option.selected ) { // if the current option has been selected
                l_option_selected.push( option ); 
            } 
        }
        return l_option_selected; // return the list of selected options
    } else { // if selection object is single-selection-object
        return sel.options[ sel.selectedIndex ];
    }
}
function Select_Get_Value_from_Option( opt ) {
    /*
    get value from the select option
    */
    if ( check_none( opt ) ) { // if option is invalid, return option without accessing its value attribute.
        return opt;
    }
    return opt.value
}
function Select_AddOptions_Using_ID( id_selectElement, dict_innerHTML_to_value ) { // add options in the select element using id and the given dictionary containing innerHTML (key) and values (values). alternatively, an Array can be given, whose values will be used to initialize both innerHTMLs and values of the options
    // get select element
    let sel = document.getElementById( id_selectElement );
    
    // add options 
    if ( Array.isArray( dict_innerHTML_to_value ) ) { // each entry will be used to initialize both innerHTML and value
        for ( let name of dict_innerHTML_to_value ) {
            let opt = document.createElement( 'option' );
            // set value and name of the option
            opt.value = name;
            opt.innerHTML = name;
            sel.appendChild( opt );
        }
    } else { // innerHTML (key) and values (values)
        for ( let name in dict_innerHTML_to_value ) {
            let opt = document.createElement( 'option' ),
                val = dict_innerHTML_to_value[ name ];
            // set value and name of the option
            opt.value = val;
            opt.innerHTML = name;
            sel.appendChild( opt );
        }
    }
}
function Select_SelectOption_Using_ID( id_selectElement, value ) { // select value
    // get select element
    let sel = document.getElementById( id_selectElement );
    
    if ( Array.isArray( value ) ) { // if a list of selection values was given
        let set_value = new Set( value ); // retrieve a set of unique values to select
        for ( let opt of sel.options ) { // iterate over option
            if ( set_value.has( opt.value  ) ) { // if the option has the value of the given list of values to select
                opt.selected = true; // select the option
            }
        }
    } else {
        // if only single value was used for selection
        sel.value = value;
    }
}
// tagify functions
function Tagify_check_Tagify_UsingID( id_element ) { // return True if the given element contains a tagify object
    let el = document.getElementById( id_element );
    return '__tagify' in el;
}
function Tagify_Destroy_UsingID( id_element, flag_clear_previous_tags = true ) { // destroy the tagify object from the element
    /*
    flag_clear_previous_tags = true // clear the tags that have been previously added to the tagify instance 
    */
    let el = document.getElementById( id_element );
    if ( '__tagify' in el ) { 
        if ( 'destroy' in el.__tagify  ) {
            el.__tagify.destroy( )
        }
    }
    if ( flag_clear_previous_tags ) {
        el.value = '' // clear previous tags
    }
}
function Tagify_Initialize_UsingID( id_element, enforceWhitelist = true, whitelist = [ ], flag_dragsort = false, maxTags = 100, maxItems = 50, flag_clear_previous_tags = true ) {
    /*
    flag_clear_previous_tags = true // clear the tags that have been previously added to the tagify instance 
    */
    // prepare
    var el = document.getElementById( id_element );
    if ( flag_clear_previous_tags ) {
        el.value = '' // clear previous tags
    }
    // initialize Tagify instance
    let tagify = new Tagify( el, {
            enforceWhitelist : enforceWhitelist,
            whitelist: whitelist,
            maxTags: maxTags,
            dropdown: {
                maxItems: maxItems,           // <- mixumum allowed rendered suggestions
                classname: "tags-look", // <- custom classname for this dropdown, so it could be targeted
                enabled: 0,             // <- show suggestions on focus
                closeOnSelect: false    // <- do not hide the suggestions dropdown once an item has been selected
            }
        });
    if ( flag_dragsort ) {
        // function for DragSort of Tagify tags
        // must update Tagify's value according to the re-ordered nodes in the DOM
        function onDragEnd(elm){
            tagify.updateValueByDOMTags()
        }
        // bind "DragSort" to Tagify's main element and tell
        // it that all the items with the below "selector" are "draggable"
        var dragsort = new DragSort( tagify.DOM.scope, {
            selector: '.'+tagify.settings.classNames.tag,
            callbacks: {
                dragEnd: onDragEnd
            }
        });
    }
    return tagify // return the object
}
function Tagify_AddTags_UsingID( id_element, l_tags ) {
    // add tags to a Tagify object script on the above inputs
    let tagify = document.getElementById( id_element ).__tagify; // retrieve the tagify object
    tagify.addTags( l_tags.map( e => { return { 'value' : e }; } ) ); // wrap inside a dictionary to avoid Tagify spliting tags containing ',' character into smaller tags
}
function Tagify_GetTagTitles_UsingID( id_element ) {
    // add tags to a Tagify object script on the above inputs
    let tagify = document.getElementById( id_element ).__tagify, // retrieve the tagify object
        l_tagtitle = [ ]; // initialize a list of titles of the tags
    for ( let e of tagify.getTagElms() ) {
        l_tagtitle.push( e.title );
    }
    return l_tagtitle;
}
    
// functions for plotting and interacting with html document
// for argsort
let argsort = arr => arr.map( (v, i) => [v, i] ).sort( ).map( a => a[ 1 ] ); // a function for arg-sorting an array
// for Array operations
// functions for numpy-like operations
function ArraySum( l ) { // return the sum of values of an array
    return l.reduce( (a, b) => a + b, 0 );
}
function ArrayIndexing( l, l_index ) {
    let l_output = [ ];
    for ( let i = 0; i < l_index.length; i++ ) { l_output.push( l[ l_index[ i ] ] ); }
    return l_output
}
function ArrayBooleanIndexing( l, l_bool ) {
    let l_output = [ ];
    for ( let i = 0; i < l_bool.length; i++ ) { if ( l_bool[ i ] ) { l_output.push( l[ i ] ); } }
    return l_output
}
function ArrayBoolAND( l_l ) {
    let l_output = [ ];
    for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
        let output = true;
        for ( let i = 0; i < l_l.length; i++ ) { output = output && l_l[ i ][ j ]; }
        l_output.push( output );
    }
    return l_output;
}
function ArrayBoolOR( l_l ) {
    let l_output = [ ];
    for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
        let output = false;
        for ( let i = 0; i < l_l.length; i++ ) { output = output || l_l[ i ][ j ]; }
        l_output.push( output );
    }
    return l_output;
}
function ArrayBoolNOT( l ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] ? false : true ); }
    return l_output;
}
function ArrayGreaterThan( l, thres ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] > thres ); }
    return l_output;
}
function ArrayLessThan( l, thres ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] < thres ); }
    return l_output;
}
function ArrayFull( length, value ) {
    let l_output = [ ];
    for ( let i = 0; i < length; i++ ) { l_output.push( value ); }
    return l_output;
}
function ArrayBroadCasting( l, l_bool, value ) {
    let l_output = [ ];
    for ( let i = 0; i < l.length; i++ ) { l_output.push( l_bool[ i ] ? value : l[ i ] ); }
    return l_output;
}
function ArrayCap( l, value ) { // cap value of a given list at the given capping value (manually set maximum value)
    l_modified = lodash.cloneDeep( l );
    for ( let i = 0; i < l.length; i ++ ) {
        if ( l[ i ] > value ) { // cap value of a given list at the given capping value (manually set maximum value)
            l_modified[ i ] = value;
        }
    }
    return l_modified
}
function ArrayFloor( l, value ) { // floor value of a given list at the given flooring value (manually set minimum value)
    l_modified = lodash.cloneDeep( l );
    for ( let i = 0; i < l.length; i ++ ) {
        if ( l[ i ] < value ) { // cap value of a given list at the given capping value (manually set maximum value)
            l_modified[ i ] = value;
        }
    }
    return l_modified
}
function ArrayApply( l, a_function ) { // apply certain function to all of values of a given array
    let l_output = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_output[ i ] = a_function( l[ i ] );
    }
    return l_output
}
function ArrayMap( l, dictionary, default_value = undefined ) { // map values in a given array using a given dictionary
    let l_output = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_output[ i ] = ( l[ i ] in dictionary ) ? dictionary[ l[ i ] ] : default_value;
    }
    return l_output
}
function ArrayTranspose( l_l ) { // transpose 2d array
    let n_row = l_l.length, n_col = l_l[ 0 ].length, l_l_t = [ ]; // transposed 2d array
    for ( let i = 0; i < n_col; i ++ ) {
        let l_t = [ ]; // transposed column (now a row)
        for ( let j = 0; j < n_row; j ++ ) { l_t.push( l_l[ j ][ i ] ); }
        l_l_t.push( l_t );
    }
    return l_l_t;
}
function ArrayAsInt( l ) { 
    let l_int = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_int.push( parseInt( l[ i ] ) ); // parse a string into an integer for each entry
    }
    return l_int
} // convert array of strings to array of integers
function ArrayAverage( l ) { // calculate average of values in the array
    let sum = l.reduce( ( a, b ) => a + b, 0 );
    let avg = ( sum / l.length ) || 0;
    return avg;
}
function ArrayMultiply( l, float_multiply_by ) { // return a list with values multiplied by 'float_multiply_by'
    let l_multiplied = [ ];
    for ( let i = 0; i < l.length; i ++ ) {
        l_multiplied.push( l[ i ] * float_multiply_by );
    }
    return l_multiplied;
}
function ArrayUniqueValues( l ) {
    let s = new Set( l ),
        l_unique_values = [ ... s ];
    delete s
    return l_unique_values
}
// accessory functions
function Pivot( l_index, l, name_none = 'None' ) { // return dictarr where unique entries of l_index are keys and a list of correspondinb values to each entry (key) is a value to each key. // similar to 'Index_list_with_dictionary' function
    /*
    name_none = 'None' // name of the 'None' category
    */
    let dictarr = { };
    for ( let i = 0; i < l_index.length; i ++ ) {
        let index = l_index[ i ];
        // use 'name_none' if the current value is None value (undefined or null)
        if ( check_none( index ) ) {
            index = name_none;
        }
        if ( index in dictarr ) {
            dictarr[ index ].push( l[ i ] );
        } else {
            dictarr[ index ] = [ l[ i ] ];
        }
    }
    return dictarr;
}

/*
RamData locations settings [START]
*/
let dict_ramdata_locations = {
    'ELDB.combined_v20221214.subset_80000_barcodes' : 'https://scelephant-free.s3.amazonaws.com/ELDB.combined_v20221214.subset_80000_barcodes.ramdata/',
    '(New York) ELDB.combined_v20221214.subset_160000_barcodes' : 'https://scelephant-free.s3.amazonaws.com/ELDB.combined_v20221214.subset_160000_barcodes.ramdata/',
    '(London) ELDB.combined_v20221214.subset_160000_barcodes' : 'https://scelephant-free-london.s3.eu-west-2.amazonaws.com/ELDB.combined_v20221214.subset_160000_barcodes.ramdata/',
    '(South Korea, Seoul) ELDB.combined_v20221214.subset_160000_barcodes' : 'https://scelephant-seoul.s3.ap-northeast-2.amazonaws.com/ELDB.combined_v20221214.subset_160000_barcodes.ramdata/',
    'ELDB.combined_v20221214.subset_320000_barcodes' : 'https://scelephant-free.s3.amazonaws.com/ELDB.combined_v20221214.subset_320000_barcodes.ramdata/',
}
/*
RamData locations settings [END]
*/
    
let dict_data = { 
    'canvas' : {
        'dict_div' : {
        }, // a data container with key = name_div and values specific to the division
    },
    'dict_ramdata' : {
    },
    'dict_anndata' : {
    },
    'bs_components' : {
        'offcanvasLoadRamData' : new bootstrap.Offcanvas( document.getElementById( "offcanvasLoadRamData" ), { backdrop: true } ),
        'offcanvasRetrieveAnnData' : new bootstrap.Offcanvas( document.getElementById( "offcanvasRetrieveAnnData" ), { backdrop: true } ),
        'offcanvasPlotAnnData' : new bootstrap.Offcanvas( document.getElementById( "offcanvasPlotAnnData" ), { backdrop: false, scroll: true } ),
        'modal_introduction' : new bootstrap.Modal( document.getElementById('modal_for_tutorial'), { keyboard: false, backdrop: 'static', focus: true } ),
        'modal_for_tutorial_intro' : new bootstrap.Modal( document.getElementById('modal_for_tutorial_intro'), { keyboard: false, backdrop: false, focus: true } ),
        'modal_for_tutorial_ramdata' : new bootstrap.Modal( document.getElementById('modal_for_tutorial_ramdata'), { keyboard: false, backdrop: false, focus: true } ),
        'modal_for_tutorial_anndata' : new bootstrap.Modal( document.getElementById('modal_for_tutorial_anndata'), { keyboard: false, backdrop: false, focus: true } ),
        'modal_for_tutorial_plot_anndata' : new bootstrap.Modal( document.getElementById('modal_for_tutorial_plot_anndata'), { keyboard: false, backdrop: false, focus: true } ),
        'modal_keyboard_shortcuts' : new bootstrap.Modal( document.getElementById('modal_keyboard_shortcuts'), { keyboard: true, backdrop: true, focus: true } ),
    },
    'tagify_components' : {
        
    },
    'misc' : { // miscellaneous variables and settings
        'name_option_no_filter' : 'no filter (all entries)',
        'function_colormap_rainbow' : chroma.scale( [ '#ff0000', '#ff8000', '#ffff00', '#80ff00', '#00ff00', '#00ff80', '#00ffff', '#0080ff', '#0000ff', '#8000ff', '#ff00ff', '#ff0080' ] ).mode( 'lab' ), // colormaps
        'name_none' : 'None', // name of 'None' values
        'int_max_length_text_label' : 70, // the maximum length of a string for text label
        'int_max_num_tags' : 100, // the maximum number of tags that can be included in the single text area (for performance optimization)
        'int_max_num_categories_for_drawing_individual_trace_for_each_category' : 10, // setting for scatter plot (categorical data). 
    }
}
// colormap examples
// tab20b '#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'
// 12color rainbow '#ff0000', '#ff8000', '#ffff00', '#80ff00', '#00ff00', '#00ff80', '#00ffff', '#0080ff', '#0000ff', '#8000ff', '#ff00ff', '#ff0080'
// 
// 'function_colormap_rainbow' : chroma.scale( [ '#ff0000','#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ff0000','#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ff0000','#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ff0000' ] ), // colormaps
dict_data.misc.get_color_from_string = ( e ) => { let val = Math.abs( cyrb53( reverseString( e ) ) ); return dict_data.misc.function_colormap_rainbow( [ ( val % 100 ) / 100, ( val % 10000 ) / 10000, ( val % 1000000 ) / 1000000 ][ parseInt( val % 300000 / 100000 ) ] ); }; // define a function to get color from string
    
function toggle_legend( name_div ) {
    /*
    toggle legends of the plotly graph
    
    'name_div' : the name of the division for the plotly graph.
    */
    let div = document.getElementById( name_div ),
        flag_show_legend = document.getElementById( `switch_toggle_legend_${name_div}` ).checked, // retrieve flag for showing legends
        layout = div.layout, // retrieve existing layout
        layout_new = { ... div.layout, showlegend : flag_show_legend }; // when 'showlegend' attribute is absent in layout, legend is present. // toggle legends
    Plotly.relayout( div, layout_new ); // relayout the graph
}
function toggle_word_cloud( name_div ) {
    /*
    toggle a division containing word cloud
    
    'name_div' : the name of the division for the plotly graph.
    */
    console.log( name_div )
    let div = document.getElementById( name_div ),
        flag_show = document.getElementById( `switch_toggle_word_cloud_${name_div}` ).checked, // retrieve flag for showing legends
        bsCollapse = new bootstrap.Collapse( `#word_cloud_container_${name_div}`, { toggle : false } ); // retrieve the collapse instance
    if ( flag_show ) {
        bsCollapse.show( );
    } else {
        bsCollapse.hide( );
    }
    delete bsCollapse;
}
function update_btn_download_data_selected_cells( name_div, l_index ) {
    /*
    update the button for downloading data of selected cells
    
    'name_div' : the name of the division for the plotly graph.
    'l_index' : list of indices of the selected cells
    # 20231225 
    */
    dict_data.canvas.dict_div[ name_div ][ 'l_index_selected' ] = l_index; // store l_index of the selected cells
    let int_num_cells_selected = l_index.length, // retrieve the number of selected cells
        btn = $( `#btn_download_data_selected_cells_${name_div}` )[ 0 ]; // retrieve the button object
    btn.innerHTML = `download raw count data of ${int_num_cells_selected} selected cells`;
    if ( btn.disabled ) {
        btn.disabled = false;
    } // enable the button
    return;
}
function convert_text_to_gzip_file_blob( str_text ) {
    /*
    str_text // text to gzip-compress and convert to blob object
    */
    return new Blob( [ pako.gzip( str_text ) ] );
}
async function convert_blobs_to_zip_archive_blob( dict_name_file_to_blob ) {
    /*
    write blobs into a zip archive in memory and return blob of the zip archive
    
    dict_name_file_to_blob // a dictionary containing name of the file as the key and blob as the value.
    # 20231225 HSA
    */
    // Creates a BlobWriter object where the zip content will be written.
    let zipFileWriter = new zip.BlobWriter( ),
        zipWriter = new zip.ZipWriter(zipFileWriter), // initialize the zip writer
        l_promise = [ ]; // initialize the list of promises
        
    // add blobs as files in the zip archive asynchronously
    for ( let name_file in dict_name_file_to_blob ) { // for each file name
        l_promise.push( zipWriter.add( name_file, new zip.BlobReader( dict_name_file_to_blob[ name_file ] ) ) )
    }
    await Promise.all( l_promise ); // add files to the zip archive asynchronously
    await zipWriter.close(); // closes the writer.

    let zipFileBlob = await zipFileWriter.getData();
    return zipFileBlob; // return blob of the zip archive
}
async function convert_anndata_to_10x_MEX_zip_archive_blob( adata ) {
    /*
    convert the given adata object to 10x MEX Zip file 
    # 20231225 HSA
    */
    let dict_name_file_to_blob = { }, // initialize 'dict_name_file_to_blob'
        val_type_gex = 'Gene Expression', // define GEX type value
        l_str_bc = adata.obs.get_column( 'str' ),
        l_str_ft = adata.var.get_column( 'str' ); // retrieve string representations of barcodes and features
    
    // write matrix file
    dict_name_file_to_blob[ '10x_MEX/matrix.mtx.gz' ] = convert_text_to_gzip_file_blob( adata.X.to_matrix_market_text( flag_switch_primary_and_secondary_axes = true ) ); // write matrix file
    
    // write barcode file
    l_str_bc.push( '' ); // add the last line
    dict_name_file_to_blob[ '10x_MEX/barcodes.tsv.gz' ] = convert_text_to_gzip_file_blob( l_str_bc.join( '\n' ) ); // write barcode file
    
    // write feature file
    l_str_ft = l_str_ft.map( ( e ) => { return [ e, e, val_type_gex ].join( '\t' ); } ); // compose other two columns of the features.tsv.gz file
    l_str_ft.push( '' ); // add the last line
    dict_name_file_to_blob[ '10x_MEX/features.tsv.gz' ] = convert_text_to_gzip_file_blob( l_str_ft.join( '\n' ) ); // write feature file
    
    return await convert_blobs_to_zip_archive_blob( dict_name_file_to_blob ); // compose a zip archive and return the result
}
async function download_data_selected_cells( name_div ) {
    /*
    download data of the selected cells
    
    'name_div' : the name of the division for the plotly graph.
    # 20231225 HSA
    */
    let data = dict_data.canvas.dict_div[ name_div ], // retrieve data associated with 'name_div'
        int_num_cells_selected = data[ 'l_index_selected' ].length, // retrieve the number of selected cells
        int_max_num_cells_allowed_for_downloading = 300, // set the maximum number of cells to be downloaded.
        btn = $( `#btn_download_data_selected_cells_${name_div}` )[ 0 ], // retrieve the button object
        ram = data[ 'adata' ].uns[ 'ram' ], // retrieve the RamData object from which AnnData object was retrieved.
        name_layer_raw = ( 'raw' in ram.layers ) ? 'raw' : Object.keys( ram.layers )[ 0 ]; // retrieve 'name_layer' containing raw count data. if 'raw' is not available, use any layer in the RamData
    
    // disable the button once fetching has been started.
    btn.disabled = true;

    // set filters
    ram.ft.set_filter( undefined ); // retrieve data of all features
    ram.bc.set_filter( undefined ); // reset the filter
    ram.bc.set_filter( await ram.bc.get_item( data[ 'l_index_selected' ] ) ) // retrieve data of selected barcodes
    
    // subsample the barcodes if the number of cells are too large
    if ( int_num_cells_selected > int_max_num_cells_allowed_for_downloading ) {
        let float_subsampling_ratio = int_max_num_cells_allowed_for_downloading / ram.bc.length; // calculate the subsampling ratio
        console.log( `subsampling ratio = ${float_subsampling_ratio}` )
        ram.bc.set_filter( ram.bc.subsample( float_subsampling_ratio ) ) // subsample the barcodes 
    }

    // retrieve data
    let adata_selected_cells = await ram.get_item( [ name_layer_raw, [ ], [ 'str' ], [ ], [ 'str' ] ] );
    console.log( `data of ${int_num_cells_selected} number of cells was downloaded and converted to AnnData` )
    // data[ 'adata_selected_cells' ] = adata_selected_cells; 
    
    // notify data has been downloaded
    btn.innerHTML = `raw count data of ${int_num_cells_selected} selected cells <b>download completed</b>`;
    
    fileSaver.saveAs( 
        await convert_anndata_to_10x_MEX_zip_archive_blob( adata_selected_cells ), // retrieve blob object of zip archive file
        `raw_counts_${int_num_cells_selected}_cells.zip` // name of the zip archive file
    );
    return adata_selected_cells;
}
    
// for downloading count matrix and AnnData

    
// function Display_DataTable( id_datatable_container, id_datatable, dictarr, l_col_selected = null ) { // load datatable with loaded datasets
//     let object_datatable = object_data.main.datatable[ id_datatable ], columns = [ ], dataSet = [ ], df = null, l_col = [ ];

//     df = new DataFrame( dictarr );
//     object_datatable.df = df; // save the reference to the dataframe
//     if ( ! ( l_col_selected === null ) ) {
//         df = df.select( ... l_col_selected ); // select appropriate columns before visualization
//     }
//     dataSet = df.toArray( ), l_col = df.listColumns( );
//     for ( let i = 0; i < l_col.length; i ++ ) { columns.push( { title: l_col[ i ] } ); } // set columns for DataTable.js
//     $( '#' + id_datatable_container ).empty( ); // empty the datatable and redraw the datatable
//     $( '#' + id_datatable_container ).append( '<table id="' + id_datatable + '" class="display" width="100%"></table>' );
//     $( '#' + id_datatable ).DataTable( { data: dataSet, columns: columns } ); // display the datatable
// }
// function Download_DataTable( ram, l_int_repr_bc ) { // download analysis result of vaccine candidate as a csv file
//     let string_csv_datatable = '', object_datatable = object_data.main.datatable[ id_datatable ], df = object_datatable.df;
//     if ( df != null ) {
//         string_csv_datatable = df.toCSV( true );
//     }
//     let blob = new Blob( [ string_csv_datatable ], { type: "text/plain;charset=utf-8" } );
//     name_file = object_datatable.name + '.datatable.csv' // change the extension of the filename
//     fileSaver.saveAs( blob, name_file ); // save file 
// }
    
    
function delete_div( name_div ) {
    /*
    delete the given div for plotting graph
    */
    if ( name_div in dict_data.canvas.dict_div ) { // delete div when 'name_div' exists in the canvas
        let div = document.getElementById( `${name_div}_container` ),
            flag_create_dual_div = dict_data.canvas.dict_div[ name_div ].flag_create_dual_div, // retrieve 'flag_create_dual_div'
            l_key = [ name_div ]; // list of keys to delete
        if ( flag_create_dual_div ) { // add keys for the dual divisions
            l_key.push( `${name_div}__top__`, `${name_div}__bottom__` );
        }
        div.remove( ); // delete the div from the document
        // delete the data associated with the div 
        for ( let key of l_key ) {
            delete dict_data.canvas.dict_div[ key ]; 
        }
    }
}
function create_div( name_div, style = "width:1100px;height:1100px;", flag_create_dual_div = false, flag_create_legend_toggle_button = false, flag_create_word_cloud_toggle_button = false, flag_create_download_selected_cells_button = false, int_word_cloud_width = 850, int_word_cloud_height = 200, str_word_cloud_placeholder_text = "<i>please click a word to display its count</i>", str_btn_download_data_selected_cells_placeholder_text = '<i>please select the cells with lasso tool to download raw counts</i>' ) {
    /*
    create a new div for plotting graph
    
    'flag_create_dual_div' : create two divisions next to each other
    'flag_create_legend_toggle_button' : create legend toggle button
    'flag_create_word_cloud_toggle_button' = false : create toggle button for showing/hiding a word cloud for exploring metadata of the selected barcodes/group of the clicked barcode
    */
    let div_new = document.createElement( 'div' ),
        str_content_innerhtml = `<h5><span class="badge rounded-pill bg-secondary">${name_div}<button type="button" class="btn-close btn-close-white" aria-label="close figure" onclick="delete_div( '${name_div}' );"></button></span></h5>`; // initialize innerHTML content (add a badge indicating the panel)
    div_new.id = `${name_div}_container_new`; // set temporary id
    div_new.className = 'plot_container';
    if ( flag_create_dual_div ) {
        // add the legend toggle button
        // for dual div., legend will be hidden by default
        if ( flag_create_legend_toggle_button ) { // add legend button only for the top division only
            str_content_innerhtml += `<div class="form-check form-check-inline form-switch"><input class="form-check-input" type="checkbox" id="switch_toggle_legend_${name_div}__top__" onchange="toggle_legend( '${name_div}__top__' )"><label class="form-check-label" for="switch_toggle_legend_${name_div}__top__">show legend</label></div>`
        }
        if ( flag_create_word_cloud_toggle_button ) { // add the word cloud toggle button to the first division 
            str_content_innerhtml += `<div class="form-check form-check-inline form-switch"><input class="form-check-input" type="checkbox" id="switch_toggle_word_cloud_${name_div}__top__" onchange="toggle_word_cloud( '${name_div}__top__' )"><label class="form-check-label" for="switch_toggle_word_cloud_${name_div}__top__">show word cloud</label></div>`
        }
        // add the data download button for the first division
        if ( flag_create_download_selected_cells_button ) {
            str_content_innerhtml += `<button class="btn btn-outline-primary" style="--bs-btn-padding-y: .1rem; --bs-btn-padding-x: .5rem; --bs-btn-font-size: .8rem;" type="button" onclick="download_data_selected_cells( '${name_div}__top__' )" id="btn_download_data_selected_cells_${name_div}__top__" disabled>${str_btn_download_data_selected_cells_placeholder_text}</button>`;
        }
        str_content_innerhtml += `<div id="${name_div}__top__" style="${style} class="plot"></div>`; // add the first division
        if ( flag_create_word_cloud_toggle_button ) { // add the word cloud container for the first division and the toggle button to the second division 
            str_content_innerhtml += `<div class="collapse" id="word_cloud_container_${name_div}__top__"><div id="word_cloud_callback_${name_div}__top__">${str_word_cloud_placeholder_text}</div><canvas id="word_cloud_${name_div}__top__" class="wordcloud" width="${int_word_cloud_width}" height="${int_word_cloud_height}"></canvas></div><div class="form-check form-check-inline form-switch"><input class="form-check-input" type="checkbox" id="switch_toggle_word_cloud_${name_div}__bottom__" onchange="toggle_word_cloud( '${name_div}__bottom__' )"><label class="form-check-label" for="switch_toggle_word_cloud_${name_div}__bottom__">show word cloud</label></div>`; // add collapse division of the first division
        }
        // add the data download button for the first division
        if ( flag_create_download_selected_cells_button ) {
            str_content_innerhtml += `<button class="btn btn-outline-primary" style="--bs-btn-padding-y: .1rem; --bs-btn-padding-x: .5rem; --bs-btn-font-size: .8rem;" type="button" onclick="download_data_selected_cells( '${name_div}__bottom__' )" id="btn_download_data_selected_cells_${name_div}__bottom__" disabled>${str_btn_download_data_selected_cells_placeholder_text}</button>`;
        }
        str_content_innerhtml += `<div id="${name_div}__bottom__" style="${style} class="plot"></div>`; // add the second division
        if ( flag_create_word_cloud_toggle_button ) { // add the word cloud container of the second division 
            str_content_innerhtml += `<div class="collapse" id="word_cloud_container_${name_div}__bottom__"><div id="word_cloud_callback_${name_div}__bottom__">${str_word_cloud_placeholder_text}</div><canvas id="word_cloud_${name_div}__bottom__" class="wordcloud" width="${int_word_cloud_width}" height="${int_word_cloud_height}"></canvas></div>`; // add a collapse division of the second division
        }
    } else {
        // add the legend toggle button
        if ( flag_create_legend_toggle_button ) {
            str_content_innerhtml += `<div class="form-check form-check-inline form-switch"><input class="form-check-input" type="checkbox" id="switch_toggle_legend_${name_div}" onchange="toggle_legend( '${name_div}' )"><label class="form-check-label" for="switch_toggle_legend_${name_div}">show legend</label></div>`
        }
        // add the word cloud toggle button
        if ( flag_create_word_cloud_toggle_button ) {
            str_content_innerhtml += `<div class="form-check form-check-inline form-switch"><input class="form-check-input" type="checkbox" id="switch_toggle_word_cloud_${name_div}" onchange="toggle_word_cloud( '${name_div}' )"><label class="form-check-label" for="switch_toggle_word_cloud_${name_div}">show word cloud</label></div>`
        }
        // add the data download button
        if ( flag_create_download_selected_cells_button ) {
            str_content_innerhtml += `<button class="btn btn-outline-primary" style="--bs-btn-padding-y: .1rem; --bs-btn-padding-x: .5rem; --bs-btn-font-size: .8rem;" type="button" onclick="download_data_selected_cells( '${name_div}' )" id="btn_download_data_selected_cells_${name_div}" disabled>${str_btn_download_data_selected_cells_placeholder_text}</button>`;
        }
        str_content_innerhtml += `<div id="${name_div}" class="plot" style="${style}"></div>`;
        // add the word cloud container
        if ( flag_create_word_cloud_toggle_button ) {
            str_content_innerhtml += `<div class="collapse" id="word_cloud_container_${name_div}"><div id="word_cloud_callback_${name_div}">${str_word_cloud_placeholder_text}</div><canvas id="word_cloud_${name_div}" class="wordcloud" width="${int_word_cloud_width}" height="${int_word_cloud_height}"></canvas></div>`
        }
    }
    div_new.innerHTML = str_content_innerhtml; // set innerHTML
    if ( name_div in dict_data.canvas.dict_div ) { // if the panel already exists in the canvas, replace previous div. with new div.
        document.getElementById( `${name_div}_container` ).replaceWith( div_new );
        div_new.id = `${name_div}_container`; // set id of the container
    } else {
        // if the panel does not exist in the canvas, prepend div at the top.
        div_new.id = `${name_div}_container`; // set id of the container
        document.getElementById( 'canvas' ).prepend( div_new );
    }
    
    let l_key = [ name_div ], // initialize the list of keys to initialize the data container
        _dict_settings = {
            flag_create_dual_div : flag_create_dual_div,
            flag_create_legend_toggle_button : flag_create_legend_toggle_button,
            flag_create_download_selected_cells_button : flag_create_download_selected_cells_button,
        }; // settings to initialize the data container
    if ( flag_create_dual_div ) {
        l_key.push( `${name_div}__top__`, `${name_div}__bottom__` ); // add keys for two subdivisions
    }
    for ( let key of l_key ) {
        dict_data.canvas.dict_div[ key ] = { ... _dict_settings }; // add a data container for the div
    }
}

let name_application = 'scelephant.js'
let config_plotly = { responsive: true, displaylogo: false, displayModeBar : true, toImageButtonOptions: { hoverClosestCartesian: true, format: 'png', filename: name_application, height: 750, width: 1100, scale: 1 }, modeBarButtonsToRemove: [ 'autoScale2d', 'toggleSpikelines', 'hoverCompareCartesian', 'hoverClosestCartesian' ] } // flexible plot width according to the window size  // do not display plotly logo

function adaptive_marker_size( ed, div, dict_kw_args ) {
    /*
    adaptively change marker sizes
    */
    // if no event was detected, exit
    if ( Object.entries( ed ).length === 0 ) { return; }
    
    // function for calculating responsive marker size
    function ResponsiveMarkerSize( div, marker_size_default = 5, int_factor_axis_range_to_marker_size = 30, int_factor_marker_size_multiply = 3 ) { // get marker size according to the given parameter and x- and y-axis range of the division containing a plotly plot
        if ( ! ( 'layout' in div ) ) {
            return marker_size_default; // if plotly has not been drawn, use the default value for the marker size
        }
        let x = div.layout.xaxis, y = div.layout.yaxis,
            int_marker_size_to_be_updated = Math.min( 10, Math.min( Math.ceil( int_factor_axis_range_to_marker_size / ( x.range[ 1 ] - x.range[ 0 ] ) ), Math.ceil( int_factor_axis_range_to_marker_size / ( y.range[ 1 ] - y.range[ 0 ] ) ) ) * int_factor_marker_size_multiply );
        return int_marker_size_to_be_updated;
    }
    
    // broadcasting updated zoom level across plots
    let x = div.layout.xaxis, y = div.layout.yaxis, flag_relayout = false, update = { }; // a flag indicating whether a relayout event is required
    // ignore when layouts are changed due to autoranging
    let int_marker_size_current = div.data[ 0 ].marker.size,
        int_marker_size_to_be_updated = ResponsiveMarkerSize( div, dict_kw_args[ 'marker_size' ], dict_kw_args[ 'int_factor_axis_range_to_marker_size' ], dict_kw_args[ 'int_factor_marker_size_multiply' ] ),
        flag_restyle = int_marker_size_to_be_updated != int_marker_size_current; // retrieve a marker indicating whether the marker size should be updated 

    if ( flag_restyle ) { // restyle existing plot
        console.log( "[adaptive_marker_size] restyling marker size to ", int_marker_size_to_be_updated );
        Plotly.restyle( div, { "marker.size" : int_marker_size_to_be_updated } );
    } 
}
function synchronized_layout( ed, divs ) {
    /*
    synchronization of zoom levels across plotly plots
    */
    if ( Object.entries( ed ).length === 0 ) { return; }
    // broadcasting updated zoom level across plots
    divs.forEach( ( div, i ) => {
        let x = div.layout.xaxis, y = div.layout.yaxis, flag_relayout = false, update = { }; // a flag indicating whether a relayout event is required
        // ignore when layouts are changed due to autoranging
        if ( ( ed[ "xaxis.autorange" ] && x.autorange ) && ( ed[ "yaxis.autorange" ] && y.autorange ) ) { 
            return;
        }
        // update x-axis
        if ( x.range[ 0 ] != ed[ "xaxis.range[0]" ] || x.range[ 1 ] != ed[ "xaxis.range[1]" ] ) {
            flag_relayout = true;
            update = { ... update, 'xaxis.range[0]': ed[ "xaxis.range[0]" ], 'xaxis.range[1]': ed[ "xaxis.range[1]" ], 'xaxis.autorange': ed[ "xaxis.autorange" ] };
        }
        // update y-axis
        if ( y.range[ 0 ] != ed[ "yaxis.range[0]" ] || y.range[ 1 ] != ed[ "yaxis.range[1]" ] ) {
            flag_relayout = true;
            update = { ... update, 'yaxis.range[0]': ed[ "yaxis.range[0]" ], 'yaxis.range[1]': ed[ "yaxis.range[1]" ], 'yaxis.autorange': ed[ "yaxis.autorange" ] };
        }
        if ( flag_relayout ) {
            Plotly.relayout( div, update ); // perform relayout operation
        }

    });
}
function get_word_count( adata, l_name_col = undefined, l_index = undefined, flag_true_for_obs_false_for_var = true, l_stop_words = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "of", "the", "", "cell", "cells" ], l_delimitors = [",", " ", ";", "_", '/', '(', ')', '[', ']' ] ) {
    /* # 2023-05-14 21:08:45 
    adata, // AnnData to survey word counts
    l_name_col, // a list of columns. To use all columns, set the argument to undefined. The columns containing numbers will be ignored.
    l_index, // list of indices. To get a word count of all entries, set argument to undefined.
    flag_true_for_obs_false_for_var = true, // if true, use obs (barcode axis), and if false, use var (features axis)
    l_stop_words = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "of", "the", "", "cell", "cells" ], // list of stop words (the words that will be ignored when counting words)
    l_delimitors = [",", " ", ";", "_", '/', '(', ')', '[', ']' ], // list of characters to use when separating the categorical labels in the metadata to obtain the word count data.
    */
    // prepare    
    let df = ( flag_true_for_obs_false_for_var ) ? adata.obs : adata.var, // retrieve appropriate dataframe
        set_stop_words = new Set( l_stop_words ), // 
        str_delim_universal = "1fcf2a7f0c",  // a string that will be used as a universal delimiter
        word_count = { }; // intialize the word count output

    // retrieve columns
    if ( l_name_col == undefined ) {
        l_name_col = [ ... df.columns ]; // use all columns of the dataframe
    }
    let set_name_col = intersection( df.columns, l_name_col );
    
    // subset the data
    if ( l_index != undefined ) {
        df = df.subset( l_index, [ ... set_name_col ] ); // subset the dataframe to retrieve word count only a specific set of entries
    }

    if ( set_name_col.size == 0 ) {
        return word_count; // return an empty result
    }

    function _update_count( dict_count_to_be_updated, dict_count_for_update ) {
        // # 2023-05-12 16:16:24 
        for ( let key in dict_count_for_update ) {
            if ( ! ( key in dict_count_to_be_updated ) ) {
                dict_count_to_be_updated[key] = dict_count_for_update[key]
            } else {
                dict_count_to_be_updated[key] += dict_count_for_update[key]
            }
        }
        return dict_count_to_be_updated
    }

    function _counter( arr_word, set_stop_words ) {
        // 2023-05-14 20:22:00 
        let word_count = { };
        for ( let word of arr_word ) {
            // check whether the word is in the set of stop words
            if ( set_stop_words.has( word ) ) { // for some reason, '' escape Set's 'in' operation, and should be handled separately.
                continue; // does not include stop word in the word count
            }
            // update the word count
            if ( ! ( word in word_count ) ) {
                word_count[ word ] = 1
            } else {
                word_count[ word ] += 1
            }
        }
        return word_count;
    }


    for ( let name_col of set_name_col ) {
        let arr_data = df.get_column( name_col ), // retrieve data of the column
            dict_cat_to_word_count = { }; // initialize a dictionary storing cat -> word_count dictionary mapping for efficient operations
        for ( let e of arr_data ) {
            if ( e != undefined ) {
                // check whether the entry is number. if a number is detected, skip the column for generating word count.
                if ( typeof e === 'number' ) {
                    break; // skip the current column
                }
                // check whether a mapping exists
                if ( ! ( e in dict_cat_to_word_count ) ) {
                    // retrieve word counts for the category
                    for ( let delim of l_delimitors ) {
                        if ( e.includes( delim ) ) {
                            e = e.replaceAll( delim, str_delim_universal ) // replace delimitor characters with universal spacer
                        }
                    }
                    // add a mapping
                    dict_cat_to_word_count[ e ] = _counter( e.split( str_delim_universal ), set_stop_words ); // create word counts for the given category
                }
                // update the word count
                word_count = _update_count( word_count, dict_cat_to_word_count[ e ] );
            }
        }
    }
    return word_count
}
function draw_graph( name_div, adata, dict_kw_args ) {
    /*
    name_div // name of the division to draw plots
    adata // anndata
    dict_kw_args // keyworded arguments
        - name_feature : undefined // if given, show expression of a gene
        - sort_by_value : true // 
    
    */  
    // define default keworded arguments
    let dict_kw_args_default = {
        'name_type_graph' : 'scatter', // the name of the type of the graph. [ 'scatter', 'violin', 'dot' ] 
        'name_feature' : undefined, // if given, show expression of a feature
        'sort_by_value' : true, // if true, sort barcodes by value that is used to color points, preventing lower-priority points to cover high-priority points
        'name_col_obs' : undefined, // if given, display values of a column of adata.obs
        'name_col_embedding' : undefined, // name of obsm data that contains embedding coordinates (assumes NestedArray was given)
        'flag_plot_feature' : true, // if true, plot feature using 'name_feature'. if false, plot obs column from adata.obs
        'name_embedding' : 'UMAP', // name of the embedding method. used to label axes
        'marker_size_for_scatter_plot' : 3, // marker size for scatter plot
        'marker_size_for_dot_plot' : 30, // marker size for dot plot
        'fig_size' : [ 1100, 1100 ], // the figure size of the new plot (height/width)
        'int_factor_axis_range_to_marker_size' : 30, // for responsive marker size
        'int_factor_marker_size_multiply' : 3, // for responsive marker size
        'vmax' : undefined, // set a maximum value to visualize. useful when an outlier exists and dampens the signals
        'title' : 'default figure name',
        'fontsize_title' : 24,
        'font_title' : 'Calibri',
        'flag_responsive_marker_size' : false,
        'flag_recreate_div' : false, // recreate the div
        'l_str_entry_feature' : undefined, // a list of string representation of features for drawing dot plots. by default use all loaded string representation of features
        'l_name_category_in_col_obs' : undefined, // a list of name of categories in the column of adata.obs for drawing dot plots or violin plots. by default, all categories will be used
        'margin' : { l: 65, r: 65, b: 90, t: 25, pad: 4 }, // margin of the plotly graph
        'flag_create_legend_toggle_button' : false, // create legend toggle button
        'flag_create_word_cloud_toggle_button' : false, // create word cloud toggle button
        'fig_size_word_cloud' : [ 1050, 200 ], // figure size of the associated word cloud
        'l_name_col_obs' : undefined, // a list of obs columns for drawing word cloud. if undefined is given, use all columns
        'flag_create_download_selected_cells_button' : false, // a flag for adding download selected cells button
    }
    
    dict_kw_args = { ... dict_kw_args_default, ... dict_kw_args }; // compose 'dict_kw_args' using the default keyworded arguments and given keyworded arguments
    
    // recreate div if 'flag_recreate_div' is True
    if ( dict_kw_args[ 'flag_recreate_div' ] ) {
        // initialize div (single graph)
        create_div( name_div, style = `width:${dict_kw_args[ 'fig_size' ][ 0 ]}px;height:${dict_kw_args[ 'fig_size' ][ 1 ]}px;`, false, dict_kw_args[ 'flag_create_legend_toggle_button' ], dict_kw_args[ 'flag_create_word_cloud_toggle_button' ], dict_kw_args[ 'flag_create_download_selected_cells_button' ], dict_kw_args[ 'fig_size_word_cloud' ][ 0 ], dict_kw_args[ 'fig_size_word_cloud' ][ 1 ] );
    }
    
    let marker_colormap = { showscale: true, colorscale: "YlOrRd", reversescale: true }; // setting for showing colormap
    
    let l_val_feature = undefined,
        l_val_obs = undefined,
        l_index = adata.obs.index, // list of indices for to keep track of the indices of obs
        l_trace = [ ], // initialize the list of plotly scatter traces
        div_plot = $( "#" + name_div )[ 0 ], // retrieve div to create a plot
        layout,
        config = { ... config_plotly, height: dict_kw_args[ 'fig_size' ][ 0 ], width: dict_kw_args[ 'fig_size' ][ 1 ] };

    // retrieve values
    // retrieve color values according to the setting
    if ( ( ! check_none( dict_kw_args[ 'name_feature' ] ) ) & ( dict_kw_args[ 'name_feature' ] in adata.var._dict_mapping_index ) & ( ! check_none( dict_kw_args[ 'flag_plot_feature' ] ) ) ) { // 'flag_plot_feature' should not be 'None' value
        l_val_feature = adata.X.subset( adata.var.get_integer_indices_of_rows( [ dict_kw_args[ 'name_feature' ] ] ) ).to_dense( ).T.tolist( )[ 0 ]; // [ ... adata.obs.get_column( 'raw_sum' ).flatten( ) ]
    }
    l_val_obs = adata.obs.get_column( dict_kw_args[ 'name_col_obs' ] );
    
    let name_type_graph = dict_kw_args[ 'name_type_graph' ];
    if ( name_type_graph == 'scatter' ) { // draw scatter plot using the data
        // initialize
        let l_color = ( dict_kw_args[ 'flag_plot_feature' ] ) ? l_val_feature : l_val_obs, // retrieve values for setting colors
            l_x = [ ... adata.obsm[ dict_kw_args[ 'name_col_embedding' ] ].get( [ null, 0 ] ).flatten( ) ],
            l_y = [ ... adata.obsm[ dict_kw_args[ 'name_col_embedding' ] ].get( [ null, 1 ] ).flatten( ) ],
            marker_size = dict_kw_args[ 'marker_size_for_scatter_plot' ]; // retrieve marker size for scatter plot
        
        if ( check_none( l_color ) ) { // if invalid inputs were given, exit
            return;
        }

        let flag_color_using_continuous_values = typeof l_color[ 0 ] == 'number', // retrieve a flag indicating whether the array contains float value
            name_val_for_color = dict_kw_args[ 'flag_plot_feature' ] ? dict_kw_args[ 'name_feature' ] : dict_kw_args[ 'name_col_obs' ]; // retrieve name of values for coloring points
        name_val_for_color = ( name_val_for_color.length > dict_data.misc.int_max_length_text_label ) ? name_val_for_color.slice( 0, dict_data.misc.int_max_length_text_label - 3 ) + '...' : name_val_for_color; // omit long labels if the label is too long

        if ( flag_color_using_continuous_values ) { // if values are continuous values
            // cap the values according to the setting
            if ( ! check_none( dict_kw_args[ 'vmax' ] ) ) { // if valid 'vmax' value has been given
                l_color = ArrayCap( l_color, dict_kw_args[ 'vmax' ] ); // cap values
            }

            // sort by color value according to the setting.
            if ( dict_kw_args[ 'sort_by_value' ] ) {
                let argsort_by_color = argsort( l_color );
                // sort by color value
                l_x = ArrayIndexing( l_x, argsort_by_color );
                l_y = ArrayIndexing( l_y, argsort_by_color );
                l_color = ArrayIndexing( l_color, argsort_by_color );
                l_index = ArrayIndexing( l_index, argsort_by_color ); // sort the indices, too
            }

            // compose a single trace when values are continuous
            let trace = {
                mode: 'markers',
                type: 'scattergl',
                x: l_x,
                y: l_y,
                customdata: ArrayTranspose( [ l_index, l_color ] ), // store the index for callback
                hovertemplate: [ `${name_val_for_color}: <b>%{customdata[1]:.5f}</b>`,
                                `UMAP: <b>%{x:.2f}</b>, <b>%{y:.2f}</b>`,
                                "<extra></extra>" ].join( "<br>" ),
                marker: { 
                    color: l_color,
                    size: marker_size
                },
                line: { 
                    width: 0
                },
            };
            trace.marker = { ... trace.marker, ... marker_colormap }; // update setting for showing colormap
            l_trace.push( trace ); // add trace to the list of traces
        } else {
            let name_none = dict_data.misc.name_none, // handle 'None' category as a separate category
                color_none = '#f2f2f2', // color of the None category
                l_category_values = l_color.map( ( e ) => { return check_none( e ) ? name_none : e; } ), // retrieve 'l_category_values' from 'l_color' 
                l_unique_category_values = ArrayUniqueValues( l_category_values ); // retrieve a list of unique category values
            if ( l_unique_category_values.length > dict_data.misc.int_max_num_categories_for_drawing_individual_trace_for_each_category ) {
                // draw a single trace for all categories
                // sort by category value according to the setting.
                if ( dict_kw_args[ 'sort_by_value' ] ) {
                    let argsort_by_color = argsort( l_category_values );
                    // sort by color value
                    l_x = ArrayIndexing( l_x, argsort_by_color );
                    l_y = ArrayIndexing( l_y, argsort_by_color );
                    l_category_values = ArrayIndexing( l_category_values, argsort_by_color );
                    l_index = ArrayIndexing( l_index, argsort_by_color ); // sort the indices, too
                }

                // compose a single trace when values are continuous
                let trace = {
                    name: name_val_for_color, // set trace name
                    mode: 'markers',
                    type: 'scattergl',
                    x: l_x,
                    y: l_y,
                    customdata: ArrayTranspose( [ l_index, l_category_values ] ), // store the index for callback
                        hovertemplate: [ `<b>%{customdata[1]}</b>`,
                                        `(${name_val_for_color})`,
                                        `UMAP: <b>%{x:.2f}</b>, <b>%{y:.2f}</b>`,
                                        "<extra></extra>" ].join( "<br>" ),
                    marker: { 
                        color: l_category_values.map( ( e ) => { return ( e == name_none ) ? color_none : dict_data.misc.get_color_from_string( e ).toString( ); } ),
                        size: marker_size
                    },
                    line: { 
                        width: 0
                    },
                };
                l_trace.push( trace ); // add trace to the list of traces
            } else {
                // draw individual trace for each category
                let dict_category_to_dict_data = { }; // initialize dict_data for each category
                for ( let i = 0; i < l_category_values.length; i ++ ) {
                    let e = l_category_values[ i ],
                        x = l_x[ i ],
                        y = l_y[ i ],
                        index = l_index[ i ];
                    // initialize dict_data for the category
                    if ( ! ( e in dict_category_to_dict_data ) ) {
                        dict_category_to_dict_data[ e ] = { l_x: [ ], l_y: [ ], l_index: [ ] }; 
                    }
                    dict_category_to_dict_data[ e ].l_x.push( x );
                    dict_category_to_dict_data[ e ].l_y.push( y );
                    dict_category_to_dict_data[ e ].l_index.push( index );
                }

                // compose trace for 'None' category before other traces can be composed
                if ( name_none in dict_category_to_dict_data ) { // if 'None' category exists
                    let e = name_none;
                    let trace = {
                        name: e, // set category name as the name of the trace
                        mode: 'markers',
                        type: 'scattergl',
                        x: dict_category_to_dict_data[ e ].l_x,
                        y: dict_category_to_dict_data[ e ].l_y,
                        customdata: ArrayTranspose( [ dict_category_to_dict_data[ e ].l_index ] ), // store the index for callback
                        hovertemplate: [ `<b>${e}</b>`,
                                        `(${name_val_for_color})`,
                                        `UMAP: <b>%{x:.2f}</b>, <b>%{y:.2f}</b>`,
                                        "<extra></extra>" ].join( "<br>" ),
                        marker: { 
                            color: color_none, // set color for 'None' category
                            size: marker_size
                        },
                        line: { 
                            width: 0
                        },
                    };
                    l_trace.push( trace ); // add trace to the list of traces
                    delete dict_category_to_dict_data[ e ]; // delete 'None' category
                }

                // compose traces        
                let l_name_category = Object.keys( dict_category_to_dict_data );
                l_name_category = l_name_category.sort( ); // sort categories 
                for ( let e of l_name_category ) { // for each category (in the sorted order)
                    let trace = {
                        name: e, // set category name as the name of the trace
                        mode: 'markers',
                        type: 'scattergl',
                        x: dict_category_to_dict_data[ e ].l_x,
                        y: dict_category_to_dict_data[ e ].l_y,
                        customdata: ArrayTranspose( [ dict_category_to_dict_data[ e ].l_index ] ), // store the index for callback
                        hovertemplate: [ `<b>${string_insert_every_n_chars( e, '<br>', dict_data.misc.int_max_length_text_label )}</b>`, 
                                        `(${name_val_for_color})`,
                                        `UMAP: <b>%{x:.2f}</b>, <b>%{y:.2f}</b>`,
                                        "<extra></extra>" ].join( "<br>" ),
                        marker: { 
                            color: dict_data.misc.get_color_from_string( e ).toString( ), // assign color of the entry using hasing
                            size: marker_size
                        },
                        line: { 
                            width: 0
                        },
                    };
                    l_trace.push( trace ); // add trace to the list of traces
                }
            }
        }
       // compose layout and configure settings
       layout = { 
            margin: { l: 65, r: 65, b: 90, t: 25, pad: 4, ... dict_kw_args[ 'margin' ] }, 
            xaxis: { title : `${dict_kw_args[ 'name_embedding' ]}-1`, zeroline: false }, 
            yaxis: { title : `${dict_kw_args[ 'name_embedding' ]}-2`, zeroline: false }, 
            hovermode: "closest",
            showlegend: false, // hide the legend by default
        };
        config = { ... config, filename: 'single-cell-scatter-graph' };
    } else if ( name_type_graph == 'violin' ) { // draw scatter plot 
        // build list of traces for each category
        let dictarr = Pivot( l_val_obs, l_val_feature, name_none = dict_data.misc.name_none ), // key = cluster, value = list of expression values.
            dictindex = Pivot( l_val_obs, l_index, name_none = dict_data.misc.name_none ), // key = cluster, value = list of indices.
            set_name_category_in_col_obs = new Set( check_none( dict_kw_args[ 'l_name_category_in_col_obs' ] ) ? Object.keys( dictarr ) : dict_kw_args[ 'l_name_category_in_col_obs' ] ), // use all categories if 'l_name_category_in_col_obs' is None
            trace_template = { 
                type: 'violin',
                opacity: 0.6,
                box: { visible: true, width: 0.075 },
                meanline: { visible: true }
            }, // define basic template
            str_separation = ( div_plot.offsetWidth > 3000 ) ? '<br>' : ' '; // set 'str_separation' based on current width to increase responsiveness of the plot
        for ( let category in dictarr ) { // for each category
            if ( set_name_category_in_col_obs.has( category ) ) { // add a trace if the category is in 'set_name_category_in_col_obs'
                let l_expr = dictarr[ category ],
                    n_cells = l_expr.length, // retrieve number of cells for the current category
                    float_mean_expression = ArrayAverage( l_expr ); // retrieve a mean expression of cells for the current trace
                let category_shortened = string_shorten( category, dict_data.misc.int_max_length_text_label, '...' ), // shorten the category name
                    trace = { ... trace_template,
                             name: category_shortened,
                             line: { color: 'black', width: 2 },
                             customdata: dictindex[ category ], // store the indices for callback
                             fillcolor: dict_data.misc.get_color_from_string( category ).toString( ), // assign color of the entry using hasing,
                             points: false, // do not show outliers to increase responsivity
                             y: l_expr,
                             x0: `${category_shortened}${str_separation}(n=${n_cells})`,
                             mean_expression_for_sorting: float_mean_expression
                            };
                l_trace.push( trace );
            }
        }
        // Sort Plotly Violin traces based on expression values
        function SortViolinTraceUsingExpression( trace_a, trace_b ) { return - ( trace_a.mean_expression_for_sorting - trace_b.mean_expression_for_sorting ) }; 
        l_trace = l_trace.sort( SortViolinTraceUsingExpression ); // sort by mean expression
        
        // compose layout and configure settings
        layout = {
            margin: { l: 50, r: 65, b: 150, t: 5, pad: 4, ... dict_kw_args[ 'margin' ] },
            yaxis: { title : `Expression of ${dict_kw_args[ 'name_feature' ]}`, rangemode: "nonnegative" },
            legend: { tracegroupgap: 0 },
            violingap: 0, // split violin plot for two covid statuses
            violingroupgap: 0,
            violinmode: "overlay",
            showlegend: false, // hide the legend by default
        }
        config = { ... config, filename: `single-cell-violin-graph-${dict_kw_args[ 'name_feature' ]}` };
    } else if ( name_type_graph == 'dot' ) {
        function get_name_cat_for_vis( e ) {
            // function for converting name category to name category for visualization
            return check_none( e ) ? dict_data.misc.name_none : string_shorten( e, dict_data.misc.int_max_length_text_label, '...' );
        }
        let set_str_entry_feature = new Set( dict_kw_args[ 'l_str_entry_feature' ] ), 
            l_name_category_in_col_obs = dict_kw_args[ 'l_name_category_in_col_obs' ].map( ( e ) => { return get_name_cat_for_vis( e ); } ), // for dot-plot shorten the category name 
            set_name_category_in_col_obs = new Set( l_name_category_in_col_obs ); // retrieve initial set of categories from the input
        set_str_entry_feature = intersection( set_str_entry_feature, new Set( adata.var.get_column( 'str' ) ) ); // retrieve intersection with the genes 
        
        // summarize data for each category
        let dict_category_to_dict_data = { }; // initialize dict_data for each category
        for ( let str_entry_ft of set_str_entry_feature ) { // for each feature in 'set_str_entry_feature'
            l_val_feature = adata.X.subset( adata.var.get_integer_indices_of_rows( [ str_entry_ft ] ) ).to_dense( ).T.tolist( )[ 0 ]; // retrieve expression data of a feature
            let dict_name_cat_to_name_cat_for_vis = { }; // initialize a dictionary for storing name of category for visualization
            for ( let i = 0; i < l_val_obs.length; i ++ ) { // iterate over entries
                let e = l_val_obs[ i ], // retrieve the name of the category
                    val = l_val_feature[ i ]; // retrieve expression value
                
                // modify name of category to visualize the name better on the graph
                if ( ! ( e in dict_name_cat_to_name_cat_for_vis ) ) {
                    dict_name_cat_to_name_cat_for_vis[ e ] = get_name_cat_for_vis( e );
                } 
                e = dict_name_cat_to_name_cat_for_vis[ e ];

                // handle 'None' category as a separate category
                if ( check_none( e ) ) {
                    e = dict_data.misc.name_none;
                }
                if ( set_name_category_in_col_obs.has( e ) ) { // only include name_category in 'set_name_category_in_col_obs'
                    // initialize dict_data for the category
                    if ( ! ( e in dict_category_to_dict_data ) ) {
                        dict_category_to_dict_data[ e ] = { }; 
                    }
                    // initialize the array to collect the data
                    if ( ! ( str_entry_ft in dict_category_to_dict_data[ e ] ) ) {
                        dict_category_to_dict_data[ e ][ str_entry_ft ] = [ ];  
                    }
                    dict_category_to_dict_data[ e ][ str_entry_ft ].push( val );
                }
            }
        }
        set_name_category_in_col_obs = new Set( Object.keys( dict_category_to_dict_data ) ); // retrieve 'set_name_category_in_col_obs' containing only valid name_category
        l_name_category_in_col_obs = l_name_category_in_col_obs.filter( e => set_name_category_in_col_obs.has( e ) ) // filter the list with a set containing valid entries (preserve the original orders)
        let l_str_entry_feature = dict_kw_args[ 'l_str_entry_feature' ].filter( e => set_str_entry_feature.has( e ) ),
            trace = {
                type: 'scatter',
                customdata: [ ],
                hovertemplate: [ `<b>%{y}</b> (%{customdata[1]:.1f}% expressed)`,
                                `<b>%{x}</b> : %{customdata[0]:.5f}`,
                                "<extra></extra>" ].join( "<br>" ),
                x: [ ],
                y: [ ],
                mode: 'markers',
                marker: {
                    color: [ ],
                    line: {
                        color: 'rgba(156, 165, 196, 1.0)',
                        width: 1,
                    },
                    symbol: 'circle',
                    size: [ ],
                    ... marker_colormap
                }
            };
        for ( let str_entry_ft of l_str_entry_feature ) {
            for ( let name_category of l_name_category_in_col_obs.reverse( ) ) { // iterate over the category in a reverse order (to put the first category in the input at the top of the dot plot)
                let l_val = dict_category_to_dict_data[ name_category ][ str_entry_ft ], // retrieve list of values for the current category
                    n_non_zeros = 0;
                for ( let val of l_val ) {
                    if ( val > 0 ) {
                        n_non_zeros ++;
                    }
                }
                // add point to the scatter plot
                trace.x.push( str_entry_ft );
                trace.y.push( name_category );
                let val_avg = ArrayAverage( l_val ), // calculate average expression
                    percentage_expressed = n_non_zeros / l_val.length; // calculate percentage of expressed barcodes
                trace.marker.color.push( val_avg ); // collect average expression
                trace.marker.size.push( percentage_expressed * dict_kw_args[ 'marker_size_for_dot_plot' ] ) // measure the proportion of the barcodes expressing the feature
                trace.customdata.push( [ val_avg, percentage_expressed * 100 ] ); // collect the custom data
            }
        }
        // compose traces
        l_trace.push( trace );
        
        // compose layout and configure settings
        layout = { margin: { l: 140, r: 40, b: 50, t: 20, ... dict_kw_args[ 'margin' ] } };
        config = { ... config, filename: 'single-cell-dot-plot' };
    } else {
        return; // exit if invalid graph type has been given
    }
    
    // draw plot using plotly.js
    // if valid 'title' was given, set title name
    if ( dict_kw_args[ 'title' ].length > 0 ) {
        layout[ 'title' ] = {
            text : dict_kw_args[ 'title' ],
            font : {
                family : dict_kw_args[ 'font_title' ],
                size : dict_kw_args[ 'fontsize_title' ]
            },
            xref: 'paper',
            x: 0.05,
        }
        layout.margin.t += 30; // increase top margin since figure title will not be set
    }
    Plotly.newPlot( div_plot, l_trace, layout, config ); // draw scatter plot of the annotation

    // for scatter plot, add event listner when 'flag_responsive_marker_size' is set to True
    if ( name_type_graph == 'scatter' ) {
        if ( dict_kw_args[ 'flag_responsive_marker_size' ] ) {
            div_plot.on( "plotly_relayout", function( ed ) {
//                 console.log( `plotly relayout attached to`, div_plot );
                adaptive_marker_size( ed, div_plot, dict_kw_args );
            });
        }
    }
    // add references to the associated data objects to the div data container
    dict_data.canvas.dict_div[ name_div ][ 'adata' ] = adata;
    dict_data.canvas.dict_div[ name_div ][ 'dict_kw_args' ] = dict_kw_args;
    
    // add word cloud callback
    let l_name_col_obs = ( dict_kw_args[ 'l_name_col_obs' ].length == 0 ) ? undefined : dict_kw_args[ 'l_name_col_obs' ]; // if no columns are selected, use all available columns
    
    // for each plot type, different call back is needed.
    if ( name_type_graph == 'scatter' ) {
        let flag_color_using_continuous_values = typeof ( ( dict_kw_args[ 'flag_plot_feature' ] ) ? l_val_feature : l_val_obs )[ 0 ] == 'number';
        // consistent interactions for both types of scatter plot
        div_plot.on('plotly_selected', function( eventData ) {
//             console.log( `${name_div} selected` ) 
//             console.log( eventData ) 
            if ( eventData != undefined ) {
                let l_index = eventData.points.map( ( pt ) => { return pt.customdata[ 0 ]; } ), // retrieve list of AnnData.obs indices 
                    count = get_word_count( adata, l_name_col_obs, l_index ); // get word count // get indices of the selected point
                update_btn_download_data_selected_cells( name_div, l_index ); // update button for downloading data of selected cells (prepare downloading data of selected cells)
                WordCloud( document.getElementById( `word_cloud_${name_div}` ), { 'minSize' : 12.5, 'weightFactor' : 125 / Math.max( ... Object.values( count ) ), 'minRotation' : 0, 'maxRotation' : 0, 'list' : Object.keys( count ).map( k => { return [ k, count[ k ] ]; } ), 'click' : ( item ) => { document.getElementById( `word_cloud_callback_${name_div}` ).innerHTML = ` term <b>'${item[ 0 ]}'</b>: ${item[ 1 ]} counts`; } } ); // draw a word cloud
            }
        });
        
        div_plot.on( 'plotly_click', function( eventData ) {
//             console.log( `${name_div} click` ) 
//             console.log( eventData ) 
            let l_index = eventData.points.map( ( pt ) => { return pt.customdata[ 0 ]; } ), // retrieve list of AnnData.obs indices
                count = get_word_count( adata, l_name_col_obs, l_index ); // get word count // get indices of the selected category
            update_btn_download_data_selected_cells( name_div, l_index ); // update button for downloading data of selected cells (prepare downloading data of selected cells)
            WordCloud( document.getElementById( `word_cloud_${name_div}` ), { 'minSize' : 12.5, 'weightFactor' : 125 / Math.max( ... Object.values( count ) ), 'minRotation' : 0, 'maxRotation' : 0, 'list' : Object.keys( count ).map( k => { return [ k, count[ k ] ]; } ), 'click' : ( item ) => { document.getElementById( `word_cloud_callback_${name_div}` ).innerHTML = ` term <b>'${item[ 0 ]}'</b>: ${item[ 1 ]} counts`; } } ); // draw a word cloud
        });  
        
    } else if ( name_type_graph == 'violin' ) {
        div_plot.on( 'plotly_click', function( eventData ) {
            let count = get_word_count( adata, l_name_col_obs, eventData.points[ 0 ].fullData.customdata ); // get word count
            WordCloud( document.getElementById( `word_cloud_${name_div}` ), { 'minSize' : 12.5, 'weightFactor' : 125 / Math.max( ... Object.values( count ) ), 'minRotation' : 0, 'maxRotation' : 0, 'list' : Object.keys( count ).map( k => { return [ k, count[ k ] ]; } ), 'click' : ( item ) => { document.getElementById( `word_cloud_callback_${name_div}` ).innerHTML = ` term <b>'${item[ 0 ]}'</b>: ${item[ 1 ]} counts`; } } ); // draw a word cloud
        });  
    }        
}

// when document is ready for interaction
$(document).ready( function( ) {
//     $('[data-toggle="tooltip"]').tooltip( ); // enable tooltips
//     $('[data-tooltip="tooltip"]').tooltip( );
//     $('[data-tooltip-always-active="tooltip"]').tooltip( );
    
//     // enable popovers
//     const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]');
//     const popoverList = [...popoverTriggerList].map( popoverTriggerEl => new bootstrap.Popover( popoverTriggerEl ) );
    
//     $( '#modal_introduction' ).modal( 'show' ); // show introduction modal
//     Toggle_Tooltips( ); // set tooltips status
//     object_plot_MolecularMimicryMap.hovermode = "closest"; // set initial status
    Initialize( );
});
    
async function Initialize( flag_perform_demonstration = true ) { // initialize the web application
    // open the welcome modal
    dict_data.bs_components.modal_introduction.show( );
    
    // add names of ramdata objects to the loadramdata panel
    let id_select_ramdata = 'select_ramdata_object';
    Select_RemoveOptions_Using_ID( id_select_ramdata );
    Select_AddOptions_Using_ID( id_select_ramdata, dict_ramdata_locations ); // add ramdata objects in the settings
    
    // set default options
    // figsize
    document.getElementById( 'input_int_fig_size_x_for_scatter_graph' ).value = '1050';
    document.getElementById( 'input_int_fig_size_y_for_scatter_graph' ).value = '800';
    document.getElementById( 'input_int_margin_l_for_scatter_graph' ).value = '65'; 
    document.getElementById( 'input_int_margin_b_for_scatter_graph' ).value = '90';
    
    document.getElementById( 'input_int_fig_size_x_for_violin_graph' ).value = '1250';
    document.getElementById( 'input_int_fig_size_y_for_violin_graph' ).value = '400';
    document.getElementById( 'input_int_margin_l_for_violin_graph' ).value = '65';
    document.getElementById( 'input_int_margin_b_for_violin_graph' ).value = '200';
    
    document.getElementById( 'input_int_fig_size_x_for_dot_graph' ).value = '1250';
    document.getElementById( 'input_int_fig_size_y_for_dot_graph' ).value = '750';
    document.getElementById( 'input_int_margin_l_for_dot_graph' ).value = '150'; // '475';
    document.getElementById( 'input_int_margin_b_for_dot_graph' ).value = '50';
    
    document.getElementById( 'input_int_fig_size_x_for_word_cloud_graph' ).value = '1050';
    document.getElementById( 'input_int_fig_size_y_for_word_cloud_graph' ).value = '200';
    
    // figname
    document.getElementById( "input_str_name_panel_for_violin_graph" ).value = 'violin_plot';
    document.getElementById( "input_str_name_figure_for_violin_graph" ).value = '';
    
    document.getElementById( "input_str_name_panel_for_dot_graph" ).value = 'dot_plot';
    document.getElementById( "input_str_name_figure_for_dot_graph" ).value = '';
    
    document.getElementById( "input_str_name_panel_for_scatter_graph" ).value = 'scatter_plot';
    document.getElementById( "input_str_name_figure_for_scatter_graph" ).value = '';
    
    // marker size
    document.getElementById( 'input_int_marker_size_for_scatter' ).value = '3';
    document.getElementById( 'input_int_marker_size_for_dot_plot' ).value = '30';
    
    document.getElementById( "input_float_vmax" ).value = '5';
    Select_SelectOption_Using_ID( 'select_ramdata_object', 'https://scelephant-free.s3.amazonaws.com/ELDB.combined_v20221214.subset_160000_barcodes.ramdata/' ); // select ELDB database
    document.getElementById( "input_path_remote_ramdata" ).value =  'https://scelephant-free.s3.amazonaws.com/ELDB.combined_v20221214.subset_pbmc3k_alignment_primary_and_secondary_neighbors_and_20480000_subsampled_barcodes.ramdata/'; // example external object
    
    document.getElementById( "radio_select_type_graph" ).click( ); // select type of the graph
    SwitchAdvancedSetting( ); // modify layout based on the setting
    
    if ( flag_perform_demonstration ) {
        /*
        Demonstration
        */
        // load ELDB
        await LoadRamData( name_ramdata = 'ram', name_adata_default = 'adata' );
        await RetrieveAnnData( name_ramdata = 'ram' );


        // demonstrate violin plot
        document.getElementById( "input_str_name_panel_for_violin_graph" ).value = 'violin_plot';
        document.getElementById( "select_str_entry_ft" ).value = 'KRT5'; // 'CTRB1'; // 'PTPRC';
        document.getElementById( "select_annotations_bc_for_plot" ).value = 'metadata__CuratedAtlasQuery__cell_type_harmonised'; // 'disease' // 'anno__cell_and_tissue_type_level__of_leiden_filter_normalized_log1p_highly_variable_12000_excluding_degs_between_ebi_hca_and_ts_100comp_scanpy_embedding___resolution_0.8__based_on_cellmarker2db';
        document.getElementById( "radio_select_type_graph_violin" ).click( );
        await PlotAnnData( ); // plot graph
        // demonstrate dot plot
        document.getElementById( "input_str_name_panel_for_dot_graph" ).value = 'dot_plot';
        document.getElementById( "select_annotations_bc_for_plot" ).value = 'metadata__CuratedAtlasQuery__tissue_harmonised' // 'annotated_leiden_filter_normalized_log1p_for_embedding_10504_features_normalized_log1p_capped_100comp_filtered_barcodes_subsampled_10857942_entries_30knn100comp_scanpy__resolution_1_based_on_cellmarker2db';
        document.getElementById( "radio_select_type_graph_dot" ).click( );
        await PlotAnnData( ); // plot graph
        // demonstrate scatter plot
        document.getElementById( "input_str_name_panel_for_scatter_graph" ).value = 'scatter_plot';
        document.getElementById( "select_embedding_for_plot" ).value = "X_umap_filter_normalized_log1p_for_embedding_10504_features_normalized_log1p_capped_100comp_filtered_barcodes_subsampled_18097526_entries_30knn100comp_scanpy_spectral";
        document.getElementById( "select_str_entry_ft" ).value = 'KRT5'; // 'PTPRC';
        document.getElementById( "select_annotations_bc_for_plot" ).value = 'annotated_leiden_filter_normalized_log1p_for_embedding_10504_features_normalized_log1p_capped_100comp_filtered_barcodes_subsampled_10857942_entries_30knn100comp_scanpy__resolution_10_based_on_cellmarker2db' // 'anno__cell_and_tissue_type_level__of_leiden_filter_normalized_log1p_highly_variable_12000_excluding_degs_between_ebi_hca_and_ts_100comp_scanpy_embedding___resolution_0.8__based_on_cellmarker2db';
        document.getElementById( "radio_select_type_graph_feature_and_obs" ).click( );
        await PlotAnnData( ); // plot graph
    }
}

// simple selection filter for more straightfoward analysis of ELDB
function IncludeUsingPrefix( l, str_prefix ) { // include entries containing the prefix 
    let l_filtered = [ ], // initialize the output
        len_prefix = str_prefix.length
    for ( e of l ) {
        if ( e.length >= len_prefix ) {
            if ( e.slice( 0, len_prefix ) == str_prefix ) {
                l_filtered.push( e )
            }
        }
    }
    return l_filtered;
}
function ExcludeUsingPrefix( l, l_prefix ) { // include entries containing the prefix // if 'flag_exclude' is false
    let l_filtered = [ ], // initialize the output
        dict_prefix = { }; // set of prefix values
        dict_prefix_length = { }; // survey the lengths of the prefix 
    for ( prefix of l_prefix ) { // for each prefix
        dict_prefix_length[ prefix.length ] = prefix;
        dict_prefix[ prefix ] = prefix.length;
    }
    for ( e of l ) {
        let flag_prefix_found = false;
        for ( prefix_length in dict_prefix_length ) { // for each prefix length, check the prefix
            if ( e.slice( 0, prefix_length ) in dict_prefix ) {
                flag_prefix_found = true; // update the flag
            }
        }
        // if the prefix has been found, exclude from the output list
        if ( ! flag_prefix_found ) {
            l_filtered.push( e )
        }
    }
    return l_filtered;
}
    
// UI components for retrieving RamData, AnnData, visualize AnnData 
async function LoadRamData( name_ramdata = 'ram', name_adata_default = 'adata' ) {
    // get URL of the selected ramdata object
    let path_folder_ramdata,
        name_option_no_filter = dict_data.misc.name_option_no_filter;
    if ( document.getElementById( "input_ramdata_from_select" ).checked ) { // select ramdata from select component 
        path_folder_ramdata = Select_Get_Selected_Option_Using_ID( 'select_ramdata_object' ).value;
    } else if ( document.getElementById( "input_ramdata_from_text" ).checked ) { // select ramdata from text component
        path_folder_ramdata = document.getElementById( "input_path_remote_ramdata" ).value;
    }
    
    // set default adata name
    document.getElementById( "input_str_name_adata_output" ).value = name_adata_default;
    
    // load ramdata
    let ram = new RamData( path_folder_ramdata );
    dict_data[ 'dict_ramdata' ][ name_ramdata ] = ram; // add the reference
    await ram.initialize( ); // initialize the RamData
    
    // update axis labels
    document.getElementById( "div_repr_bc" ).innerHTML = `<h5>Barcode Axis <span class="badge text-bg-secondary">${ram.metadata[ 'int_num_barcodes' ]} entries</span></h5>`;
    document.getElementById( "div_repr_ft" ).innerHTML = `<h5>Feature Axis <span class="badge text-bg-secondary">${ram.metadata[ 'int_num_features' ]} entries</span></h5>`;
    
    // retrieve sorted lists of columns for bc and ft axes
    let l_name_col_bc = [ name_option_no_filter, ... ram.bc.meta.columns ], // default setting is no filter (all entries)
        l_name_col_ft = [ name_option_no_filter, ... ram.ft.meta.columns ], // default setting is no filter (all entries)
        l_name_layer = Object.keys( ram.layers );
    l_name_col_bc = l_name_col_bc.sort( );
    l_name_col_ft = l_name_col_ft.sort( );
    l_name_layer = l_name_layer.sort( );
    
    let metadata = ram.metadata;
    // remove options and tagify objects
    Select_RemoveOptions_Using_ID( 'select_filter_bc' );
    Select_RemoveOptions_Using_ID( 'select_filter_ft' );
    Select_RemoveOptions_Using_ID( 'select_layer' );
    Tagify_Destroy_UsingID( 'choose_annotations_bc' );
    Tagify_Destroy_UsingID( 'choose_embedding' );
    Tagify_Destroy_UsingID( 'input_str_gene_names' );

    // add appropriate options
    Select_AddOptions_Using_ID( 'select_filter_bc', [ name_option_no_filter, 'filtered_barcodes', ... IncludeUsingPrefix( l_name_col_bc, 'filter_' ) ] ); // 'filtered_barcodes' is the default filter name
    Select_AddOptions_Using_ID( 'select_filter_ft', [ name_option_no_filter, ... IncludeUsingPrefix( l_name_col_ft, 'filter_' ) ] ); 
    Select_AddOptions_Using_ID( 'select_layer', l_name_layer ); 
    Tagify_Initialize_UsingID( 'choose_annotations_bc', true, ExcludeUsingPrefix( l_name_col_bc, [ 'X_umap_', 'X_pca_', 'filter_' ] ), false, 20, 20 ); 
    Tagify_Initialize_UsingID( 'choose_embedding', true, IncludeUsingPrefix( l_name_col_bc, 'X_umap_' ), false, 20, 20 ); 
    if ( metadata[ 'default-ft-load_str' ] ) { // if feature axis string representations are loaded by default, use the string representations of the feature axis as the white list
        let arr_str_rep_ft = await ram.ft.load_str( );
        Tagify_Initialize_UsingID( 'input_str_gene_names', true, arr_str_rep_ft, false, 50, 50 ); 
    } else { // if string representations are not loaded by default, disable the white-list-enforcing feature.
        Tagify_Initialize_UsingID( 'input_str_gene_names', false, [ ], false, 50, 50 ); 
    }
    
    // select default filters
    Select_SelectOption_Using_ID( 'select_filter_bc', check_none( metadata[ 'default-bc-filter' ] ) ? name_option_no_filter : metadata[ 'default-bc-filter' ] );
    Select_SelectOption_Using_ID( 'select_filter_ft', check_none( metadata[ 'default-ft-filter' ] ) ? name_option_no_filter : metadata[ 'default-ft-filter' ] );
    Select_SelectOption_Using_ID( 'select_layer', metadata[ 'default-layer' ] ); 
    Tagify_AddTags_UsingID( 'choose_annotations_bc', metadata[ 'default-bc-l_name_col_of_obs' ] ); 
    Tagify_AddTags_UsingID( 'choose_embedding', metadata[ 'default-bc-l_name_col_of_obsm' ] ); 
    Tagify_AddTags_UsingID( 'input_str_gene_names', metadata['default-ft-l_str_repr'] ); 
    
    // close current panel
    dict_data.bs_components.offcanvasLoadRamData.hide( );
    // show next panel
    dict_data.bs_components.offcanvasRetrieveAnnData.show( );
}
    
function UpdatePanelPlotAnnData( ) {
    /*
    update the panel for plotting AnnData for the AnnData currently selected in 'select_adata'
    */
    let name_anndata = Select_Get_Selected_Option_Using_ID( 'select_adata' ).value, // retrieve name of the selected AnnData
        adata = dict_data[ 'dict_anndata' ][ name_anndata ], // retrieve anndata
        l_str_entry_ft = adata.var.get_column( 'str' ).sort( ), // retrieve list of str_entry_ft
        l_name_col_obs = [ ... difference( adata.obs.columns, new Set( [ 'str' ] ) ) ].sort( ),
        l_name_col_obsm = Object.keys( adata.obsm );
    
    // reset options
    Select_RemoveOptions_Using_ID( 'select_str_entry_ft' );
    Select_RemoveOptions_Using_ID( 'select_annotations_bc_for_plot' );
    Select_RemoveOptions_Using_ID( 'select_embedding_for_plot' );
    
    // add appropriate options
    Select_AddOptions_Using_ID( 'select_str_entry_ft', l_str_entry_ft ); 
    Select_AddOptions_Using_ID( 'select_annotations_bc_for_plot', l_name_col_obs ); 
    Select_AddOptions_Using_ID( 'select_embedding_for_plot', l_name_col_obsm ); 
    
    UpdateCategories( );// update categories
    
    // set appropriate default input feature representations
    Tagify_Destroy_UsingID( 'input_l_str_entry_ft_for_plotting' );
    
    if ( dict_data.misc.int_max_num_tags >= l_str_entry_ft.length ) {
        Tagify_Initialize_UsingID( 'input_l_str_entry_ft_for_plotting', true, l_str_entry_ft, true, 100, 50 ); // enable drag-sort
        Tagify_AddTags_UsingID( 'input_l_str_entry_ft_for_plotting', l_str_entry_ft ); 
    } else {
        // if the number of tags exceeds the limit, use (fall back to) the simple text area 
        document.getElementById( 'input_l_str_entry_ft_for_plotting' ).value = l_str_entry_ft.join( ', ' );
    }
    
    // set l_annotations_bc_for_plot
    Tagify_Destroy_UsingID( 'input_l_annotations_bc_for_plot' );
    
    if ( dict_data.misc.int_max_num_tags >= l_name_col_obs.length ) {
        Tagify_Initialize_UsingID( 'input_l_annotations_bc_for_plot', true, l_name_col_obs, true, 100, 50 ); // enable drag-sort
        Tagify_AddTags_UsingID( 'input_l_annotations_bc_for_plot', l_name_col_obs ); 
    } else {
        // if the number of tags exceeds the limit, use (fall back to) the simple text area 
        document.getElementById( 'input_l_annotations_bc_for_plot' ).value = l_name_col_obs.join( ', ' );
    }
}
    
async function RetrieveAnnData( name_ramdata = 'ram' ) {
    /*
    Retrieve AnnData and set attributes for the next panel
    */
    // disable the button while retrieving the anndata
    document.getElementById( 'button_for_retrieving_anndata' ).disabled = true;
    document.getElementById( 'button_for_retrieving_anndata' ).innerHTML = `Retrieve AnnData  <div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>`; // add spinner indicating ramdata is being retrieved       
    
    // retrieve RamData
    let ram = dict_data[ 'dict_ramdata' ][ name_ramdata ],
        name_option_no_filter = dict_data.misc.name_option_no_filter;
    
    // retrieve list of input columns and values
    let name_col_filter_bc = Select_Get_Selected_Option_Using_ID( 'select_filter_bc' ).value,
        l_name_col_obs = Tagify_GetTagTitles_UsingID( 'choose_annotations_bc' ).sort( ),
        l_name_col_obsm = Tagify_GetTagTitles_UsingID( 'choose_embedding' ).sort( ),
        name_col_filter_ft = Select_Get_Selected_Option_Using_ID( 'select_filter_ft' ).value,
        name_layer = Select_Get_Selected_Option_Using_ID( 'select_layer' ).value,
        name_anndata = document.getElementById( 'input_str_name_adata_output' ).value,
        l_str_entry_feature = Tagify_GetTagTitles_UsingID( 'input_str_gene_names' ).map( ( e ) => { return e.trim( ); } ).filter( e => e.length > 0 ); // retrieve a list of string representations of the entries of the feature axis // filter out invalid entries (zero length)

    // load barcode filter
    if ( name_col_filter_bc != name_option_no_filter ) {
        await ram.bc.change_filter( name_col_filter_bc );
    } else {
        ram.bc.filter = null; // reset the filter
    }
    // load feature filter
    if ( name_col_filter_ft != name_option_no_filter ) {
        await ram.ft.change_filter( name_col_filter_ft )
    } else {
        ram.ft.filter = null; // reset the filter
    }
    // create view before retrieving data
    ram.ft.create_view( )
    
    // load string representations of the feature axis
    await ram.ft.load_str( )
    
    // retrieve anndata and plotting functions
    let adata = await ram.get_item( [ name_layer, [ ], [ l_name_col_obsm, ... l_name_col_obs ], l_str_entry_feature, [ 'str' ] ] )
    adata.uns[ 'ram' ] = ram; // add reference to the original RamData object for call back functions
    dict_data[ 'dict_anndata' ][ name_anndata ] = adata; // add the reference

    // update adata select options
    let l_name_adata = Object.keys( dict_data[ 'dict_anndata' ] ).sort( ); // retrieve list of available name_adata
    Select_RemoveOptions_Using_ID( 'select_adata' ); // reset options
    Select_AddOptions_Using_ID( 'select_adata', l_name_adata ); // add appropriate options
    
    // update panel for plotting AnnData
    UpdatePanelPlotAnnData( );
    
    // enable the button once the anndata was retrieved
    document.getElementById( 'button_for_retrieving_anndata' ).innerHTML = `Retrieve AnnData`; // remove the spinner
    document.getElementById( 'button_for_retrieving_anndata' ).disabled = false;
    
    // close current panel
    dict_data.bs_components.offcanvasRetrieveAnnData.hide( );
    // show next panel
    dict_data.bs_components.offcanvasPlotAnnData.show( );
}
    
async function PlotAnnData( ) {
    // retrieve list of input columns and values
    let name_anndata = Select_Get_Selected_Option_Using_ID( 'select_adata' ).value,
        name_col_obsm = Select_Get_Selected_Option_Using_ID( 'select_embedding_for_plot' ).value,
        str_entry_ft = Select_Get_Value_from_Option( Select_Get_Selected_Option_Using_ID( 'select_str_entry_ft' ) ),
        name_col_obs = Select_Get_Value_from_Option( Select_Get_Selected_Option_Using_ID( 'select_annotations_bc_for_plot' ) ),
        flag_responsive_marker_size = document.getElementById( 'switch_responsive_marker_size_or_static' ).checked,
        int_marker_size_for_scatter_plot = parseInt( document.getElementById( 'input_int_marker_size_for_scatter' ).value ),
        input_int_marker_size_for_dot_plot = parseInt( document.getElementById( 'input_int_marker_size_for_dot_plot' ).value ),        
        input_float_vmax = parseFloat( document.getElementById( 'input_float_vmax' ).value ),
        l_str_entry_feature = Tagify_check_Tagify_UsingID( 'input_l_str_entry_ft_for_plotting' ) ? Tagify_GetTagTitles_UsingID( 'input_l_str_entry_ft_for_plotting' ) : document.getElementById( 'input_l_str_entry_ft_for_plotting' ).value.split( ',' ).map( ( e ) => { return e.trim( ); } ).filter( e => e.length > 0 ), // retrieve values from either tagify object or simple text area
        l_name_category_in_col_obs = Tagify_check_Tagify_UsingID( 'input_l_category_for_plotting' ) ? Tagify_GetTagTitles_UsingID( 'input_l_category_for_plotting' ) : document.getElementById( 'input_l_category_for_plotting' ).value.split( ',' ).map( ( e ) => { return e.trim( ); } ).filter( e => e.length > 0 ), // retrieve values from either tagify object or simple text area
        l_name_col_obs = Tagify_check_Tagify_UsingID( 'input_l_annotations_bc_for_plot' ) ? Tagify_GetTagTitles_UsingID( 'input_l_annotations_bc_for_plot' ) : document.getElementById( 'input_l_annotations_bc_for_plot' ).value.split( ',' ).map( ( e ) => { return e.trim( ); } ).filter( e => e.length > 0 ), // retrieve values from either tagify object or simple text area
        
        // figsize settings
        int_fig_size_x_for_scatter_graph = parseInt( document.getElementById( 'input_int_fig_size_x_for_scatter_graph' ).value ),
        int_fig_size_y_for_scatter_graph = parseInt( document.getElementById( 'input_int_fig_size_y_for_scatter_graph' ).value ),
        int_margin_l_for_scatter_graph = parseInt( document.getElementById( 'input_int_margin_l_for_scatter_graph' ).value ),
        int_margin_b_for_scatter_graph = parseInt( document.getElementById( 'input_int_margin_b_for_scatter_graph' ).value ),
    
        int_fig_size_x_for_violin_graph = parseInt( document.getElementById( 'input_int_fig_size_x_for_violin_graph' ).value ),
        int_fig_size_y_for_violin_graph = parseInt( document.getElementById( 'input_int_fig_size_y_for_violin_graph' ).value ),
        int_margin_l_for_violin_graph = parseInt( document.getElementById( 'input_int_margin_l_for_violin_graph' ).value ),
        int_margin_b_for_violin_graph = parseInt( document.getElementById( 'input_int_margin_b_for_violin_graph' ).value ),
    
        int_fig_size_x_for_dot_graph = parseInt( document.getElementById( 'input_int_fig_size_x_for_dot_graph' ).value ),
        int_fig_size_y_for_dot_graph = parseInt( document.getElementById( 'input_int_fig_size_y_for_dot_graph' ).value ),
        int_margin_l_for_dot_graph = parseInt( document.getElementById( 'input_int_margin_l_for_dot_graph' ).value ),
        int_margin_b_for_dot_graph = parseInt( document.getElementById( 'input_int_margin_b_for_dot_graph' ).value ),

        int_fig_size_x_for_word_cloud_graph = parseInt( document.getElementById( 'input_int_fig_size_x_for_word_cloud_graph' ).value ),
        int_fig_size_y_for_word_cloud_graph = parseInt( document.getElementById( 'input_int_fig_size_y_for_word_cloud_graph' ).value ),

        // figname and panel name settings
        str_name_panel_for_scatter_graph = document.getElementById( 'input_str_name_panel_for_scatter_graph' ).value,
        str_name_figure_for_scatter_graph = document.getElementById( 'input_str_name_figure_for_scatter_graph' ).value,

        str_name_panel_for_violin_graph = document.getElementById( 'input_str_name_panel_for_violin_graph' ).value,
        str_name_figure_for_violin_graph = document.getElementById( 'input_str_name_figure_for_violin_graph' ).value,

        str_name_panel_for_dot_graph = document.getElementById( 'input_str_name_panel_for_dot_graph' ).value,
        str_name_figure_for_dot_graph = document.getElementById( 'input_str_name_figure_for_dot_graph' ).value,
        
        adata = dict_data[ 'dict_anndata' ][ name_anndata ], // retrieve the reference
        dict_key_args_for_draw_graph = { 'name_feature' : str_entry_ft, 'name_col_obs' : name_col_obs, 'name_col_embedding' : name_col_obsm, 'flag_responsive_marker_size' : flag_responsive_marker_size, 'margin' : { l : int_margin_l_for_scatter_graph, b : int_margin_b_for_scatter_graph }, 'fig_size' : [ int_fig_size_x_for_scatter_graph, int_fig_size_y_for_scatter_graph ], 'vmax' : isNaN( input_float_vmax ) ? undefined : input_float_vmax, 'marker_size_for_scatter_plot' : isNaN( int_marker_size_for_scatter_plot ) ? 3 : int_marker_size_for_scatter_plot, 'marker_size_for_dot_plot' : isNaN( input_int_marker_size_for_dot_plot ) ? 3 : input_int_marker_size_for_dot_plot, 'fig_size_word_cloud' : [ int_fig_size_x_for_word_cloud_graph, int_fig_size_y_for_word_cloud_graph ], 'l_name_col_obs' : l_name_col_obs }; // keyworded arguments for the draw_graph function
    
    // draw graph
    if ( document.getElementById( 'radio_select_type_graph_feature' ).checked ) { // plot feature values
        draw_graph( str_name_panel_for_scatter_graph, adata, { ... dict_key_args_for_draw_graph, 'name_type_graph' : 'scatter', 'title' : str_name_figure_for_scatter_graph, 'flag_recreate_div' : true, 'flag_plot_feature' : true, 'flag_create_legend_toggle_button' : false, 'flag_create_word_cloud_toggle_button' : true, 'flag_create_download_selected_cells_button' : true } ); // no legend is required for feature plot
    } else if ( document.getElementById( 'radio_select_type_graph_obs' ).checked ) { // plot annotation values
        draw_graph( str_name_panel_for_scatter_graph, adata, { ... dict_key_args_for_draw_graph, 'name_type_graph' : 'scatter', 'title' : str_name_figure_for_scatter_graph, 'flag_recreate_div' : true, 'flag_plot_feature' : false, 'flag_create_legend_toggle_button' : true, 'flag_create_word_cloud_toggle_button' : true, 'flag_create_download_selected_cells_button' : true } );
    } else if ( document.getElementById( 'radio_select_type_graph_feature_and_obs' ).checked ) { // plot both feature and annotations
        let name_panel = str_name_panel_for_scatter_graph; // retrieve the name of the panel
        // initialize div (dual graphs)
        create_div( name_panel, style = `width:${int_fig_size_x_for_scatter_graph}px;height:${int_fig_size_y_for_scatter_graph}px;`, flag_create_dual_div = true, flag_create_legend_toggle_button = true, flag_create_word_cloud_toggle_button = true, flag_create_download_selected_cells_button = true, int_fig_size_x_for_word_cloud_graph, int_fig_size_y_for_word_cloud_graph,  );
            
        // draw graphs without re-creating div
        draw_graph( `${name_panel}__top__`, adata, { ... dict_key_args_for_draw_graph, 'name_type_graph' : 'scatter', 'title' : str_name_figure_for_scatter_graph, 'flag_recreate_div' : false, 'flag_plot_feature' : false, 'flag_create_legend_toggle_button' : false, 'flag_create_word_cloud_toggle_button' : false } );
        draw_graph( `${name_panel}__bottom__`, adata, { ... dict_key_args_for_draw_graph, 'name_type_graph' : 'scatter', 'title' : str_name_figure_for_scatter_graph, 'flag_recreate_div' : false, 'flag_plot_feature' : true, 'flag_create_legend_toggle_button' : false, 'flag_create_word_cloud_toggle_button' : false } );
        
        // sync two plots
        let l_div_plotly = [ document.getElementById( `${name_panel}__top__` ), document.getElementById( `${name_panel}__bottom__` ) ];
        for ( let div of l_div_plotly ) { // for each division with plotly graphs
            div.on( "plotly_relayout" , function( ed ) { // add event listner for synchronizing layouts
                synchronized_layout( ed, l_div_plotly );
            });
        }
    } else if ( document.getElementById( 'radio_select_type_graph_violin' ).checked ) { // plot violin plots using both feature and annotation data
        draw_graph( str_name_panel_for_violin_graph, adata, { ... dict_key_args_for_draw_graph, 'name_type_graph' : 'violin', 'title' : str_name_figure_for_violin_graph, 'flag_recreate_div' : true, 'flag_plot_feature' : true, 'l_name_category_in_col_obs' : l_name_category_in_col_obs, 'fig_size' : [ int_fig_size_x_for_violin_graph, int_fig_size_y_for_violin_graph ], 'margin' : { l : int_margin_l_for_violin_graph, b : int_margin_b_for_violin_graph }, 'flag_create_legend_toggle_button' : true, 'flag_create_word_cloud_toggle_button' : true, 'flag_create_download_selected_cells_button' : false } );
    } else if ( document.getElementById( 'radio_select_type_graph_dot' ).checked ) { // plot dot plots using both feature and annotation data
        draw_graph( str_name_panel_for_dot_graph, adata, { ... dict_key_args_for_draw_graph, 'name_type_graph' : 'dot', 'title' : str_name_figure_for_dot_graph, 'flag_recreate_div' : true, 'flag_plot_feature' : undefined, 'l_str_entry_feature' : l_str_entry_feature, 'l_name_category_in_col_obs' : l_name_category_in_col_obs, 'fig_size' : [ int_fig_size_x_for_dot_graph, int_fig_size_y_for_dot_graph ], 'margin' : { l : int_margin_l_for_dot_graph, b : int_margin_b_for_dot_graph }, 'flag_create_legend_toggle_button' : false, 'flag_create_word_cloud_toggle_button' : false, 'flag_create_download_selected_cells_button' : false } ); // no legend is required for dot plot
    }
//     // close current panel
//     dict_data.bs_components.offcanvasPlotAnnData.hide( );
}
    
// for increasing interactivity
function UpdateCategories( ) {
    /*
    update categories of 'input_l_category_for_plotting' based on 'select_annotations_bc_for_plot'
    */
    let name_anndata = Select_Get_Selected_Option_Using_ID( 'select_adata' ).value,
        name_col_obs = Select_Get_Value_from_Option( Select_Get_Selected_Option_Using_ID( 'select_annotations_bc_for_plot' ) ),
        adata = dict_data[ 'dict_anndata' ][ name_anndata ], // retrieve the reference
        l_val_obs = adata.obs.get_column( name_col_obs ); // retrieve barcode annotations
    
    if ( l_val_obs.length == 0 ) { // check adata has a valid number of entries
        return;
    }
    if ( typeof l_val_obs[ 0 ] == 'number' ) { // check 'l_val_obs' contains string values
        document.getElementById( 'input_l_category_for_plotting' ).value = '(current annotation contains continuous values)'; // empty the input field
        return;
    }
        
    let set_val_obs = new Set( l_val_obs ); // retrieve unique values
    // handle None values
    for ( let e of [ undefined, null ] ) { // for each value representing 'None'
        if ( set_val_obs.has( e ) ) { // replace the value with the unified string value representing 'None'
            set_val_obs.delete( e )
            set_val_obs.add( dict_data.misc.name_none ); // add value represenging 'None' values
        }
    }
    // set 'input_l_category_for_plotting'
    let l_category = [ ... set_val_obs ].sort( ); // sort by string
    Tagify_Destroy_UsingID( 'input_l_category_for_plotting' );
    if ( dict_data.misc.int_max_num_tags >= l_category.length ) {
        Tagify_Initialize_UsingID( 'input_l_category_for_plotting', true, l_category, true, dict_data.misc.int_max_num_tags, 50 ); // enable drag-sort
        Tagify_AddTags_UsingID( 'input_l_category_for_plotting', l_category ); 
        console.log( `updating categories using ${l_category.length} number of categories`  );
    } else {
        // if the number of tags exceeds the limit, use (fall back to) the simple text area 
        document.getElementById( 'input_l_category_for_plotting' ).value = l_category.join( ', ' );
    }
}

function SwitchAdvancedSetting( ) {
    /*
    switch between advanced setting and simple setting
    */
    let flag_advanced_mode = document.getElementById( 'switch_simple_or_advanced' ).checked; // retrieve a flag indicating advanced mode is active
    
    document.getElementById( 'panel_figure_setting_advanced' ).hidden = ! flag_advanced_mode;
    document.getElementById( 'panel_select_layer' ).hidden = ! flag_advanced_mode;    
    document.getElementById( 'panel_input_str_name_adata_output' ).hidden = ! flag_advanced_mode;
    document.getElementById( 'panel_select_filter_ft' ).hidden = ! flag_advanced_mode;
    document.getElementById( 'plotting_panel_data_setting_advanced' ).hidden = ! flag_advanced_mode;
    document.getElementById( 'plotting_panel_select_adata' ).hidden = ! flag_advanced_mode;
}
    
function RearrangePlottingPanel( ) {
    /*
    rearrange plotting panel appropriate for each graph type for better interactivity.
    also change the graph type name
    */
    // draw graph
    if ( document.getElementById( 'radio_select_type_graph_feature' ).checked ) { // plot feature values
        // setting for the plot button & selecting adata
        document.getElementById( 'button_plot_anndata' ).disabled = false;
        document.getElementById( 'select_adata' ).disabled = false;
        document.getElementById( 'name_graph_type' ).innerHTML = "<h4>Scatter Plot - Feature</h4>"; // set graph type name
        
        document.getElementById( 'plotting_panel_select_str_entry_ft' ).hidden = false;
        document.getElementById( 'plotting_panel_input_l_str_entry_ft_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_select_annotations_bc_for_plot' ).hidden = true;
        document.getElementById( 'plotting_panel_select_l_annotations_bc_for_plot' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_category_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_input_float_vmax' ).hidden = false;
        document.getElementById( 'plotting_panel_title_coordinates' ).hidden = false;
        document.getElementById( 'plotting_panel_select_embedding_for_plot' ).hidden = false;
        
        document.getElementById( 'plotting_panel_title_marker_size' ).hidden = false;
        document.getElementById( 'plotting_panel_switch_responsive_marker_size_or_static' ).hidden = false;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_scatter' ).hidden = false;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_dot_plot' ).hidden = true;
        
        // figsize setting
        document.getElementById( 'panel_figure_size_and_margin_setting_for_scatter_graph' ).hidden = false;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_dot_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_word_cloud_graph' ).hidden = true;
        
        // figname setting
        document.getElementById( 'panel_figure_name_setting_for_scatter_graph' ).hidden = false;
        document.getElementById( 'panel_figure_name_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_dot_graph' ).hidden = true;
        
    } else if ( document.getElementById( 'radio_select_type_graph_obs' ).checked ) { // plot annotation values
        // setting for the plot button & selecting adata
        document.getElementById( 'button_plot_anndata' ).disabled = false;
        document.getElementById( 'select_adata' ).disabled = false;
        document.getElementById( 'name_graph_type' ).innerHTML = "<h4>Scatter Plot - Barcode Annotations</h4>"; // set graph type name
        
        document.getElementById( 'plotting_panel_select_str_entry_ft' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_str_entry_ft_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_select_annotations_bc_for_plot' ).hidden = false;
        document.getElementById( 'plotting_panel_select_l_annotations_bc_for_plot' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_category_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_input_float_vmax' ).hidden = false;
        document.getElementById( 'plotting_panel_title_coordinates' ).hidden = false;
        document.getElementById( 'plotting_panel_select_embedding_for_plot' ).hidden = false;
        
        document.getElementById( 'plotting_panel_title_marker_size' ).hidden = false;
        document.getElementById( 'plotting_panel_switch_responsive_marker_size_or_static' ).hidden = false;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_scatter' ).hidden = false;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_dot_plot' ).hidden = true;
        
        // figsize setting
        document.getElementById( 'panel_figure_size_and_margin_setting_for_scatter_graph' ).hidden = false;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_dot_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_word_cloud_graph' ).hidden = true;
        
        // figname setting
        document.getElementById( 'panel_figure_name_setting_for_scatter_graph' ).hidden = false;
        document.getElementById( 'panel_figure_name_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_dot_graph' ).hidden = true;
        
    } else if ( document.getElementById( 'radio_select_type_graph_feature_and_obs' ).checked ) { // plot both feature and annotations
        // setting for the plot button & selecting adata
        document.getElementById( 'button_plot_anndata' ).disabled = false;
        document.getElementById( 'select_adata' ).disabled = false;
        document.getElementById( 'name_graph_type' ).innerHTML = "<h4>Scatter Plot - Feature and Annotations</h4>"; // set graph type name
        
        document.getElementById( 'plotting_panel_select_str_entry_ft' ).hidden = false;
        document.getElementById( 'plotting_panel_input_l_str_entry_ft_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_select_annotations_bc_for_plot' ).hidden = false;
        document.getElementById( 'plotting_panel_select_l_annotations_bc_for_plot' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_category_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_input_float_vmax' ).hidden = false;
        document.getElementById( 'plotting_panel_title_coordinates' ).hidden = false;
        document.getElementById( 'plotting_panel_select_embedding_for_plot' ).hidden = false;
        
        document.getElementById( 'plotting_panel_title_marker_size' ).hidden = false;
        document.getElementById( 'plotting_panel_switch_responsive_marker_size_or_static' ).hidden = false;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_scatter' ).hidden = false;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_dot_plot' ).hidden = true;
        
        // figsize setting
        document.getElementById( 'panel_figure_size_and_margin_setting_for_scatter_graph' ).hidden = false;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_dot_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_word_cloud_graph' ).hidden = true;
        
        // figname setting
        document.getElementById( 'panel_figure_name_setting_for_scatter_graph' ).hidden = false;
        document.getElementById( 'panel_figure_name_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_dot_graph' ).hidden = true;
        
    } else if ( document.getElementById( 'radio_select_type_graph_violin' ).checked ) { // plot violin plots using both feature and annotation data
        // setting for the plot button & selecting adata
        document.getElementById( 'button_plot_anndata' ).disabled = false;
        document.getElementById( 'select_adata' ).disabled = false;
        document.getElementById( 'name_graph_type' ).innerHTML = "<h4>Violin Plot</h4>"; // set graph type name
        
        document.getElementById( 'plotting_panel_select_str_entry_ft' ).hidden = false;
        document.getElementById( 'plotting_panel_input_l_str_entry_ft_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_select_annotations_bc_for_plot' ).hidden = false;
        document.getElementById( 'plotting_panel_select_l_annotations_bc_for_plot' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_category_for_plotting' ).hidden = false;
        document.getElementById( 'plotting_panel_input_float_vmax' ).hidden = true;
        document.getElementById( 'plotting_panel_title_coordinates' ).hidden = true;
        document.getElementById( 'plotting_panel_select_embedding_for_plot' ).hidden = true;
        
        document.getElementById( 'plotting_panel_title_marker_size' ).hidden = true;
        document.getElementById( 'plotting_panel_switch_responsive_marker_size_or_static' ).hidden = true;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_scatter' ).hidden = true;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_dot_plot' ).hidden = true;
        
        // figsize setting
        document.getElementById( 'panel_figure_size_and_margin_setting_for_scatter_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_violin_graph' ).hidden = false;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_dot_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_word_cloud_graph' ).hidden = true;
        
        // figname setting
        document.getElementById( 'panel_figure_name_setting_for_scatter_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_violin_graph' ).hidden = false;
        document.getElementById( 'panel_figure_name_setting_for_dot_graph' ).hidden = true;
        
        UpdateCategories( ); // update categories
        
    } else if ( document.getElementById( 'radio_select_type_graph_dot' ).checked ) { // plot dot plots using both feature and annotation data
        // setting for the plot button & selecting adata
        document.getElementById( 'button_plot_anndata' ).disabled = false;
        document.getElementById( 'select_adata' ).disabled = false;
        document.getElementById( 'name_graph_type' ).innerHTML = "<h4>Dot Plot</h4>"; // set graph type name
        
        document.getElementById( 'plotting_panel_select_str_entry_ft' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_str_entry_ft_for_plotting' ).hidden = false;
        document.getElementById( 'plotting_panel_select_annotations_bc_for_plot' ).hidden = false;
        document.getElementById( 'plotting_panel_select_l_annotations_bc_for_plot' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_category_for_plotting' ).hidden = false;
        document.getElementById( 'plotting_panel_input_float_vmax' ).hidden = true;
        document.getElementById( 'plotting_panel_title_coordinates' ).hidden = true;
        document.getElementById( 'plotting_panel_select_embedding_for_plot' ).hidden = true;
        
        document.getElementById( 'plotting_panel_title_marker_size' ).hidden = false;
        document.getElementById( 'plotting_panel_switch_responsive_marker_size_or_static' ).hidden = true;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_scatter' ).hidden = true;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_dot_plot' ).hidden = false;
        
        // figsize setting
        document.getElementById( 'panel_figure_size_and_margin_setting_for_scatter_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_dot_graph' ).hidden = false;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_word_cloud_graph' ).hidden = true;
        
        // figname setting
        document.getElementById( 'panel_figure_name_setting_for_scatter_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_dot_graph' ).hidden = false;
        
        UpdateCategories( ); // update categories
    } else if ( document.getElementById( 'radio_select_type_graph_word_cloud' ).checked ) { // update settings for word cloud plotting functions
        // setting for the plot button & selecting adata
        document.getElementById( 'button_plot_anndata' ).disabled = true;
        document.getElementById( 'select_adata' ).disabled = true;
        document.getElementById( 'name_graph_type' ).innerHTML = "<h4>Word Cloud (Topic Exploration)</h4>"; // set graph type name
        
        document.getElementById( 'plotting_panel_select_str_entry_ft' ).hidden = true;
        document.getElementById( 'plotting_panel_input_l_str_entry_ft_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_select_annotations_bc_for_plot' ).hidden = true;
        document.getElementById( 'plotting_panel_select_l_annotations_bc_for_plot' ).hidden = false;
        document.getElementById( 'plotting_panel_input_l_category_for_plotting' ).hidden = true;
        document.getElementById( 'plotting_panel_input_float_vmax' ).hidden = true;
        document.getElementById( 'plotting_panel_title_coordinates' ).hidden = true;
        document.getElementById( 'plotting_panel_select_embedding_for_plot' ).hidden = true;
        
        document.getElementById( 'plotting_panel_title_marker_size' ).hidden = true;
        document.getElementById( 'plotting_panel_switch_responsive_marker_size_or_static' ).hidden = true;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_scatter' ).hidden = true;
        document.getElementById( 'plotting_panel_input_int_marker_size_for_dot_plot' ).hidden = true;
        
        // figsize setting
        document.getElementById( 'panel_figure_size_and_margin_setting_for_scatter_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_dot_graph' ).hidden = true;
        document.getElementById( 'panel_figure_size_and_margin_setting_for_word_cloud_graph' ).hidden = false;
        
        // figname setting
        document.getElementById( 'panel_figure_name_setting_for_scatter_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_violin_graph' ).hidden = true;
        document.getElementById( 'panel_figure_name_setting_for_dot_graph' ).hidden = true;
        
        UpdateCategories( ); // update categories
    }
}
    
/* 
Hot-key settings
*/
function stopPropagation(e)
{
    e = e || event;/* get IE event ( not passed ) */
    e.stopPropagation? e.stopPropagation() : e.cancelBubble = true;
}
hotkeys( 'alt+q,alt+w,alt+e,alt+r,ctrl+i,command+i', function ( event, handler ) {
    // disable defaults
    event.preventDefault( );
    event.returnValue = false;
    stopPropagation( event );
    switch ( handler.key ) {
        case 'alt+q': 
        case 'option+q': 
            dict_data.bs_components.offcanvasLoadRamData.toggle( );
            break;
        case 'alt+w': 
        case 'option+w': 
            dict_data.bs_components.offcanvasRetrieveAnnData.toggle( );
            break;
        case 'alt+e': 
        case 'option+e': 
            dict_data.bs_components.offcanvasPlotAnnData.toggle( );
            break;
        case 'alt+r': 
        case 'option+r': 
            PlotAnnData( );
            break;
        case 'ctrl+i': 
        case 'command+i': 
            dict_data.bs_components.modal_introduction.toggle( );
            break;
        default: alert( event );
    }
}); 
    
/*
Start a Tutorial
*/
function Scroll_to_the_Top( ) {
    document.body.scrollTop = 0; // For Safari
    document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
function StartTutorial( ) {
    /*
    start tutorial
    */
    // hide all panels
    dict_data.bs_components.offcanvasLoadRamData.hide( );
    dict_data.bs_components.offcanvasRetrieveAnnData.hide( );
    dict_data.bs_components.offcanvasPlotAnnData.hide( );
    
    // hide the previous models
    dict_data.bs_components.modal_introduction.hide( );
    dict_data.bs_components.modal_for_tutorial_ramdata.hide( )
    
    // open the current models
    dict_data.bs_components.modal_for_tutorial_intro.show( );
    
    // move to the top of the application
    Scroll_to_the_Top( );
}
function StartTutorialRamData( ) {
    /*
    StartTutorialRamData
    */
    // hide all panels
    dict_data.bs_components.offcanvasLoadRamData.show( );
    dict_data.bs_components.offcanvasRetrieveAnnData.hide( );
    dict_data.bs_components.offcanvasPlotAnnData.hide( );
    
    // hide the previous models
    dict_data.bs_components.modal_for_tutorial_intro.hide( );
    dict_data.bs_components.modal_for_tutorial_anndata.hide( )
    
    // open the current model
    dict_data.bs_components.modal_for_tutorial_ramdata.show( );
}
function StartTutorialAnnData( ) {
    /*
    StartTutorialAnnData
    */
    // hide all panels
    dict_data.bs_components.offcanvasLoadRamData.hide( );
    dict_data.bs_components.offcanvasRetrieveAnnData.show( );
    dict_data.bs_components.offcanvasPlotAnnData.hide( );
    
    // hide the previous models
    dict_data.bs_components.modal_for_tutorial_ramdata.hide( );
    dict_data.bs_components.modal_for_tutorial_plot_anndata.hide( )
    
    // open the current model
    dict_data.bs_components.modal_for_tutorial_anndata.show( );
}
function StartTutorialPlotAnnData( ) {
    /*
    StartTutorialPlotAnnData
    */
    // hide all panels
    dict_data.bs_components.offcanvasLoadRamData.hide( );
    dict_data.bs_components.offcanvasRetrieveAnnData.hide( );
    dict_data.bs_components.offcanvasPlotAnnData.show( );
    
    // hide the previous models
    dict_data.bs_components.modal_for_tutorial_anndata.hide( );
    dict_data.bs_components.modal_keyboard_shortcuts.hide( )
    
    // open the current model
    dict_data.bs_components.modal_for_tutorial_plot_anndata.show( );
}
function CompleteTutorial( ) {
    /*
    CompleteTutorial
    */
    // hide the previous models
    dict_data.bs_components.modal_for_tutorial_plot_anndata.hide( );
    
    // open the current model
    dict_data.bs_components.modal_keyboard_shortcuts.show( );
}
    
</script>
</html>









































